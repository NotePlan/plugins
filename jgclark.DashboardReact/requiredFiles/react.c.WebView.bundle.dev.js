var WebViewBundle = (function (exports, React) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  /**
   * A reusable button component.
   */
  function Button(props) {
    const {
      text,
      clickHandler,
      className
    } = props;
    return /*#__PURE__*/React__default["default"].createElement("button", {
      onClick: clickHandler,
      className: className
    }, text);
  }

  // This is a context provider for the app. You should generally not need to edit this file.

  /**
   * Type definitions for the application context.
   */

  // Default context value with initial reactSettings and functions.
  const defaultContextValue = {
    sendActionToPlugin: () => {},
    sendToPlugin: () => {},
    dispatch: () => {},
    pluginData: {},
    reactSettings: {},
    // Initial empty reactSettings local
    updateReactSettings: () => {},
    // Placeholder function, actual implementation below.
    updatePluginData: () => {} // Placeholder function, actual implementation below.
  };

  /**
   * Create the context with the default value.
   */
  const AppContext = /*#__PURE__*/React.createContext(defaultContextValue);

  // Explicitly annotate the return type of AppProvider as a React element
  const AppProvider = ({
    children,
    sendActionToPlugin,
    sendToPlugin,
    dispatch,
    pluginData,
    updatePluginData
  }) => {
    const reactSettings = pluginData.reactSettings;

    /**
     * Update the reactSettings, must be sent the entire reactSettings object.
     * @param {Object} newSettings - The new reactSettings object to replace the current reactSettings (must be the full object)
     * @param {string} [messageForLog] - Optional message to log to the console.
     */
    const updateReactSettings = React.useCallback((newSettings, messageForLog) => {
      pluginData.reactSettings = newSettings;
      updatePluginData(pluginData, messageForLog);
    }, []);

    // Provide the context value with all functions and state.
    const contextValue = {
      sendActionToPlugin,
      sendToPlugin,
      dispatch,
      pluginData,
      reactSettings,
      updateReactSettings,
      updatePluginData
    };
    return /*#__PURE__*/React__default["default"].createElement(AppContext.Provider, {
      value: contextValue
    }, children);
  };

  /**
   * Custom hook to use the AppContext.
   * @returns {AppContextType} - The context value.
   */
  const useAppContext = () => React.useContext(AppContext);

  /**
   * Displays the dashboard's header.
   */
  const Header = ({
    lastUpdated
  }) => {
    const {
      reactSettings,
      updateReactSettings,
      sendActionToPlugin /*, sendToPlugin, dispatch, pluginData, */
    } = useAppContext();
    const handleCheckboxClick = e => {
      const isChecked = e?.target.checked || false;
      console.log(`Checkbox clicked. setting in global Context reactSettings.filterPriorityItems to ${String(isChecked)}`);
      updateReactSettings({
        ...reactSettings,
        filterPriorityItems: isChecked
      }, `reactSettings.filterPriorityItems set to ${String(isChecked)}`);
    };
    const handleRefreshClick = () => {
      console.log('Refresh button clicked');
      sendActionToPlugin('refresh', {});
    };

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "header"
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "lastUpdated"
    }, "Last updated: ", /*#__PURE__*/React__default["default"].createElement("span", {
      id: "timer"
    }), ' '), /*#__PURE__*/React__default["default"].createElement(Button, {
      text: 'Refresh',
      clickHandler: handleRefreshClick,
      className: "PCButton"
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "totalCounts"
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      id: "totalDoneCount"
    }, "0"), " items closed"), /*#__PURE__*/React__default["default"].createElement("div", null, /*#__PURE__*/React__default["default"].createElement("input", {
      type: "checkbox",
      className: "apple-switch",
      onChange: handleCheckboxClick,
      name: "filterPriorityItems",
      id: "filterPriorityItems",
      checked: reactSettings.filterPriorityItems || false
    }), /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: "filterPriorityItems"
    }, "Filter out lower-priority items?")));
  };

  // Buttons for adding tasks and checklists to today's note
  function CommandButton(inputObj) {
    const {
      sendActionToPlugin /*, sendToPlugin, dispatch, pluginData */
    } = useAppContext();
    const {
      button
    } = inputObj;

    // console.log('CommandButton: ' + button.display)

    // Tried this approach but decided it's not flexible enough
    // const possIconBefore = (button.iconBefore !== '') ? <i className={`${button.iconBefore} padRight`}></i> : ''
    // const possIconAfter = (button.iconAfter !== '') ? <i className={`padLeft ${button.iconAfter}`}></i> : ''

    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton tooltip",
      "data-tooltip": button.tooltip,
      "data-plugin-id": button.actionPluginID
      // data-command={button.actionFunctionName}
      // data-command-args={filename}
      ,
      onClick: () => sendActionToPlugin(button.actionFunctionName, button.actionFunctionParam),
      dangerouslySetInnerHTML: {
        __html: button.display
      }
    }), ' ');
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire (path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var dist = {exports: {}};

  (function (module, exports) {
  (function (global, factory) {
  	module.exports = factory() ;
  }(commonjsGlobal, (function () {
  	function createCommonjsModule(fn, module) {
  		return module = { exports: {} }, fn(module, module.exports), module.exports;
  	}

  	var _global = createCommonjsModule(function (module) {
  	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  	var global = module.exports = typeof window != 'undefined' && window.Math == Math
  	  ? window : typeof self != 'undefined' && self.Math == Math ? self
  	  // eslint-disable-next-line no-new-func
  	  : Function('return this')();
  	if (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef
  	});

  	var _core = createCommonjsModule(function (module) {
  	var core = module.exports = { version: '2.6.5' };
  	if (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef
  	});
  	_core.version;

  	var _isObject = function (it) {
  	  return typeof it === 'object' ? it !== null : typeof it === 'function';
  	};

  	var _anObject = function (it) {
  	  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }
  	  return it;
  	};

  	var _fails = function (exec) {
  	  try {
  	    return !!exec();
  	  } catch (e) {
  	    return true;
  	  }
  	};

  	// Thank's IE8 for his funny defineProperty
  	var _descriptors = !_fails(function () {
  	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  	});

  	var document = _global.document;
  	// typeof document.createElement is 'object' in old IE
  	var is = _isObject(document) && _isObject(document.createElement);
  	var _domCreate = function (it) {
  	  return is ? document.createElement(it) : {};
  	};

  	var _ie8DomDefine = !_descriptors && !_fails(function () {
  	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  	});

  	// 7.1.1 ToPrimitive(input [, PreferredType])

  	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
  	// and the second argument - flag - preferred type is a string
  	var _toPrimitive = function (it, S) {
  	  if (!_isObject(it)) { return it; }
  	  var fn, val;
  	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
  	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }
  	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
  	  throw TypeError("Can't convert object to primitive value");
  	};

  	var dP = Object.defineProperty;

  	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  	  _anObject(O);
  	  P = _toPrimitive(P, true);
  	  _anObject(Attributes);
  	  if (_ie8DomDefine) { try {
  	    return dP(O, P, Attributes);
  	  } catch (e) { /* empty */ } }
  	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }
  	  if ('value' in Attributes) { O[P] = Attributes.value; }
  	  return O;
  	};

  	var _objectDp = {
  		f: f
  	};

  	var _propertyDesc = function (bitmap, value) {
  	  return {
  	    enumerable: !(bitmap & 1),
  	    configurable: !(bitmap & 2),
  	    writable: !(bitmap & 4),
  	    value: value
  	  };
  	};

  	var _hide = _descriptors ? function (object, key, value) {
  	  return _objectDp.f(object, key, _propertyDesc(1, value));
  	} : function (object, key, value) {
  	  object[key] = value;
  	  return object;
  	};

  	var hasOwnProperty = {}.hasOwnProperty;
  	var _has = function (it, key) {
  	  return hasOwnProperty.call(it, key);
  	};

  	var id = 0;
  	var px = Math.random();
  	var _uid = function (key) {
  	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  	};

  	var _shared = createCommonjsModule(function (module) {
  	var SHARED = '__core-js_shared__';
  	var store = _global[SHARED] || (_global[SHARED] = {});

  	(module.exports = function (key, value) {
  	  return store[key] || (store[key] = value !== undefined ? value : {});
  	})('versions', []).push({
  	  version: _core.version,
  	  mode: 'global',
  	  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
  	});
  	});

  	var _functionToString = _shared('native-function-to-string', Function.toString);

  	var _redefine = createCommonjsModule(function (module) {
  	var SRC = _uid('src');

  	var TO_STRING = 'toString';
  	var TPL = ('' + _functionToString).split(TO_STRING);

  	_core.inspectSource = function (it) {
  	  return _functionToString.call(it);
  	};

  	(module.exports = function (O, key, val, safe) {
  	  var isFunction = typeof val == 'function';
  	  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }
  	  if (O[key] === val) { return; }
  	  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }
  	  if (O === _global) {
  	    O[key] = val;
  	  } else if (!safe) {
  	    delete O[key];
  	    _hide(O, key, val);
  	  } else if (O[key]) {
  	    O[key] = val;
  	  } else {
  	    _hide(O, key, val);
  	  }
  	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  	})(Function.prototype, TO_STRING, function toString() {
  	  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
  	});
  	});

  	var _aFunction = function (it) {
  	  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }
  	  return it;
  	};

  	// optional / simple context binding

  	var _ctx = function (fn, that, length) {
  	  _aFunction(fn);
  	  if (that === undefined) { return fn; }
  	  switch (length) {
  	    case 1: return function (a) {
  	      return fn.call(that, a);
  	    };
  	    case 2: return function (a, b) {
  	      return fn.call(that, a, b);
  	    };
  	    case 3: return function (a, b, c) {
  	      return fn.call(that, a, b, c);
  	    };
  	  }
  	  return function (/* ...args */) {
  	    return fn.apply(that, arguments);
  	  };
  	};

  	var PROTOTYPE = 'prototype';

  	var $export = function (type, name, source) {
  	  var IS_FORCED = type & $export.F;
  	  var IS_GLOBAL = type & $export.G;
  	  var IS_STATIC = type & $export.S;
  	  var IS_PROTO = type & $export.P;
  	  var IS_BIND = type & $export.B;
  	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  	  var key, own, out, exp;
  	  if (IS_GLOBAL) { source = name; }
  	  for (key in source) {
  	    // contains in native
  	    own = !IS_FORCED && target && target[key] !== undefined;
  	    // export native or passed
  	    out = (own ? target : source)[key];
  	    // bind timers to global for call from export context
  	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
  	    // extend global
  	    if (target) { _redefine(target, key, out, type & $export.U); }
  	    // export
  	    if (exports[key] != out) { _hide(exports, key, exp); }
  	    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }
  	  }
  	};
  	_global.core = _core;
  	// type bitmap
  	$export.F = 1;   // forced
  	$export.G = 2;   // global
  	$export.S = 4;   // static
  	$export.P = 8;   // proto
  	$export.B = 16;  // bind
  	$export.W = 32;  // wrap
  	$export.U = 64;  // safe
  	$export.R = 128; // real proto method for `library`
  	var _export = $export;

  	// 7.1.4 ToInteger
  	var ceil = Math.ceil;
  	var floor = Math.floor;
  	var _toInteger = function (it) {
  	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  	};

  	// 7.2.1 RequireObjectCoercible(argument)
  	var _defined = function (it) {
  	  if (it == undefined) { throw TypeError("Can't call method on  " + it); }
  	  return it;
  	};

  	// true  -> String#at
  	// false -> String#codePointAt
  	var _stringAt = function (TO_STRING) {
  	  return function (that, pos) {
  	    var s = String(_defined(that));
  	    var i = _toInteger(pos);
  	    var l = s.length;
  	    var a, b;
  	    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }
  	    a = s.charCodeAt(i);
  	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
  	      ? TO_STRING ? s.charAt(i) : a
  	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  	  };
  	};

  	var $at = _stringAt(false);
  	_export(_export.P, 'String', {
  	  // 21.1.3.3 String.prototype.codePointAt(pos)
  	  codePointAt: function codePointAt(pos) {
  	    return $at(this, pos);
  	  }
  	});

  	_core.String.codePointAt;

  	var max = Math.max;
  	var min = Math.min;
  	var _toAbsoluteIndex = function (index, length) {
  	  index = _toInteger(index);
  	  return index < 0 ? max(index + length, 0) : min(index, length);
  	};

  	var fromCharCode = String.fromCharCode;
  	var $fromCodePoint = String.fromCodePoint;

  	// length should be 1, old FF problem
  	_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  	  // 21.1.2.2 String.fromCodePoint(...codePoints)
  	  fromCodePoint: function fromCodePoint(x) {
  	    var arguments$1 = arguments;
  	 // eslint-disable-line no-unused-vars
  	    var res = [];
  	    var aLen = arguments.length;
  	    var i = 0;
  	    var code;
  	    while (aLen > i) {
  	      code = +arguments$1[i++];
  	      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }
  	      res.push(code < 0x10000
  	        ? fromCharCode(code)
  	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
  	      );
  	    } return res.join('');
  	  }
  	});

  	_core.String.fromCodePoint;

  	// This is a generated file. Do not edit.
  	var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  	var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  	var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

  	var unicode = {
  		Space_Separator: Space_Separator,
  		ID_Start: ID_Start,
  		ID_Continue: ID_Continue
  	};

  	var util = {
  	    isSpaceSeparator: function isSpaceSeparator (c) {
  	        return typeof c === 'string' && unicode.Space_Separator.test(c)
  	    },

  	    isIdStartChar: function isIdStartChar (c) {
  	        return typeof c === 'string' && (
  	            (c >= 'a' && c <= 'z') ||
  	        (c >= 'A' && c <= 'Z') ||
  	        (c === '$') || (c === '_') ||
  	        unicode.ID_Start.test(c)
  	        )
  	    },

  	    isIdContinueChar: function isIdContinueChar (c) {
  	        return typeof c === 'string' && (
  	            (c >= 'a' && c <= 'z') ||
  	        (c >= 'A' && c <= 'Z') ||
  	        (c >= '0' && c <= '9') ||
  	        (c === '$') || (c === '_') ||
  	        (c === '\u200C') || (c === '\u200D') ||
  	        unicode.ID_Continue.test(c)
  	        )
  	    },

  	    isDigit: function isDigit (c) {
  	        return typeof c === 'string' && /[0-9]/.test(c)
  	    },

  	    isHexDigit: function isHexDigit (c) {
  	        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
  	    },
  	};

  	var source;
  	var parseState;
  	var stack;
  	var pos;
  	var line;
  	var column;
  	var token;
  	var key;
  	var root;

  	var parse = function parse (text, reviver) {
  	    source = String(text);
  	    parseState = 'start';
  	    stack = [];
  	    pos = 0;
  	    line = 1;
  	    column = 0;
  	    token = undefined;
  	    key = undefined;
  	    root = undefined;

  	    do {
  	        token = lex();

  	        // This code is unreachable.
  	        // if (!parseStates[parseState]) {
  	        //     throw invalidParseState()
  	        // }

  	        parseStates[parseState]();
  	    } while (token.type !== 'eof')

  	    if (typeof reviver === 'function') {
  	        return internalize({'': root}, '', reviver)
  	    }

  	    return root
  	};

  	function internalize (holder, name, reviver) {
  	    var value = holder[name];
  	    if (value != null && typeof value === 'object') {
  	        if (Array.isArray(value)) {
  	            for (var i = 0; i < value.length; i++) {
  	                var key = String(i);
  	                var replacement = internalize(value, key, reviver);
  	                if (replacement === undefined) {
  	                    delete value[key];
  	                } else {
  	                    Object.defineProperty(value, key, {
  	                        value: replacement,
  	                        writable: true,
  	                        enumerable: true,
  	                        configurable: true,
  	                    });
  	                }
  	            }
  	        } else {
  	            for (var key$1 in value) {
  	                var replacement$1 = internalize(value, key$1, reviver);
  	                if (replacement$1 === undefined) {
  	                    delete value[key$1];
  	                } else {
  	                    Object.defineProperty(value, key$1, {
  	                        value: replacement$1,
  	                        writable: true,
  	                        enumerable: true,
  	                        configurable: true,
  	                    });
  	                }
  	            }
  	        }
  	    }

  	    return reviver.call(holder, name, value)
  	}

  	var lexState;
  	var buffer;
  	var doubleQuote;
  	var sign;
  	var c;

  	function lex () {
  	    lexState = 'default';
  	    buffer = '';
  	    doubleQuote = false;
  	    sign = 1;

  	    for (;;) {
  	        c = peek();

  	        // This code is unreachable.
  	        // if (!lexStates[lexState]) {
  	        //     throw invalidLexState(lexState)
  	        // }

  	        var token = lexStates[lexState]();
  	        if (token) {
  	            return token
  	        }
  	    }
  	}

  	function peek () {
  	    if (source[pos]) {
  	        return String.fromCodePoint(source.codePointAt(pos))
  	    }
  	}

  	function read () {
  	    var c = peek();

  	    if (c === '\n') {
  	        line++;
  	        column = 0;
  	    } else if (c) {
  	        column += c.length;
  	    } else {
  	        column++;
  	    }

  	    if (c) {
  	        pos += c.length;
  	    }

  	    return c
  	}

  	var lexStates = {
  	    default: function default$1 () {
  	        switch (c) {
  	        case '\t':
  	        case '\v':
  	        case '\f':
  	        case ' ':
  	        case '\u00A0':
  	        case '\uFEFF':
  	        case '\n':
  	        case '\r':
  	        case '\u2028':
  	        case '\u2029':
  	            read();
  	            return

  	        case '/':
  	            read();
  	            lexState = 'comment';
  	            return

  	        case undefined:
  	            read();
  	            return newToken('eof')
  	        }

  	        if (util.isSpaceSeparator(c)) {
  	            read();
  	            return
  	        }

  	        // This code is unreachable.
  	        // if (!lexStates[parseState]) {
  	        //     throw invalidLexState(parseState)
  	        // }

  	        return lexStates[parseState]()
  	    },

  	    comment: function comment () {
  	        switch (c) {
  	        case '*':
  	            read();
  	            lexState = 'multiLineComment';
  	            return

  	        case '/':
  	            read();
  	            lexState = 'singleLineComment';
  	            return
  	        }

  	        throw invalidChar(read())
  	    },

  	    multiLineComment: function multiLineComment () {
  	        switch (c) {
  	        case '*':
  	            read();
  	            lexState = 'multiLineCommentAsterisk';
  	            return

  	        case undefined:
  	            throw invalidChar(read())
  	        }

  	        read();
  	    },

  	    multiLineCommentAsterisk: function multiLineCommentAsterisk () {
  	        switch (c) {
  	        case '*':
  	            read();
  	            return

  	        case '/':
  	            read();
  	            lexState = 'default';
  	            return

  	        case undefined:
  	            throw invalidChar(read())
  	        }

  	        read();
  	        lexState = 'multiLineComment';
  	    },

  	    singleLineComment: function singleLineComment () {
  	        switch (c) {
  	        case '\n':
  	        case '\r':
  	        case '\u2028':
  	        case '\u2029':
  	            read();
  	            lexState = 'default';
  	            return

  	        case undefined:
  	            read();
  	            return newToken('eof')
  	        }

  	        read();
  	    },

  	    value: function value () {
  	        switch (c) {
  	        case '{':
  	        case '[':
  	            return newToken('punctuator', read())

  	        case 'n':
  	            read();
  	            literal('ull');
  	            return newToken('null', null)

  	        case 't':
  	            read();
  	            literal('rue');
  	            return newToken('boolean', true)

  	        case 'f':
  	            read();
  	            literal('alse');
  	            return newToken('boolean', false)

  	        case '-':
  	        case '+':
  	            if (read() === '-') {
  	                sign = -1;
  	            }

  	            lexState = 'sign';
  	            return

  	        case '.':
  	            buffer = read();
  	            lexState = 'decimalPointLeading';
  	            return

  	        case '0':
  	            buffer = read();
  	            lexState = 'zero';
  	            return

  	        case '1':
  	        case '2':
  	        case '3':
  	        case '4':
  	        case '5':
  	        case '6':
  	        case '7':
  	        case '8':
  	        case '9':
  	            buffer = read();
  	            lexState = 'decimalInteger';
  	            return

  	        case 'I':
  	            read();
  	            literal('nfinity');
  	            return newToken('numeric', Infinity)

  	        case 'N':
  	            read();
  	            literal('aN');
  	            return newToken('numeric', NaN)

  	        case '"':
  	        case "'":
  	            doubleQuote = (read() === '"');
  	            buffer = '';
  	            lexState = 'string';
  	            return
  	        }

  	        throw invalidChar(read())
  	    },

  	    identifierNameStartEscape: function identifierNameStartEscape () {
  	        if (c !== 'u') {
  	            throw invalidChar(read())
  	        }

  	        read();
  	        var u = unicodeEscape();
  	        switch (u) {
  	        case '$':
  	        case '_':
  	            break

  	        default:
  	            if (!util.isIdStartChar(u)) {
  	                throw invalidIdentifier()
  	            }

  	            break
  	        }

  	        buffer += u;
  	        lexState = 'identifierName';
  	    },

  	    identifierName: function identifierName () {
  	        switch (c) {
  	        case '$':
  	        case '_':
  	        case '\u200C':
  	        case '\u200D':
  	            buffer += read();
  	            return

  	        case '\\':
  	            read();
  	            lexState = 'identifierNameEscape';
  	            return
  	        }

  	        if (util.isIdContinueChar(c)) {
  	            buffer += read();
  	            return
  	        }

  	        return newToken('identifier', buffer)
  	    },

  	    identifierNameEscape: function identifierNameEscape () {
  	        if (c !== 'u') {
  	            throw invalidChar(read())
  	        }

  	        read();
  	        var u = unicodeEscape();
  	        switch (u) {
  	        case '$':
  	        case '_':
  	        case '\u200C':
  	        case '\u200D':
  	            break

  	        default:
  	            if (!util.isIdContinueChar(u)) {
  	                throw invalidIdentifier()
  	            }

  	            break
  	        }

  	        buffer += u;
  	        lexState = 'identifierName';
  	    },

  	    sign: function sign$1 () {
  	        switch (c) {
  	        case '.':
  	            buffer = read();
  	            lexState = 'decimalPointLeading';
  	            return

  	        case '0':
  	            buffer = read();
  	            lexState = 'zero';
  	            return

  	        case '1':
  	        case '2':
  	        case '3':
  	        case '4':
  	        case '5':
  	        case '6':
  	        case '7':
  	        case '8':
  	        case '9':
  	            buffer = read();
  	            lexState = 'decimalInteger';
  	            return

  	        case 'I':
  	            read();
  	            literal('nfinity');
  	            return newToken('numeric', sign * Infinity)

  	        case 'N':
  	            read();
  	            literal('aN');
  	            return newToken('numeric', NaN)
  	        }

  	        throw invalidChar(read())
  	    },

  	    zero: function zero () {
  	        switch (c) {
  	        case '.':
  	            buffer += read();
  	            lexState = 'decimalPoint';
  	            return

  	        case 'e':
  	        case 'E':
  	            buffer += read();
  	            lexState = 'decimalExponent';
  	            return

  	        case 'x':
  	        case 'X':
  	            buffer += read();
  	            lexState = 'hexadecimal';
  	            return
  	        }

  	        return newToken('numeric', sign * 0)
  	    },

  	    decimalInteger: function decimalInteger () {
  	        switch (c) {
  	        case '.':
  	            buffer += read();
  	            lexState = 'decimalPoint';
  	            return

  	        case 'e':
  	        case 'E':
  	            buffer += read();
  	            lexState = 'decimalExponent';
  	            return
  	        }

  	        if (util.isDigit(c)) {
  	            buffer += read();
  	            return
  	        }

  	        return newToken('numeric', sign * Number(buffer))
  	    },

  	    decimalPointLeading: function decimalPointLeading () {
  	        if (util.isDigit(c)) {
  	            buffer += read();
  	            lexState = 'decimalFraction';
  	            return
  	        }

  	        throw invalidChar(read())
  	    },

  	    decimalPoint: function decimalPoint () {
  	        switch (c) {
  	        case 'e':
  	        case 'E':
  	            buffer += read();
  	            lexState = 'decimalExponent';
  	            return
  	        }

  	        if (util.isDigit(c)) {
  	            buffer += read();
  	            lexState = 'decimalFraction';
  	            return
  	        }

  	        return newToken('numeric', sign * Number(buffer))
  	    },

  	    decimalFraction: function decimalFraction () {
  	        switch (c) {
  	        case 'e':
  	        case 'E':
  	            buffer += read();
  	            lexState = 'decimalExponent';
  	            return
  	        }

  	        if (util.isDigit(c)) {
  	            buffer += read();
  	            return
  	        }

  	        return newToken('numeric', sign * Number(buffer))
  	    },

  	    decimalExponent: function decimalExponent () {
  	        switch (c) {
  	        case '+':
  	        case '-':
  	            buffer += read();
  	            lexState = 'decimalExponentSign';
  	            return
  	        }

  	        if (util.isDigit(c)) {
  	            buffer += read();
  	            lexState = 'decimalExponentInteger';
  	            return
  	        }

  	        throw invalidChar(read())
  	    },

  	    decimalExponentSign: function decimalExponentSign () {
  	        if (util.isDigit(c)) {
  	            buffer += read();
  	            lexState = 'decimalExponentInteger';
  	            return
  	        }

  	        throw invalidChar(read())
  	    },

  	    decimalExponentInteger: function decimalExponentInteger () {
  	        if (util.isDigit(c)) {
  	            buffer += read();
  	            return
  	        }

  	        return newToken('numeric', sign * Number(buffer))
  	    },

  	    hexadecimal: function hexadecimal () {
  	        if (util.isHexDigit(c)) {
  	            buffer += read();
  	            lexState = 'hexadecimalInteger';
  	            return
  	        }

  	        throw invalidChar(read())
  	    },

  	    hexadecimalInteger: function hexadecimalInteger () {
  	        if (util.isHexDigit(c)) {
  	            buffer += read();
  	            return
  	        }

  	        return newToken('numeric', sign * Number(buffer))
  	    },

  	    string: function string () {
  	        switch (c) {
  	        case '\\':
  	            read();
  	            buffer += escape();
  	            return

  	        case '"':
  	            if (doubleQuote) {
  	                read();
  	                return newToken('string', buffer)
  	            }

  	            buffer += read();
  	            return

  	        case "'":
  	            if (!doubleQuote) {
  	                read();
  	                return newToken('string', buffer)
  	            }

  	            buffer += read();
  	            return

  	        case '\n':
  	        case '\r':
  	            throw invalidChar(read())

  	        case '\u2028':
  	        case '\u2029':
  	            separatorChar(c);
  	            break

  	        case undefined:
  	            throw invalidChar(read())
  	        }

  	        buffer += read();
  	    },

  	    start: function start () {
  	        switch (c) {
  	        case '{':
  	        case '[':
  	            return newToken('punctuator', read())

  	        // This code is unreachable since the default lexState handles eof.
  	        // case undefined:
  	        //     return newToken('eof')
  	        }

  	        lexState = 'value';
  	    },

  	    beforePropertyName: function beforePropertyName () {
  	        switch (c) {
  	        case '$':
  	        case '_':
  	            buffer = read();
  	            lexState = 'identifierName';
  	            return

  	        case '\\':
  	            read();
  	            lexState = 'identifierNameStartEscape';
  	            return

  	        case '}':
  	            return newToken('punctuator', read())

  	        case '"':
  	        case "'":
  	            doubleQuote = (read() === '"');
  	            lexState = 'string';
  	            return
  	        }

  	        if (util.isIdStartChar(c)) {
  	            buffer += read();
  	            lexState = 'identifierName';
  	            return
  	        }

  	        throw invalidChar(read())
  	    },

  	    afterPropertyName: function afterPropertyName () {
  	        if (c === ':') {
  	            return newToken('punctuator', read())
  	        }

  	        throw invalidChar(read())
  	    },

  	    beforePropertyValue: function beforePropertyValue () {
  	        lexState = 'value';
  	    },

  	    afterPropertyValue: function afterPropertyValue () {
  	        switch (c) {
  	        case ',':
  	        case '}':
  	            return newToken('punctuator', read())
  	        }

  	        throw invalidChar(read())
  	    },

  	    beforeArrayValue: function beforeArrayValue () {
  	        if (c === ']') {
  	            return newToken('punctuator', read())
  	        }

  	        lexState = 'value';
  	    },

  	    afterArrayValue: function afterArrayValue () {
  	        switch (c) {
  	        case ',':
  	        case ']':
  	            return newToken('punctuator', read())
  	        }

  	        throw invalidChar(read())
  	    },

  	    end: function end () {
  	        // This code is unreachable since it's handled by the default lexState.
  	        // if (c === undefined) {
  	        //     read()
  	        //     return newToken('eof')
  	        // }

  	        throw invalidChar(read())
  	    },
  	};

  	function newToken (type, value) {
  	    return {
  	        type: type,
  	        value: value,
  	        line: line,
  	        column: column,
  	    }
  	}

  	function literal (s) {
  	    for (var i = 0, list = s; i < list.length; i += 1) {
  	        var c = list[i];

  	        var p = peek();

  	        if (p !== c) {
  	            throw invalidChar(read())
  	        }

  	        read();
  	    }
  	}

  	function escape () {
  	    var c = peek();
  	    switch (c) {
  	    case 'b':
  	        read();
  	        return '\b'

  	    case 'f':
  	        read();
  	        return '\f'

  	    case 'n':
  	        read();
  	        return '\n'

  	    case 'r':
  	        read();
  	        return '\r'

  	    case 't':
  	        read();
  	        return '\t'

  	    case 'v':
  	        read();
  	        return '\v'

  	    case '0':
  	        read();
  	        if (util.isDigit(peek())) {
  	            throw invalidChar(read())
  	        }

  	        return '\0'

  	    case 'x':
  	        read();
  	        return hexEscape()

  	    case 'u':
  	        read();
  	        return unicodeEscape()

  	    case '\n':
  	    case '\u2028':
  	    case '\u2029':
  	        read();
  	        return ''

  	    case '\r':
  	        read();
  	        if (peek() === '\n') {
  	            read();
  	        }

  	        return ''

  	    case '1':
  	    case '2':
  	    case '3':
  	    case '4':
  	    case '5':
  	    case '6':
  	    case '7':
  	    case '8':
  	    case '9':
  	        throw invalidChar(read())

  	    case undefined:
  	        throw invalidChar(read())
  	    }

  	    return read()
  	}

  	function hexEscape () {
  	    var buffer = '';
  	    var c = peek();

  	    if (!util.isHexDigit(c)) {
  	        throw invalidChar(read())
  	    }

  	    buffer += read();

  	    c = peek();
  	    if (!util.isHexDigit(c)) {
  	        throw invalidChar(read())
  	    }

  	    buffer += read();

  	    return String.fromCodePoint(parseInt(buffer, 16))
  	}

  	function unicodeEscape () {
  	    var buffer = '';
  	    var count = 4;

  	    while (count-- > 0) {
  	        var c = peek();
  	        if (!util.isHexDigit(c)) {
  	            throw invalidChar(read())
  	        }

  	        buffer += read();
  	    }

  	    return String.fromCodePoint(parseInt(buffer, 16))
  	}

  	var parseStates = {
  	    start: function start () {
  	        if (token.type === 'eof') {
  	            throw invalidEOF()
  	        }

  	        push();
  	    },

  	    beforePropertyName: function beforePropertyName () {
  	        switch (token.type) {
  	        case 'identifier':
  	        case 'string':
  	            key = token.value;
  	            parseState = 'afterPropertyName';
  	            return

  	        case 'punctuator':
  	            // This code is unreachable since it's handled by the lexState.
  	            // if (token.value !== '}') {
  	            //     throw invalidToken()
  	            // }

  	            pop();
  	            return

  	        case 'eof':
  	            throw invalidEOF()
  	        }

  	        // This code is unreachable since it's handled by the lexState.
  	        // throw invalidToken()
  	    },

  	    afterPropertyName: function afterPropertyName () {
  	        // This code is unreachable since it's handled by the lexState.
  	        // if (token.type !== 'punctuator' || token.value !== ':') {
  	        //     throw invalidToken()
  	        // }

  	        if (token.type === 'eof') {
  	            throw invalidEOF()
  	        }

  	        parseState = 'beforePropertyValue';
  	    },

  	    beforePropertyValue: function beforePropertyValue () {
  	        if (token.type === 'eof') {
  	            throw invalidEOF()
  	        }

  	        push();
  	    },

  	    beforeArrayValue: function beforeArrayValue () {
  	        if (token.type === 'eof') {
  	            throw invalidEOF()
  	        }

  	        if (token.type === 'punctuator' && token.value === ']') {
  	            pop();
  	            return
  	        }

  	        push();
  	    },

  	    afterPropertyValue: function afterPropertyValue () {
  	        // This code is unreachable since it's handled by the lexState.
  	        // if (token.type !== 'punctuator') {
  	        //     throw invalidToken()
  	        // }

  	        if (token.type === 'eof') {
  	            throw invalidEOF()
  	        }

  	        switch (token.value) {
  	        case ',':
  	            parseState = 'beforePropertyName';
  	            return

  	        case '}':
  	            pop();
  	        }

  	        // This code is unreachable since it's handled by the lexState.
  	        // throw invalidToken()
  	    },

  	    afterArrayValue: function afterArrayValue () {
  	        // This code is unreachable since it's handled by the lexState.
  	        // if (token.type !== 'punctuator') {
  	        //     throw invalidToken()
  	        // }

  	        if (token.type === 'eof') {
  	            throw invalidEOF()
  	        }

  	        switch (token.value) {
  	        case ',':
  	            parseState = 'beforeArrayValue';
  	            return

  	        case ']':
  	            pop();
  	        }

  	        // This code is unreachable since it's handled by the lexState.
  	        // throw invalidToken()
  	    },

  	    end: function end () {
  	        // This code is unreachable since it's handled by the lexState.
  	        // if (token.type !== 'eof') {
  	        //     throw invalidToken()
  	        // }
  	    },
  	};

  	function push () {
  	    var value;

  	    switch (token.type) {
  	    case 'punctuator':
  	        switch (token.value) {
  	        case '{':
  	            value = {};
  	            break

  	        case '[':
  	            value = [];
  	            break
  	        }

  	        break

  	    case 'null':
  	    case 'boolean':
  	    case 'numeric':
  	    case 'string':
  	        value = token.value;
  	        break

  	    // This code is unreachable.
  	    // default:
  	    //     throw invalidToken()
  	    }

  	    if (root === undefined) {
  	        root = value;
  	    } else {
  	        var parent = stack[stack.length - 1];
  	        if (Array.isArray(parent)) {
  	            parent.push(value);
  	        } else {
  	            Object.defineProperty(parent, key, {
  	                value: value,
  	                writable: true,
  	                enumerable: true,
  	                configurable: true,
  	            });
  	        }
  	    }

  	    if (value !== null && typeof value === 'object') {
  	        stack.push(value);

  	        if (Array.isArray(value)) {
  	            parseState = 'beforeArrayValue';
  	        } else {
  	            parseState = 'beforePropertyName';
  	        }
  	    } else {
  	        var current = stack[stack.length - 1];
  	        if (current == null) {
  	            parseState = 'end';
  	        } else if (Array.isArray(current)) {
  	            parseState = 'afterArrayValue';
  	        } else {
  	            parseState = 'afterPropertyValue';
  	        }
  	    }
  	}

  	function pop () {
  	    stack.pop();

  	    var current = stack[stack.length - 1];
  	    if (current == null) {
  	        parseState = 'end';
  	    } else if (Array.isArray(current)) {
  	        parseState = 'afterArrayValue';
  	    } else {
  	        parseState = 'afterPropertyValue';
  	    }
  	}

  	// This code is unreachable.
  	// function invalidParseState () {
  	//     return new Error(`JSON5: invalid parse state '${parseState}'`)
  	// }

  	// This code is unreachable.
  	// function invalidLexState (state) {
  	//     return new Error(`JSON5: invalid lex state '${state}'`)
  	// }

  	function invalidChar (c) {
  	    if (c === undefined) {
  	        return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
  	    }

  	    return syntaxError(("JSON5: invalid character '" + (formatChar(c)) + "' at " + line + ":" + column))
  	}

  	function invalidEOF () {
  	    return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
  	}

  	// This code is unreachable.
  	// function invalidToken () {
  	//     if (token.type === 'eof') {
  	//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
  	//     }

  	//     const c = String.fromCodePoint(token.value.codePointAt(0))
  	//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
  	// }

  	function invalidIdentifier () {
  	    column -= 5;
  	    return syntaxError(("JSON5: invalid identifier character at " + line + ":" + column))
  	}

  	function separatorChar (c) {
  	    console.warn(("JSON5: '" + (formatChar(c)) + "' in strings is not valid ECMAScript; consider escaping"));
  	}

  	function formatChar (c) {
  	    var replacements = {
  	        "'": "\\'",
  	        '"': '\\"',
  	        '\\': '\\\\',
  	        '\b': '\\b',
  	        '\f': '\\f',
  	        '\n': '\\n',
  	        '\r': '\\r',
  	        '\t': '\\t',
  	        '\v': '\\v',
  	        '\0': '\\0',
  	        '\u2028': '\\u2028',
  	        '\u2029': '\\u2029',
  	    };

  	    if (replacements[c]) {
  	        return replacements[c]
  	    }

  	    if (c < ' ') {
  	        var hexString = c.charCodeAt(0).toString(16);
  	        return '\\x' + ('00' + hexString).substring(hexString.length)
  	    }

  	    return c
  	}

  	function syntaxError (message) {
  	    var err = new SyntaxError(message);
  	    err.lineNumber = line;
  	    err.columnNumber = column;
  	    return err
  	}

  	var stringify = function stringify (value, replacer, space) {
  	    var stack = [];
  	    var indent = '';
  	    var propertyList;
  	    var replacerFunc;
  	    var gap = '';
  	    var quote;

  	    if (
  	        replacer != null &&
  	        typeof replacer === 'object' &&
  	        !Array.isArray(replacer)
  	    ) {
  	        space = replacer.space;
  	        quote = replacer.quote;
  	        replacer = replacer.replacer;
  	    }

  	    if (typeof replacer === 'function') {
  	        replacerFunc = replacer;
  	    } else if (Array.isArray(replacer)) {
  	        propertyList = [];
  	        for (var i = 0, list = replacer; i < list.length; i += 1) {
  	            var v = list[i];

  	            var item = (void 0);

  	            if (typeof v === 'string') {
  	                item = v;
  	            } else if (
  	                typeof v === 'number' ||
  	                v instanceof String ||
  	                v instanceof Number
  	            ) {
  	                item = String(v);
  	            }

  	            if (item !== undefined && propertyList.indexOf(item) < 0) {
  	                propertyList.push(item);
  	            }
  	        }
  	    }

  	    if (space instanceof Number) {
  	        space = Number(space);
  	    } else if (space instanceof String) {
  	        space = String(space);
  	    }

  	    if (typeof space === 'number') {
  	        if (space > 0) {
  	            space = Math.min(10, Math.floor(space));
  	            gap = '          '.substr(0, space);
  	        }
  	    } else if (typeof space === 'string') {
  	        gap = space.substr(0, 10);
  	    }

  	    return serializeProperty('', {'': value})

  	    function serializeProperty (key, holder) {
  	        var value = holder[key];
  	        if (value != null) {
  	            if (typeof value.toJSON5 === 'function') {
  	                value = value.toJSON5(key);
  	            } else if (typeof value.toJSON === 'function') {
  	                value = value.toJSON(key);
  	            }
  	        }

  	        if (replacerFunc) {
  	            value = replacerFunc.call(holder, key, value);
  	        }

  	        if (value instanceof Number) {
  	            value = Number(value);
  	        } else if (value instanceof String) {
  	            value = String(value);
  	        } else if (value instanceof Boolean) {
  	            value = value.valueOf();
  	        }

  	        switch (value) {
  	        case null: return 'null'
  	        case true: return 'true'
  	        case false: return 'false'
  	        }

  	        if (typeof value === 'string') {
  	            return quoteString(value)
  	        }

  	        if (typeof value === 'number') {
  	            return String(value)
  	        }

  	        if (typeof value === 'object') {
  	            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)
  	        }

  	        return undefined
  	    }

  	    function quoteString (value) {
  	        var quotes = {
  	            "'": 0.1,
  	            '"': 0.2,
  	        };

  	        var replacements = {
  	            "'": "\\'",
  	            '"': '\\"',
  	            '\\': '\\\\',
  	            '\b': '\\b',
  	            '\f': '\\f',
  	            '\n': '\\n',
  	            '\r': '\\r',
  	            '\t': '\\t',
  	            '\v': '\\v',
  	            '\0': '\\0',
  	            '\u2028': '\\u2028',
  	            '\u2029': '\\u2029',
  	        };

  	        var product = '';

  	        for (var i = 0; i < value.length; i++) {
  	            var c = value[i];
  	            switch (c) {
  	            case "'":
  	            case '"':
  	                quotes[c]++;
  	                product += c;
  	                continue

  	            case '\0':
  	                if (util.isDigit(value[i + 1])) {
  	                    product += '\\x00';
  	                    continue
  	                }
  	            }

  	            if (replacements[c]) {
  	                product += replacements[c];
  	                continue
  	            }

  	            if (c < ' ') {
  	                var hexString = c.charCodeAt(0).toString(16);
  	                product += '\\x' + ('00' + hexString).substring(hexString.length);
  	                continue
  	            }

  	            product += c;
  	        }

  	        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });

  	        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);

  	        return quoteChar + product + quoteChar
  	    }

  	    function serializeObject (value) {
  	        if (stack.indexOf(value) >= 0) {
  	            throw TypeError('Converting circular structure to JSON5')
  	        }

  	        stack.push(value);

  	        var stepback = indent;
  	        indent = indent + gap;

  	        var keys = propertyList || Object.keys(value);
  	        var partial = [];
  	        for (var i = 0, list = keys; i < list.length; i += 1) {
  	            var key = list[i];

  	            var propertyString = serializeProperty(key, value);
  	            if (propertyString !== undefined) {
  	                var member = serializeKey(key) + ':';
  	                if (gap !== '') {
  	                    member += ' ';
  	                }
  	                member += propertyString;
  	                partial.push(member);
  	            }
  	        }

  	        var final;
  	        if (partial.length === 0) {
  	            final = '{}';
  	        } else {
  	            var properties;
  	            if (gap === '') {
  	                properties = partial.join(',');
  	                final = '{' + properties + '}';
  	            } else {
  	                var separator = ',\n' + indent;
  	                properties = partial.join(separator);
  	                final = '{\n' + indent + properties + ',\n' + stepback + '}';
  	            }
  	        }

  	        stack.pop();
  	        indent = stepback;
  	        return final
  	    }

  	    function serializeKey (key) {
  	        if (key.length === 0) {
  	            return quoteString(key)
  	        }

  	        var firstChar = String.fromCodePoint(key.codePointAt(0));
  	        if (!util.isIdStartChar(firstChar)) {
  	            return quoteString(key)
  	        }

  	        for (var i = firstChar.length; i < key.length; i++) {
  	            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
  	                return quoteString(key)
  	            }
  	        }

  	        return key
  	    }

  	    function serializeArray (value) {
  	        if (stack.indexOf(value) >= 0) {
  	            throw TypeError('Converting circular structure to JSON5')
  	        }

  	        stack.push(value);

  	        var stepback = indent;
  	        indent = indent + gap;

  	        var partial = [];
  	        for (var i = 0; i < value.length; i++) {
  	            var propertyString = serializeProperty(String(i), value);
  	            partial.push((propertyString !== undefined) ? propertyString : 'null');
  	        }

  	        var final;
  	        if (partial.length === 0) {
  	            final = '[]';
  	        } else {
  	            if (gap === '') {
  	                var properties = partial.join(',');
  	                final = '[' + properties + ']';
  	            } else {
  	                var separator = ',\n' + indent;
  	                var properties$1 = partial.join(separator);
  	                final = '[\n' + indent + properties$1 + ',\n' + stepback + ']';
  	            }
  	        }

  	        stack.pop();
  	        indent = stepback;
  	        return final
  	    }
  	};

  	var JSON5 = {
  	    parse: parse,
  	    stringify: stringify,
  	};

  	var lib = JSON5;

  	var es5 = lib;

  	return es5;

  })));
  }(dist));

  var strftime = {exports: {}};

  (function (module) {
  (function() {

      var Locales = {
          de_DE: {
              days: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
              shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
              months: ['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
              shortMonths: ['Jan', 'Feb', 'MÃ¤r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d.%m.%Y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          en_CA: {
              days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
              shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
              months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
              shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
              ordinalSuffixes: [
                  'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
                  'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
                  'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
                  'st'
              ],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d/%m/%y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%r',
                  x: '%D'
              }
          },

          en_US: {
              days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
              shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
              months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
              shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
              ordinalSuffixes: [
                  'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
                  'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
                  'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
                  'st'
              ],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%m/%d/%y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%r',
                  x: '%D'
              }
          },

          es_MX: {
              days: ['domingo', 'lunes', 'martes', 'miÃ©rcoles', 'jueves', 'viernes', 'sÃ¡bado'],
              shortDays: ['dom', 'lun', 'mar', 'miÃ©', 'jue', 'vie', 'sÃ¡b'],
              months: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre',' diciembre'],
              shortMonths: ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d/%m/%Y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          fr_FR: {
              days: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
              shortDays: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
              months: ['janvier', 'fÃ©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aoÃ»t', 'septembre', 'octobre', 'novembre', 'dÃ©cembre'],
              shortMonths: ['janv.', 'fÃ©vr.', 'mars', 'avril', 'mai', 'juin', 'juil.', 'aoÃ»t', 'sept.', 'oct.', 'nov.', 'dÃ©c.'],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d/%m/%Y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          it_IT: {
              days: ['domenica', 'lunedÃ¬', 'martedÃ¬', 'mercoledÃ¬', 'giovedÃ¬', 'venerdÃ¬', 'sabato'],
              shortDays: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
              months: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'],
              shortMonths: ['pr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d/%m/%Y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          nl_NL: {
              days: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
              shortDays: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
              months: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
              shortMonths: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d-%m-%y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          pt_BR: {
              days: ['domingo', 'segunda', 'terÃ§a', 'quarta', 'quinta', 'sexta', 'sÃ¡bado'],
              shortDays: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'SÃ¡b'],
              months: ['janeiro', 'fevereiro', 'marÃ§o', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'],
              shortMonths: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d-%m-%Y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          ru_RU: {
              days: ['ÐÐ¾ÑÐºÑÐµÑÐµÐ½ÑÐµ', 'ÐÐ¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº', 'ÐÑÐ¾ÑÐ½Ð¸Ðº', 'Ð¡ÑÐµÐ´Ð°', 'Ð§ÐµÑÐ²ÐµÑÐ³', 'ÐÑÑÐ½Ð¸ÑÐ°', 'Ð¡ÑÐ±Ð±Ð¾ÑÐ°'],
              shortDays: ['ÐÑ', 'ÐÐ½', 'ÐÑ', 'Ð¡Ñ', 'Ð§Ñ', 'ÐÑ', 'Ð¡Ð±'],
              months: ['Ð¯Ð½Ð²Ð°ÑÑ', 'Ð¤ÐµÐ²ÑÐ°Ð»Ñ', 'ÐÐ°ÑÑ', 'ÐÐ¿ÑÐµÐ»Ñ', 'ÐÐ°Ð¹', 'ÐÑÐ½Ñ', 'ÐÑÐ»Ñ', 'ÐÐ²Ð³ÑÑÑ', 'Ð¡ÐµÐ½ÑÑÐ±ÑÑ', 'ÐÐºÑÑÐ±ÑÑ', 'ÐÐ¾ÑÐ±ÑÑ', 'ÐÐµÐºÐ°Ð±ÑÑ'],
              shortMonths: ['ÑÐ½Ð²', 'ÑÐµÐ²', 'Ð¼Ð°Ñ', 'Ð°Ð¿Ñ', 'Ð¼Ð°Ð¹', 'Ð¸ÑÐ½', 'Ð¸ÑÐ»', 'Ð°Ð²Ð³', 'ÑÐµÐ½', 'Ð¾ÐºÑ', 'Ð½Ð¾Ñ', 'Ð´ÐµÐº'],
              AM: 'AM',
              PM: 'PM',
              am: 'am',
              pm: 'pm',
              formats: {
                  c: '%a %d %b %Y %X',
                  D: '%d.%m.%y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          tr_TR: {
              days: ['Pazar', 'Pazartesi', 'SalÄ±','ÃarÅamba', 'PerÅembe', 'Cuma', 'Cumartesi'],
              shortDays: ['Paz', 'Pzt', 'Sal', 'ÃrÅ', 'PrÅ', 'Cum', 'Cts'],
              months: ['Ocak', 'Åubat', 'Mart', 'Nisan', 'MayÄ±s', 'Haziran', 'Temmuz', 'AÄustos', 'EylÃ¼l', 'Ekim', 'KasÄ±m', 'AralÄ±k'],
              shortMonths: ['Oca', 'Åub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'AÄu', 'Eyl', 'Eki', 'Kas', 'Ara'],
              AM: 'ÃÃ',
              PM: 'ÃS',
              am: 'ÃÃ',
              pm: 'ÃS',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d-%m-%Y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%T',
                  x: '%D'
              }
          },

          // By michaeljayt<michaeljayt@gmail.com>
          // https://github.com/michaeljayt/strftime/commit/bcb4c12743811d51e568175aa7bff3fd2a77cef3
          zh_CN: {
              days: ['æææ¥', 'ææä¸', 'ææäº', 'ææä¸', 'ææå', 'ææäº', 'ææå­'],
              shortDays: ['æ¥', 'ä¸', 'äº', 'ä¸', 'å', 'äº', 'å­'],
              months: ['ä¸æä»½', 'äºæä»½', 'ä¸æä»½', 'åæä»½', 'äºæä»½', 'å­æä»½', 'ä¸æä»½', 'å«æä»½', 'ä¹æä»½', 'åæä»½', 'åä¸æä»½', 'åäºæä»½'],
              shortMonths: ['ä¸æ', 'äºæ', 'ä¸æ', 'åæ', 'äºæ', 'å­æ', 'ä¸æ', 'å«æ', 'ä¹æ', 'åæ', 'åä¸æ', 'åäºæ'],
              AM: 'ä¸å',
              PM: 'ä¸å',
              am: 'ä¸å',
              pm: 'ä¸å',
              formats: {
                  c: '%a %d %b %Y %X %Z',
                  D: '%d/%m/%y',
                  F: '%Y-%m-%d',
                  R: '%H:%M',
                  r: '%I:%M:%S %p',
                  T: '%H:%M:%S',
                  v: '%e-%b-%Y',
                  X: '%r',
                  x: '%D'
              }
          }
      };

      var DefaultLocale = Locales['en_US'],
          defaultStrftime = new Strftime(DefaultLocale, 0, false);

      // CommonJS / Node module
      {
          module.exports = defaultStrftime;
      }

      // Polyfill Date.now for old browsers.
      if (typeof Date.now !== 'function') {
          Date.now = function() {
            return +new Date();
          };
      }

      function Strftime(locale, customTimezoneOffset, useUtcTimezone) {
          var _locale = locale || DefaultLocale,
              _customTimezoneOffset = customTimezoneOffset || 0,
              _useUtcBasedDate = useUtcTimezone || false,

              // we store unix timestamp value here to not create new Date() each iteration (each millisecond)
              // Date.now() is 2 times faster than new Date()
              // while millisecond precise is enough here
              // this could be very helpful when strftime triggered a lot of times one by one
              _cachedDateTimestamp = 0,
              _cachedDate;

          function _strftime(format, date) {
              var timestamp;

              if (!date) {
                  var currentTimestamp = Date.now();
                  if (currentTimestamp > _cachedDateTimestamp) {
                      _cachedDateTimestamp = currentTimestamp;
                      _cachedDate = new Date(_cachedDateTimestamp);

                      timestamp = _cachedDateTimestamp;

                      if (_useUtcBasedDate) {
                          // how to avoid duplication of date instantiation for utc here?
                          // we tied to getTimezoneOffset of the current date
                          _cachedDate = new Date(_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate) + _customTimezoneOffset);
                      }
                  }
                  else {
                    timestamp = _cachedDateTimestamp;
                  }
                  date = _cachedDate;
              }
              else {
                  timestamp = date.getTime();

                  if (_useUtcBasedDate) {
                      var utcOffset = getTimestampToUtcOffsetFor(date);
                      date = new Date(timestamp + utcOffset + _customTimezoneOffset);
                      // If we've crossed a DST boundary with this calculation we need to
                      // adjust the new date accordingly or it will be off by an hour in UTC.
                      if (getTimestampToUtcOffsetFor(date) !== utcOffset) {
                          var newUTCOffset = getTimestampToUtcOffsetFor(date);
                          date = new Date(timestamp + newUTCOffset + _customTimezoneOffset);
                      }
                  }
              }

              return _processFormat(format, date, _locale, timestamp);
          }

          function _processFormat(format, date, locale, timestamp) {
              var resultString = '',
                  padding = null,
                  isInScope = false,
                  length = format.length,
                  extendedTZ = false;

              for (var i = 0; i < length; i++) {

                  var currentCharCode = format.charCodeAt(i);

                  if (isInScope === true) {
                      // '-'
                      if (currentCharCode === 45) {
                          padding = '';
                          continue;
                      }
                      // '_'
                      else if (currentCharCode === 95) {
                          padding = ' ';
                          continue;
                      }
                      // '0'
                      else if (currentCharCode === 48) {
                          padding = '0';
                          continue;
                      }
                      // ':'
                      else if (currentCharCode === 58) {
                        if (extendedTZ) {
                            warn("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                        }
                        extendedTZ = true;
                        continue;
                      }

                      switch (currentCharCode) {

                          // Examples for new Date(0) in GMT

                          // '%'
                          // case '%':
                          case 37:
                              resultString += '%';
                              break;

                          // 'Thursday'
                          // case 'A':
                          case 65:
                              resultString += locale.days[date.getDay()];
                              break;

                          // 'January'
                          // case 'B':
                          case 66:
                              resultString += locale.months[date.getMonth()];
                              break;

                          // '19'
                          // case 'C':
                          case 67:
                              resultString += padTill2(Math.floor(date.getFullYear() / 100), padding);
                              break;

                          // '01/01/70'
                          // case 'D':
                          case 68:
                              resultString += _processFormat(locale.formats.D, date, locale, timestamp);
                              break;

                          // '1970-01-01'
                          // case 'F':
                          case 70:
                              resultString += _processFormat(locale.formats.F, date, locale, timestamp);
                              break;

                          // '00'
                          // case 'H':
                          case 72:
                              resultString += padTill2(date.getHours(), padding);
                              break;

                          // '12'
                          // case 'I':
                          case 73:
                              resultString += padTill2(hours12(date.getHours()), padding);
                              break;

                          // '000'
                          // case 'L':
                          case 76:
                              resultString += padTill3(Math.floor(timestamp % 1000));
                              break;

                          // '00'
                          // case 'M':
                          case 77:
                              resultString += padTill2(date.getMinutes(), padding);
                              break;

                          // 'am'
                          // case 'P':
                          case 80:
                              resultString += date.getHours() < 12 ? locale.am : locale.pm;
                              break;

                          // '00:00'
                          // case 'R':
                          case 82:
                              resultString += _processFormat(locale.formats.R, date, locale, timestamp);
                              break;

                          // '00'
                          // case 'S':
                          case 83:
                              resultString += padTill2(date.getSeconds(), padding);
                              break;

                          // '00:00:00'
                          // case 'T':
                          case 84:
                              resultString += _processFormat(locale.formats.T, date, locale, timestamp);
                              break;

                          // '00'
                          // case 'U':
                          case 85:
                              resultString += padTill2(weekNumber(date, 'sunday'), padding);
                              break;

                          // '00'
                          // case 'W':
                          case 87:
                              resultString += padTill2(weekNumber(date, 'monday'), padding);
                              break;

                          // '16:00:00'
                          // case 'X':
                          case 88:
                              resultString += _processFormat(locale.formats.X, date, locale, timestamp);
                              break;

                          // '1970'
                          // case 'Y':
                          case 89:
                              resultString += date.getFullYear();
                              break;

                          // 'GMT'
                          // case 'Z':
                          case 90:
                              if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                                  resultString += "GMT";
                              }
                              else {
                                  // fixme optimize
                                  var tzString = date.toString().match(/\(([\w\s]+)\)/);
                                  resultString += tzString && tzString[1] || '';
                              }
                              break;

                          // 'Thu'
                          // case 'a':
                          case 97:
                              resultString += locale.shortDays[date.getDay()];
                              break;

                          // 'Jan'
                          // case 'b':
                          case 98:
                              resultString += locale.shortMonths[date.getMonth()];
                              break;

                          // ''
                          // case 'c':
                          case 99:
                              resultString += _processFormat(locale.formats.c, date, locale, timestamp);
                              break;

                          // '01'
                          // case 'd':
                          case 100:
                              resultString += padTill2(date.getDate(), padding);
                              break;

                          // ' 1'
                          // case 'e':
                          case 101:
                              resultString += padTill2(date.getDate(), padding == null ? ' ' : padding);
                              break;

                          // 'Jan'
                          // case 'h':
                          case 104:
                              resultString += locale.shortMonths[date.getMonth()];
                              break;

                          // '000'
                          // case 'j':
                          case 106:
                              var y = new Date(date.getFullYear(), 0, 1);
                              var day = Math.ceil((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
                              resultString += padTill3(day);
                              break;

                          // ' 0'
                          // case 'k':
                          case 107:
                              resultString += padTill2(date.getHours(), padding == null ? ' ' : padding);
                              break;

                          // '12'
                          // case 'l':
                          case 108:
                              resultString += padTill2(hours12(date.getHours()), padding == null ? ' ' : padding);
                              break;

                          // '01'
                          // case 'm':
                          case 109:
                              resultString += padTill2(date.getMonth() + 1, padding);
                              break;

                          // '\n'
                          // case 'n':
                          case 110:
                              resultString += '\n';
                              break;

                          // '1st'
                          // case 'o':
                          case 111:
                              // Try to use an ordinal suffix from the locale, but fall back to using the old
                              // function for compatibility with old locales that lack them.
                              var day = date.getDate();
                              if (locale.ordinalSuffixes) {
                                  resultString += String(day) + (locale.ordinalSuffixes[day - 1] || ordinal(day));
                              }
                              else {
                                  resultString += String(day) + ordinal(day);
                              }
                              break;

                          // 'AM'
                          // case 'p':
                          case 112:
                              resultString += date.getHours() < 12 ? locale.AM : locale.PM;
                              break;

                          // '12:00:00 AM'
                          // case 'r':
                          case 114:
                              resultString += _processFormat(locale.formats.r, date, locale, timestamp);
                              break;

                          // '0'
                          // case 's':
                          case 115:
                              resultString += Math.floor(timestamp / 1000);
                              break;

                          // '\t'
                          // case 't':
                          case 116:
                              resultString += '\t';
                              break;

                          // '4'
                          // case 'u':
                          case 117:
                              var day = date.getDay();
                              resultString += day === 0 ? 7 : day;
                              break; // 1 - 7, Monday is first day of the week

                          // ' 1-Jan-1970'
                          // case 'v':
                          case 118:
                              resultString += _processFormat(locale.formats.v, date, locale, timestamp);
                              break;

                          // '4'
                          // case 'w':
                          case 119:
                              resultString += date.getDay();
                              break; // 0 - 6, Sunday is first day of the week

                          // '12/31/69'
                          // case 'x':
                          case 120:
                              resultString += _processFormat(locale.formats.x, date, locale, timestamp);
                              break;

                          // '70'
                          // case 'y':
                          case 121:
                              resultString += ('' + date.getFullYear()).slice(2);
                              break;

                          // '+0000'
                          // case 'z':
                          case 122:
                              if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                                  resultString += extendedTZ ? "+00:00" : "+0000";
                              }
                              else {
                                  var off;
                                  if (_customTimezoneOffset !== 0) {
                                      off = _customTimezoneOffset / (60 * 1000);
                                  }
                                  else {
                                      off = -date.getTimezoneOffset();
                                  }
                                  var sign = off < 0 ? '-' : '+';
                                  var sep = extendedTZ ? ':' : '';
                                  var hours = Math.floor(Math.abs(off / 60));
                                  var mins = Math.abs(off % 60);
                                  resultString += sign + padTill2(hours) + sep + padTill2(mins);
                              }
                              break;

                          default:
                              if (isInScope) {
                                  resultString += '%';
                              }
                              resultString += format[i];
                              break;
                      }

                      padding = null;
                      isInScope = false;
                      continue;
                  }

                  // '%'
                  if (currentCharCode === 37) {
                      isInScope = true;
                      continue;
                  }

                  resultString += format[i];
              }

              return resultString;
          }

          var strftime = _strftime;

          strftime.localize = function(locale) {
              return new Strftime(locale || _locale, _customTimezoneOffset, _useUtcBasedDate);
          };

          strftime.localizeByIdentifier = function(localeIdentifier) {
              var locale = Locales[localeIdentifier];
              if (!locale) {
                  warn('[WARNING] No locale found with identifier "' + localeIdentifier + '".');
                  return strftime;
              }
              return strftime.localize(locale);
          };

          strftime.timezone = function(timezone) {
              var customTimezoneOffset = _customTimezoneOffset;
              var useUtcBasedDate = _useUtcBasedDate;

              var timezoneType = typeof timezone;
              if (timezoneType === 'number' || timezoneType === 'string') {
                  useUtcBasedDate = true;

                  // ISO 8601 format timezone string, [-+]HHMM
                  if (timezoneType === 'string') {
                      var sign = timezone[0] === '-' ? -1 : 1,
                          hours = parseInt(timezone.slice(1, 3), 10),
                          minutes = parseInt(timezone.slice(3, 5), 10);

                      customTimezoneOffset = sign * ((60 * hours) + minutes) * 60 * 1000;
                      // in minutes: 420
                  }
                  else if (timezoneType === 'number') {
                      customTimezoneOffset = timezone * 60 * 1000;
                  }
              }

              return new Strftime(_locale, customTimezoneOffset, useUtcBasedDate);
          };

          strftime.utc = function() {
              return new Strftime(_locale, _customTimezoneOffset, true);
          };

          return strftime;
      }

      function padTill2(numberToPad, paddingChar) {
          if (paddingChar === '' || numberToPad > 9) {
              return numberToPad;
          }
          if (paddingChar == null) {
              paddingChar = '0';
          }
          return paddingChar + numberToPad;
      }

      function padTill3(numberToPad) {
          if (numberToPad > 99) {
              return numberToPad;
          }
          if (numberToPad > 9) {
              return '0' + numberToPad;
          }
          return '00' + numberToPad;
      }

      function hours12(hour) {
          if (hour === 0) {
              return 12;
          }
          else if (hour > 12) {
              return hour - 12;
          }
          return hour;
      }

      // firstWeekday: 'sunday' or 'monday', default is 'sunday'
      //
      // Pilfered & ported from Ruby's strftime implementation.
      function weekNumber(date, firstWeekday) {
          firstWeekday = firstWeekday || 'sunday';

          // This works by shifting the weekday back by one day if we
          // are treating Monday as the first day of the week.
          var weekday = date.getDay();
          if (firstWeekday === 'monday') {
              if (weekday === 0) // Sunday
                  weekday = 6;
              else
                  weekday--;
          }

          var firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1),
              dateUtc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
              yday = Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
              weekNum = (yday + 7 - weekday) / 7;

          return Math.floor(weekNum);
      }

      // Get the ordinal suffix for a number: st, nd, rd, or th
      function ordinal(number) {
          var i = number % 10;
          var ii = number % 100;

          if ((ii >= 11 && ii <= 13) || i === 0 || i >= 4) {
              return 'th';
          }
          switch (i) {
              case 1: return 'st';
              case 2: return 'nd';
              case 3: return 'rd';
          }
      }

      function getTimestampToUtcOffsetFor(date) {
          return (date.getTimezoneOffset() || 0) * 60000;
      }

      function warn(message) {
          if (typeof console !== 'undefined' && typeof console.warn == 'function') {
              console.warn(message);
          }
      }

  }());
  }(strftime));

  var momentWithLocales = {exports: {}};

  (function (module, exports) {
  (function (global, factory) {
      module.exports = factory() ;
  }(commonjsGlobal, (function () {
      var hookCallback;

      function hooks() {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback(callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return (
              input instanceof Array ||
              Object.prototype.toString.call(input) === '[object Array]'
          );
      }

      function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return (
              input != null &&
              Object.prototype.toString.call(input) === '[object Object]'
          );
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
              return Object.getOwnPropertyNames(obj).length === 0;
          } else {
              var k;
              for (k in obj) {
                  if (hasOwnProp(obj, k)) {
                      return false;
                  }
              }
              return true;
          }
      }

      function isUndefined(input) {
          return input === void 0;
      }

      function isNumber(input) {
          return (
              typeof input === 'number' ||
              Object.prototype.toString.call(input) === '[object Number]'
          );
      }

      function isDate(input) {
          return (
              input instanceof Date ||
              Object.prototype.toString.call(input) === '[object Date]'
          );
      }

      function map(arr, fn) {
          var res = [],
              i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidEra: null,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false,
              parsedDateParts: [],
              era: null,
              meridiem: null,
              rfc2822: false,
              weekdayMismatch: false,
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this),
                  len = t.length >>> 0,
                  i;

              for (i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m),
                  parsedParts = some.call(flags.parsedDateParts, function (i) {
                      return i != null;
                  }),
                  isNowValid =
                      !isNaN(m._d.getTime()) &&
                      flags.overflow < 0 &&
                      !flags.empty &&
                      !flags.invalidEra &&
                      !flags.invalidMonth &&
                      !flags.invalidWeekday &&
                      !flags.weekdayMismatch &&
                      !flags.nullInput &&
                      !flags.invalidFormat &&
                      !flags.userInvalidated &&
                      (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  isNowValid =
                      isNowValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                  m._isValid = isNowValid;
              } else {
                  return isNowValid;
              }
          }
          return m._isValid;
      }

      function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          } else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = (hooks.momentProperties = []),
          updateInProgress = false;

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i = 0; i < momentProperties.length; i++) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
              this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment(obj) {
          return (
              obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
          );
      }

      function warn(msg) {
          if (
              hooks.suppressDeprecationWarnings === false &&
              typeof console !== 'undefined' &&
              console.warn
          ) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (hooks.deprecationHandler != null) {
                  hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  var args = [],
                      arg,
                      i,
                      key;
                  for (i = 0; i < arguments.length; i++) {
                      arg = '';
                      if (typeof arguments[i] === 'object') {
                          arg += '\n[' + i + '] ';
                          for (key in arguments[0]) {
                              if (hasOwnProp(arguments[0], key)) {
                                  arg += key + ': ' + arguments[0][key] + ', ';
                              }
                          }
                          arg = arg.slice(0, -2); // Remove trailing comma and space
                      } else {
                          arg = arguments[i];
                      }
                      args.push(arg);
                  }
                  warn(
                      msg +
                          '\nArguments: ' +
                          Array.prototype.slice.call(args).join('') +
                          '\n' +
                          new Error().stack
                  );
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
          return (
              (typeof Function !== 'undefined' && input instanceof Function) ||
              Object.prototype.toString.call(input) === '[object Function]'
          );
      }

      function set(config) {
          var prop, i;
          for (i in config) {
              if (hasOwnProp(config, i)) {
                  prop = config[i];
                  if (isFunction(prop)) {
                      this[i] = prop;
                  } else {
                      this['_' + i] = prop;
                  }
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                  '|' +
                  /\d{1,2}/.source
          );
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
              prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          for (prop in parentConfig) {
              if (
                  hasOwnProp(parentConfig, prop) &&
                  !hasOwnProp(childConfig, prop) &&
                  isObject(parentConfig[prop])
              ) {
                  // make sure changes to properties don't modify parent config
                  res[prop] = extend({}, res[prop]);
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i,
                  res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      };

      function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (
              (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
              absNumber
          );
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(
                      func.apply(this, arguments),
                      token
                  );
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
              i,
              length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '',
                  i;
              for (i = 0; i < length; i++) {
                  output += isFunction(array[i])
                      ? array[i].call(mom, format)
                      : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] =
              formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(
                  localFormattingTokens,
                  replaceLongDateFormatTokens
              );
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
      };

      function longDateFormat(key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper
              .match(formattingTokens)
              .map(function (tok) {
                  if (
                      tok === 'MMMM' ||
                      tok === 'MM' ||
                      tok === 'DD' ||
                      tok === 'dddd'
                  ) {
                      return tok.slice(1);
                  }
                  return tok;
              })
              .join('');

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate() {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal(number) {
          return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      };

      function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output)
              ? output(number, withoutSuffix, string, isFuture)
              : output.replace(/%d/i, number);
      }

      function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string'
              ? aliases[units] || aliases[units.toLowerCase()]
              : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
          var units = [],
              u;
          for (u in unitsObj) {
              if (hasOwnProp(unitsObj, u)) {
                  units.push({ unit: u, priority: priorities[u] });
              }
          }
          units.sort(function (a, b) {
              return a.priority - b.priority;
          });
          return units;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      function absFloor(number) {
          if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      function makeGetSet(unit, keepTime) {
          return function (value) {
              if (value != null) {
                  set$1(this, unit, value);
                  hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get(this, unit);
              }
          };
      }

      function get(mom, unit) {
          return mom.isValid()
              ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
              : NaN;
      }

      function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
              if (
                  unit === 'FullYear' &&
                  isLeapYear(mom.year()) &&
                  mom.month() === 1 &&
                  mom.date() === 29
              ) {
                  value = toInt(value);
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                      value,
                      mom.month(),
                      daysInMonth(value, mom.month())
                  );
              } else {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
              }
          }
      }

      // MOMENTS

      function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units]();
          }
          return this;
      }

      function stringSet(units, value) {
          if (typeof units === 'object') {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units),
                  i;
              for (i = 0; i < prioritized.length; i++) {
                  this[prioritized[i].unit](units[prioritized[i].unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      var match1 = /\d/, //       0 - 9
          match2 = /\d\d/, //      00 - 99
          match3 = /\d{3}/, //     000 - 999
          match4 = /\d{4}/, //    0000 - 9999
          match6 = /[+-]?\d{6}/, // -999999 - 999999
          match1to2 = /\d\d?/, //       0 - 99
          match3to4 = /\d\d\d\d?/, //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
          match1to3 = /\d{1,3}/, //       0 - 999
          match1to4 = /\d{1,4}/, //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
          matchUnsigned = /\d+/, //       0 - inf
          matchSigned = /[+-]?\d+/, //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          regexes;

      regexes = {};

      function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex)
              ? regex
              : function (isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex;
                };
      }

      function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(
              s
                  .replace('\\', '')
                  .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                      matched,
                      p1,
                      p2,
                      p3,
                      p4
                  ) {
                      return p1 || p2 || p3 || p4;
                  })
          );
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken(token, callback) {
          var i,
              func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (isNumber(callback)) {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;

      function mod(n, x) {
          return ((n % x) + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
              return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1
              ? isLeapYear(year)
                  ? 29
                  : 28
              : 31 - ((modMonth % 7) % 2);
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
              '_'
          ),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;

      function localeMonths(m, format) {
          if (!m) {
              return isArray(this._months)
                  ? this._months
                  : this._months['standalone'];
          }
          return isArray(this._months)
              ? this._months[m.month()]
              : this._months[
                    (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                        ? 'format'
                        : 'standalone'
                ][m.month()];
      }

      function localeMonthsShort(m, format) {
          if (!m) {
              return isArray(this._monthsShort)
                  ? this._monthsShort
                  : this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort)
              ? this._monthsShort[m.month()]
              : this._monthsShort[
                    MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                ][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
          var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp(
                      '^' + this.months(mom, '').replace('.', '') + '$',
                      'i'
                  );
                  this._shortMonthsParse[i] = new RegExp(
                      '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                      'i'
                  );
              }
              if (!strict && !this._monthsParse[i]) {
                  regex =
                      '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'MMMM' &&
                  this._longMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'MMM' &&
                  this._shortMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth(mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (!isNumber(value)) {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth(value) {
          if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
          } else {
              return get(this, 'Month');
          }
      }

      function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
      }

      function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsShortRegex')) {
                  this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict
                  ? this._monthsShortStrictRegex
                  : this._monthsShortRegex;
          }
      }

      function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict
                  ? this._monthsStrictRegex
                  : this._monthsRegex;
          }
      }

      function computeMonthsParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._monthsShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] =
              input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear() {
          return isLeapYear(this.year());
      }

      function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              date = new Date(y + 400, m, d, h, M, s, ms);
              if (isFinite(date.getFullYear())) {
                  date.setFullYear(y);
              }
          } else {
              date = new Date(y, m, d, h, M, s, ms);
          }

          return date;
      }

      function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              args = Array.prototype.slice.call(arguments);
              // preserve leap years using a full 400 year cycle, then reset
              args[0] = y + 400;
              date = new Date(Date.UTC.apply(null, args));
              if (isFinite(date.getUTCFullYear())) {
                  date.setUTCFullYear(y);
              }
          } else {
              date = new Date(Date.UTC.apply(null, arguments));
          }

          return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear,
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear,
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
          input,
          week,
          config,
          token
      ) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      };

      function localeFirstDayOfWeek() {
          return this._week.dow;
      }

      function localeFirstDayOfYear() {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
              return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
      }

      // LOCALES
      function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
      }

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;

      function localeWeekdays(m, format) {
          var weekdays = isArray(this._weekdays)
              ? this._weekdays
              : this._weekdays[
                    m && m !== true && this._weekdays.isFormat.test(format)
                        ? 'format'
                        : 'standalone'
                ];
          return m === true
              ? shiftWeekdays(weekdays, this._week.dow)
              : m
              ? weekdays[m.day()]
              : weekdays;
      }

      function localeWeekdaysShort(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysShort, this._week.dow)
              : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
      }

      function localeWeekdaysMin(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysMin, this._week.dow)
              : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
          var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._shortWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._minWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
              }
              if (!this._weekdaysParse[i]) {
                  regex =
                      '^' +
                      this.weekdays(mom, '') +
                      '|^' +
                      this.weekdaysShort(mom, '') +
                      '|^' +
                      this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'dddd' &&
                  this._fullWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'ddd' &&
                  this._shortWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'dd' &&
                  this._minWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
              return this.day() || 7;
          }
      }

      function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict
                  ? this._weekdaysStrictRegex
                  : this._weekdaysRegex;
          }
      }

      function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                  this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict
                  ? this._weekdaysShortStrictRegex
                  : this._weekdaysShortRegex;
          }
      }

      function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                  this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict
                  ? this._weekdaysMinStrictRegex
                  : this._weekdaysMinRegex;
          }
      }

      function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = regexEscape(this.weekdaysMin(mom, ''));
              shortp = regexEscape(this.weekdaysShort(mom, ''));
              longp = regexEscape(this.weekdays(mom, ''));
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._weekdaysShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
          this._weekdaysMinStrictRegex = new RegExp(
              '^(' + minPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return (
              '' +
              hFormat.apply(this) +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return (
              '' +
              this.hours() +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(
                  this.hours(),
                  this.minutes(),
                  lowercase
              );
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('k', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);

      function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }

      var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,

          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,

          week: defaultLocaleWeek,

          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,

          meridiemParse: defaultLocaleMeridiemParse,
      };

      // internal storage for locale config files
      var locales = {},
          localeFamilies = {},
          globalLocale;

      function commonPrefix(arr1, arr2) {
          var i,
              minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
              if (arr1[i] !== arr2[i]) {
                  return i;
              }
          }
          return minl;
      }

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0,
              j,
              next,
              locale,
              split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (
                      next &&
                      next.length >= j &&
                      commonPrefix(split, next) >= j - 1
                  ) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return globalLocale;
      }

      function loadLocale(name) {
          var oldLocale = null,
              aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (
              locales[name] === undefined &&
              'object' !== 'undefined' &&
              module &&
              module.exports
          ) {
              try {
                  oldLocale = globalLocale._abbr;
                  aliasedRequire = commonjsRequire;
                  aliasedRequire('./locale/' + name);
                  getSetGlobalLocale(oldLocale);
              } catch (e) {
                  // mark as not found to avoid repeating expensive file require call causing high CPU
                  // when trying to find en-US, en_US, en-us for every format call
                  locales[name] = null; // null means not found
              }
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = getLocale(key);
              } else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              } else {
                  if (typeof console !== 'undefined' && console.warn) {
                      //warn user if arguments are passed but the locale could not be set
                      console.warn(
                          'Locale ' + key + ' not found. Did you forget to load it?'
                      );
                  }
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale(name, config) {
          if (config !== null) {
              var locale,
                  parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple(
                      'defineLocaleOverride',
                      'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                  );
                  parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      parentConfig = locales[config.parentLocale]._config;
                  } else {
                      locale = loadLocale(config.parentLocale);
                      if (locale != null) {
                          parentConfig = locale._config;
                      } else {
                          if (!localeFamilies[config.parentLocale]) {
                              localeFamilies[config.parentLocale] = [];
                          }
                          localeFamilies[config.parentLocale].push({
                              name: name,
                              config: config,
                          });
                          return null;
                      }
                  }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                  localeFamilies[name].forEach(function (x) {
                      defineLocale(x.name, x.config);
                  });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);

              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale,
                  tmpLocale,
                  parentConfig = baseConfig;

              if (locales[name] != null && locales[name].parentLocale != null) {
                  // Update existing child locale in-place to avoid memory-leaks
                  locales[name].set(mergeConfigs(locales[name]._config, config));
              } else {
                  // MERGE
                  tmpLocale = loadLocale(name);
                  if (tmpLocale != null) {
                      parentConfig = tmpLocale._config;
                  }
                  config = mergeConfigs(parentConfig, config);
                  if (tmpLocale == null) {
                      // updateLocale is called for creating a new locale
                      // Set abbr so it will have a name (getters return
                      // undefined otherwise).
                      config.abbr = name;
                  }
                  locale = new Locale(config);
                  locale.parentLocale = locales[name];
                  locales[name] = locale;
              }

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                      if (name === getSetGlobalLocale()) {
                          getSetGlobalLocale(name);
                      }
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function getLocale(key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function listLocales() {
          return keys(locales);
      }

      function checkOverflow(m) {
          var overflow,
              a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH] < 0 || a[MONTH] > 11
                      ? MONTH
                      : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                      ? DATE
                      : a[HOUR] < 0 ||
                        a[HOUR] > 24 ||
                        (a[HOUR] === 24 &&
                            (a[MINUTE] !== 0 ||
                                a[SECOND] !== 0 ||
                                a[MILLISECOND] !== 0))
                      ? HOUR
                      : a[MINUTE] < 0 || a[MINUTE] > 59
                      ? MINUTE
                      : a[SECOND] < 0 || a[SECOND] > 59
                      ? SECOND
                      : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                      ? MILLISECOND
                      : -1;

              if (
                  getParsingFlags(m)._overflowDayOfYear &&
                  (overflow < YEAR || overflow > DATE)
              ) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [
              ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
              ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
              ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
              ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
              ['YYYY-DDD', /\d{4}-\d{3}/],
              ['YYYY-MM', /\d{4}-\d\d/, false],
              ['YYYYYYMMDD', /[+-]\d{10}/],
              ['YYYYMMDD', /\d{8}/],
              ['GGGG[W]WWE', /\d{4}W\d{3}/],
              ['GGGG[W]WW', /\d{4}W\d{2}/, false],
              ['YYYYDDD', /\d{7}/],
              ['YYYYMM', /\d{6}/, false],
              ['YYYY', /\d{4}/, false],
          ],
          // iso time formats and regexes
          isoTimes = [
              ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
              ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
              ['HH:mm:ss', /\d\d:\d\d:\d\d/],
              ['HH:mm', /\d\d:\d\d/],
              ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
              ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
              ['HHmmss', /\d\d\d\d\d\d/],
              ['HHmm', /\d\d\d\d/],
              ['HH', /\d\d/],
          ],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
              UT: 0,
              GMT: 0,
              EDT: -4 * 60,
              EST: -5 * 60,
              CDT: -5 * 60,
              CST: -6 * 60,
              MDT: -6 * 60,
              MST: -7 * 60,
              PDT: -7 * 60,
              PST: -8 * 60,
          };

      // date from iso format
      function configFromISO(config) {
          var i,
              l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      function extractFromRFC2822Strings(
          yearStr,
          monthStr,
          dayStr,
          hourStr,
          minuteStr,
          secondStr
      ) {
          var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10),
          ];

          if (secondStr) {
              result.push(parseInt(secondStr, 10));
          }

          return result;
      }

      function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
              return 2000 + year;
          } else if (year <= 999) {
              return 1900 + year;
          }
          return year;
      }

      function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s
              .replace(/\([^)]*\)|[\n\t]/g, ' ')
              .replace(/(\s\s+)/g, ' ')
              .replace(/^\s\s*/, '')
              .replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
              var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                  weekdayActual = new Date(
                      parsedInput[0],
                      parsedInput[1],
                      parsedInput[2]
                  ).getDay();
              if (weekdayProvided !== weekdayActual) {
                  getParsingFlags(config).weekdayMismatch = true;
                  config._isValid = false;
                  return false;
              }
          }
          return true;
      }

      function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
              return obsOffsets[obsOffset];
          } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
          } else {
              var hm = parseInt(numOffset, 10),
                  m = hm % 100,
                  h = (hm - m) / 100;
              return h * 60 + m;
          }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
              parsedArray;
          if (match) {
              parsedArray = extractFromRFC2822Strings(
                  match[4],
                  match[3],
                  match[2],
                  match[5],
                  match[6],
                  match[7]
              );
              if (!checkWeekday(match[1], parsedArray, config)) {
                  return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
          } else {
              config._isValid = false;
          }
      }

      // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          configFromRFC2822(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          if (config._strict) {
              config._isValid = false;
          } else {
              // Final attempt, use Input Fallback
              hooks.createFromInputFallback(config);
          }
      }

      hooks.createFromInputFallback = deprecate(
          'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
              'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
              'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
              return [
                  nowValue.getUTCFullYear(),
                  nowValue.getUTCMonth(),
                  nowValue.getUTCDate(),
              ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray(config) {
          var i,
              date,
              input = [],
              currentDate,
              expectedWeekday,
              yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (
                  config._dayOfYear > daysInYear(yearToUse) ||
                  config._dayOfYear === 0
              ) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] =
                  config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (
              config._a[HOUR] === 24 &&
              config._a[MINUTE] === 0 &&
              config._a[SECOND] === 0 &&
              config._a[MILLISECOND] === 0
          ) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(
              null,
              input
          );
          expectedWeekday = config._useUTC
              ? config._d.getUTCDay()
              : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (
              config._w &&
              typeof config._w.d !== 'undefined' &&
              config._w.d !== expectedWeekday
          ) {
              getParsingFlags(config).weekdayMismatch = true;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(
                  w.GG,
                  config._a[YEAR],
                  weekOfYear(createLocal(), 1, 4).year
              );
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from beginning of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to beginning of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
          }
          if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0,
              era;

          tokens =
              expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                  [])[0];
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(
                      string.indexOf(parsedInput) + parsedInput.length
                  );
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  } else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              } else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver =
              stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (
              config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0
          ) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(
              config._locale,
              config._a[HOUR],
              config._meridiem
          );

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
              config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }

          configFromArray(config);
          checkOverflow(config);
      }

      function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,
              scoreToBeat,
              i,
              currentScore,
              validFormatFound,
              bestFormatIsValid = false;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              validFormatFound = false;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (isValid(tempConfig)) {
                  validFormatFound = true;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (!bestFormatIsValid) {
                  if (
                      scoreToBeat == null ||
                      currentScore < scoreToBeat ||
                      validFormatFound
                  ) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                      if (validFormatFound) {
                          bestFormatIsValid = true;
                      }
                  }
              } else {
                  if (currentScore < scoreToBeat) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                  }
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i),
              dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map(
              [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
              function (obj) {
                  return obj && parseInt(obj, 10);
              }
          );

          configFromArray(config);
      }

      function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig(config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return createInvalid({ nullInput: true });
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
              config._d = input;
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          } else {
              configFromInput(config);
          }

          if (!isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
              config._d = new Date(hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (isObject(input)) {
              configFromObject(config);
          } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
          } else {
              hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};

          if (format === true || format === false) {
              strict = format;
              format = undefined;
          }

          if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
          }

          if (
              (isObject(input) && isObjectEmpty(input)) ||
              (isArray(input) && input.length === 0)
          ) {
              input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
              'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other < this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          ),
          prototypeMax = deprecate(
              'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other > this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +new Date();
      };

      var ordering = [
          'year',
          'quarter',
          'month',
          'week',
          'day',
          'hour',
          'minute',
          'second',
          'millisecond',
      ];

      function isDurationValid(m) {
          var key,
              unitHasDecimal = false,
              i;
          for (key in m) {
              if (
                  hasOwnProp(m, key) &&
                  !(
                      indexOf.call(ordering, key) !== -1 &&
                      (m[key] == null || !isNaN(m[key]))
                  )
              ) {
                  return false;
              }
          }

          for (i = 0; i < ordering.length; ++i) {
              if (m[ordering[i]]) {
                  if (unitHasDecimal) {
                      return false; // only allow non-integers for smallest unit
                  }
                  if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                      unitHasDecimal = true;
                  }
              }
          }

          return true;
      }

      function isValid$1() {
          return this._isValid;
      }

      function createInvalid$1() {
          return createDuration(NaN);
      }

      function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds =
              +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;

          this._data = {};

          this._locale = getLocale();

          this._bubble();
      }

      function isDuration(obj) {
          return obj instanceof Duration;
      }

      function absRound(number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if (
                  (dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
              ) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      // FORMATTING

      function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset(),
                  sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return (
                  sign +
                  zeroFill(~~(offset / 60), 2) +
                  separator +
                  zeroFill(~~offset % 60, 2)
              );
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
              chunk,
              parts,
              minutes;

          if (matches === null) {
              return null;
          }

          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);

          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff =
                  (isMoment(input) || isDate(input)
                      ? input.valueOf()
                      : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
          } else {
              return createLocal(input).local();
          }
      }

      function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
                  if (input === null) {
                      return this;
                  }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      addSubtract(
                          this,
                          createDuration(input - offset, 'm'),
                          1,
                          false
                      );
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone(input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset() {
          if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                  this.utcOffset(tZone);
              } else {
                  this.utcOffset(0, true);
              }
          }
          return this;
      }

      function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime() {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {},
              other;

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted =
                  this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal() {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration(input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms: input._milliseconds,
                  d: input._days,
                  M: input._months,
              };
          } else if (isNumber(input) || !isNaN(+input)) {
              duration = {};
              if (key) {
                  duration[key] = +input;
              } else {
                  duration.milliseconds = +input;
              }
          } else if ((match = aspNetRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: 0,
                  d: toInt(match[DATE]) * sign,
                  h: toInt(match[HOUR]) * sign,
                  m: toInt(match[MINUTE]) * sign,
                  s: toInt(match[SECOND]) * sign,
                  ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
              };
          } else if ((match = isoRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: parseIso(match[2], sign),
                  M: parseIso(match[3], sign),
                  w: parseIso(match[4], sign),
                  d: parseIso(match[5], sign),
                  h: parseIso(match[6], sign),
                  m: parseIso(match[7], sign),
                  s: parseIso(match[8], sign),
              };
          } else if (duration == null) {
              // checks for null or undefined
              duration = {};
          } else if (
              typeof duration === 'object' &&
              ('from' in duration || 'to' in duration)
          ) {
              diffRes = momentsDifference(
                  createLocal(duration.from),
                  createLocal(duration.to)
              );

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
              ret._isValid = input._isValid;
          }

          return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {};

          res.months =
              other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +base.clone().add(res.months, 'M');

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return { milliseconds: 0, months: 0 };
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(
                      name,
                      'moment().' +
                          name +
                          '(period, number) is deprecated. Please use moment().' +
                          name +
                          '(number, period). ' +
                          'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                  );
                  tmp = val;
                  val = period;
                  period = tmp;
              }

              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
          };
      }

      function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (months) {
              setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
              set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
              hooks.updateOffset(mom, days || months);
          }
      }

      var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');

      function isString(input) {
          return typeof input === 'string' || input instanceof String;
      }

      // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
      function isMomentInput(input) {
          return (
              isMoment(input) ||
              isDate(input) ||
              isString(input) ||
              isNumber(input) ||
              isNumberOrStringArray(input) ||
              isMomentInputObject(input) ||
              input === null ||
              input === undefined
          );
      }

      function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'years',
                  'year',
                  'y',
                  'months',
                  'month',
                  'M',
                  'days',
                  'day',
                  'd',
                  'dates',
                  'date',
                  'D',
                  'hours',
                  'hour',
                  'h',
                  'minutes',
                  'minute',
                  'm',
                  'seconds',
                  'second',
                  's',
                  'milliseconds',
                  'millisecond',
                  'ms',
              ],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function isNumberOrStringArray(input) {
          var arrayTest = isArray(input),
              dataTypeTest = false;
          if (arrayTest) {
              dataTypeTest =
                  input.filter(function (item) {
                      return !isNumber(item) && isString(input);
                  }).length === 0;
          }
          return arrayTest && dataTypeTest;
      }

      function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'sameDay',
                  'nextDay',
                  'lastDay',
                  'nextWeek',
                  'lastWeek',
                  'sameElse',
              ],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6
              ? 'sameElse'
              : diff < -1
              ? 'lastWeek'
              : diff < 0
              ? 'lastDay'
              : diff < 1
              ? 'sameDay'
              : diff < 2
              ? 'nextDay'
              : diff < 7
              ? 'nextWeek'
              : 'sameElse';
      }

      function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
              if (!arguments[0]) {
                  time = undefined;
                  formats = undefined;
              } else if (isMomentInput(arguments[0])) {
                  time = arguments[0];
                  formats = undefined;
              } else if (isCalendarSpec(arguments[0])) {
                  formats = arguments[0];
                  time = undefined;
              }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse',
              output =
                  formats &&
                  (isFunction(formats[format])
                      ? formats[format].call(this, now)
                      : formats[format]);

          return this.format(
              output || this.localeData().calendar(format, this, createLocal(now))
          );
      }

      function clone() {
          return new Moment(this);
      }

      function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
              return false;
          }
          inclusivity = inclusivity || '()';
          return (
              (inclusivity[0] === '('
                  ? this.isAfter(localFrom, units)
                  : !this.isBefore(localFrom, units)) &&
              (inclusivity[1] === ')'
                  ? this.isBefore(localTo, units)
                  : !this.isAfter(localTo, units))
          );
      }

      function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return (
                  this.clone().startOf(units).valueOf() <= inputMs &&
                  inputMs <= this.clone().endOf(units).valueOf()
              );
          }
      }

      function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
      }

      function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
      }

      function diff(input, units, asFloat) {
          var that, zoneDelta, output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          switch (units) {
              case 'year':
                  output = monthDiff(this, that) / 12;
                  break;
              case 'month':
                  output = monthDiff(this, that);
                  break;
              case 'quarter':
                  output = monthDiff(this, that) / 3;
                  break;
              case 'second':
                  output = (this - that) / 1e3;
                  break; // 1000
              case 'minute':
                  output = (this - that) / 6e4;
                  break; // 1000 * 60
              case 'hour':
                  output = (this - that) / 36e5;
                  break; // 1000 * 60 * 60
              case 'day':
                  output = (this - that - zoneDelta) / 864e5;
                  break; // 1000 * 60 * 60 * 24, negate dst
              case 'week':
                  output = (this - that - zoneDelta) / 6048e5;
                  break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default:
                  output = this - that;
          }

          return asFloat ? output : absFloor(output);
      }

      function monthDiff(a, b) {
          if (a.date() < b.date()) {
              // end-of-month calculations work correct when the start month has more
              // days than the end month.
              return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2,
              adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
          if (!this.isValid()) {
              return null;
          }
          var utc = keepOffset !== true,
              m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(
                  m,
                  utc
                      ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                      : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
              );
          }
          if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                  return this.toDate().toISOString();
              } else {
                  return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                      .toISOString()
                      .replace('Z', formatMoment(m, 'Z'));
              }
          }
          return formatMoment(
              m,
              utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
          );
      }

      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */
      function inspect() {
          if (!this.isValid()) {
              return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
              zone = '',
              prefix,
              year,
              datetime,
              suffix;
          if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
              zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';

          return this.format(prefix + year + datetime + suffix);
      }

      function format(inputString) {
          if (!inputString) {
              inputString = this.isUtc()
                  ? hooks.defaultFormatUtc
                  : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ to: this, from: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
      }

      function to(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ from: this, to: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale(key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData() {
          return this._locale;
      }

      var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

      // actual modulo - handles negative numbers (for dates before 1970):
      function mod$1(dividend, divisor) {
          return ((dividend % divisor) + divisor) % divisor;
      }

      function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return new Date(y, m, d).valueOf();
          }
      }

      function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return Date.UTC(y, m, d);
          }
      }

      function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year(), 0, 1);
                  break;
              case 'quarter':
                  time = startOfDate(
                      this.year(),
                      this.month() - (this.month() % 3),
                      1
                  );
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month(), 1);
                  break;
              case 'week':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - this.weekday()
                  );
                  break;
              case 'isoWeek':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - (this.isoWeekday() - 1)
                  );
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date());
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time -= mod$1(
                      time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                      MS_PER_HOUR
                  );
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_MINUTE);
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_SECOND);
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year() + 1, 0, 1) - 1;
                  break;
              case 'quarter':
                  time =
                      startOfDate(
                          this.year(),
                          this.month() - (this.month() % 3) + 3,
                          1
                      ) - 1;
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                  break;
              case 'week':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - this.weekday() + 7
                      ) - 1;
                  break;
              case 'isoWeek':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - (this.isoWeekday() - 1) + 7
                      ) - 1;
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time +=
                      MS_PER_HOUR -
                      mod$1(
                          time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                          MS_PER_HOUR
                      ) -
                      1;
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
      }

      function unix() {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate() {
          return new Date(this.valueOf());
      }

      function toArray() {
          var m = this;
          return [
              m.year(),
              m.month(),
              m.date(),
              m.hour(),
              m.minute(),
              m.second(),
              m.millisecond(),
          ];
      }

      function toObject() {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds(),
          };
      }

      function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2() {
          return isValid(this);
      }

      function parsingFlags() {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt() {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict,
          };
      }

      addFormatToken('N', 0, 0, 'eraAbbr');
      addFormatToken('NN', 0, 0, 'eraAbbr');
      addFormatToken('NNN', 0, 0, 'eraAbbr');
      addFormatToken('NNNN', 0, 0, 'eraName');
      addFormatToken('NNNNN', 0, 0, 'eraNarrow');

      addFormatToken('y', ['y', 1], 'yo', 'eraYear');
      addFormatToken('y', ['yy', 2], 0, 'eraYear');
      addFormatToken('y', ['yyy', 3], 0, 'eraYear');
      addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

      addRegexToken('N', matchEraAbbr);
      addRegexToken('NN', matchEraAbbr);
      addRegexToken('NNN', matchEraAbbr);
      addRegexToken('NNNN', matchEraName);
      addRegexToken('NNNNN', matchEraNarrow);

      addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
          input,
          array,
          config,
          token
      ) {
          var era = config._locale.erasParse(input, token, config._strict);
          if (era) {
              getParsingFlags(config).era = era;
          } else {
              getParsingFlags(config).invalidEra = input;
          }
      });

      addRegexToken('y', matchUnsigned);
      addRegexToken('yy', matchUnsigned);
      addRegexToken('yyy', matchUnsigned);
      addRegexToken('yyyy', matchUnsigned);
      addRegexToken('yo', matchEraYearOrdinal);

      addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
      addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
              match = input.match(config._locale._eraYearOrdinalRegex);
          }

          if (config._locale.eraYearOrdinalParse) {
              array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
              array[YEAR] = parseInt(input, 10);
          }
      });

      function localeEras(m, format) {
          var i,
              l,
              date,
              eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
              switch (typeof eras[i].since) {
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].since).startOf('day');
                      eras[i].since = date.valueOf();
                      break;
              }

              switch (typeof eras[i].until) {
                  case 'undefined':
                      eras[i].until = +Infinity;
                      break;
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].until).startOf('day').valueOf();
                      eras[i].until = date.valueOf();
                      break;
              }
          }
          return eras;
      }

      function localeErasParse(eraName, format, strict) {
          var i,
              l,
              eras = this.eras(),
              name,
              abbr,
              narrow;
          eraName = eraName.toUpperCase();

          for (i = 0, l = eras.length; i < l; ++i) {
              name = eras[i].name.toUpperCase();
              abbr = eras[i].abbr.toUpperCase();
              narrow = eras[i].narrow.toUpperCase();

              if (strict) {
                  switch (format) {
                      case 'N':
                      case 'NN':
                      case 'NNN':
                          if (abbr === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNN':
                          if (name === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNNN':
                          if (narrow === eraName) {
                              return eras[i];
                          }
                          break;
                  }
              } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                  return eras[i];
              }
          }
      }

      function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
              return hooks(era.since).year();
          } else {
              return hooks(era.since).year() + (year - era.offset) * dir;
          }
      }

      function getEraName() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].name;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].name;
              }
          }

          return '';
      }

      function getEraNarrow() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].narrow;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].narrow;
              }
          }

          return '';
      }

      function getEraAbbr() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].abbr;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].abbr;
              }
          }

          return '';
      }

      function getEraYear() {
          var i,
              l,
              dir,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              dir = eras[i].since <= eras[i].until ? +1 : -1;

              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (
                  (eras[i].since <= val && val <= eras[i].until) ||
                  (eras[i].until <= val && val <= eras[i].since)
              ) {
                  return (
                      (this.year() - hooks(eras[i].since).year()) * dir +
                      eras[i].offset
                  );
              }
          }

          return this.year();
      }

      function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
      }

      function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }

      function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }

      function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
      }

      function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
      }

      function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
      }

      function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
      }

      function computeErasParse() {
          var abbrPieces = [],
              namePieces = [],
              narrowPieces = [],
              mixedPieces = [],
              i,
              l,
              eras = this.eras();

          for (i = 0, l = eras.length; i < l; ++i) {
              namePieces.push(regexEscape(eras[i].name));
              abbrPieces.push(regexEscape(eras[i].abbr));
              narrowPieces.push(regexEscape(eras[i].narrow));

              mixedPieces.push(regexEscape(eras[i].name));
              mixedPieces.push(regexEscape(eras[i].abbr));
              mixedPieces.push(regexEscape(eras[i].narrow));
          }

          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp(
              '^(' + narrowPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);

      // PARSING

      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
          input,
          week,
          config,
          token
      ) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.week(),
              this.weekday(),
              this.localeData()._week.dow,
              this.localeData()._week.doy
          );
      }

      function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.isoWeek(),
              this.isoWeekday(),
              1,
              4
          );
      }

      function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
      }

      function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
      }

      function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter(input) {
          return input == null
              ? Math.ceil((this.month() + 1) / 3)
              : this.month((input - 1) * 3 + (this.month() % 3));
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIORITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict
              ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
              : locale._dayOfMonthOrdinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear(input) {
          var dayOfYear =
              Math.round(
                  (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
              ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });

      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);

      var token, getSetMillisecond;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }

      getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;

      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
              return 'Moment<' + this.format() + '>';
          };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
          'dates accessor is deprecated. Use date instead.',
          getSetDayOfMonth
      );
      proto.months = deprecate(
          'months accessor is deprecated. Use month instead',
          getSetMonth
      );
      proto.years = deprecate(
          'years accessor is deprecated. Use year instead',
          getSetYear
      );
      proto.zone = deprecate(
          'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
          getSetZone
      );
      proto.isDSTShifted = deprecate(
          'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
          isDaylightSavingTimeShifted
      );

      function createUnix(input) {
          return createLocal(input * 1000);
      }

      function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat(string) {
          return string;
      }

      var proto$1 = Locale.prototype;

      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;

      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;

      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;

      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;

      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1(format, index, field, setter) {
          var locale = getLocale(),
              utc = createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return get$1(format, index, field, 'month');
          }

          var i,
              out = [];
          for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0,
              i,
              out = [];

          if (index != null) {
              return get$1(format, (index + shift) % 7, field, 'day');
          }

          for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
          eras: [
              {
                  since: '0001-01-01',
                  until: +Infinity,
                  offset: 1,
                  name: 'Anno Domini',
                  narrow: 'AD',
                  abbr: 'AD',
              },
              {
                  since: '0000-12-31',
                  until: -Infinity,
                  offset: 1,
                  name: 'Before Christ',
                  narrow: 'BC',
                  abbr: 'BC',
              },
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      toInt((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
      });

      // Side effect imports

      hooks.lang = deprecate(
          'moment.lang is deprecated. Use moment.locale instead.',
          getSetGlobalLocale
      );
      hooks.langData = deprecate(
          'moment.langData is deprecated. Use moment.localeData instead.',
          getLocale
      );

      var mathAbs = Math.abs;

      function abs() {
          var data = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);

          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);

          return this;
      }

      function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
      }

      function absCeil(number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble() {
          var milliseconds = this._milliseconds,
              days = this._days,
              months = this._months,
              data = this._data,
              seconds,
              minutes,
              hours,
              years,
              monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (
              !(
                  (milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0)
              )
          ) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;

          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;

          hours = absFloor(minutes / 60);
          data.hours = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days = days;
          data.months = months;
          data.years = years;

          return this;
      }

      function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return (days * 4800) / 146097;
      }

      function monthsToDays(months) {
          // the reverse of daysToMonths
          return (months * 146097) / 4800;
      }

      function as(units) {
          if (!this.isValid()) {
              return NaN;
          }
          var days,
              months,
              milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'quarter' || units === 'year') {
              days = this._days + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              switch (units) {
                  case 'month':
                      return months;
                  case 'quarter':
                      return months / 3;
                  case 'year':
                      return months / 12;
              }
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week':
                      return days / 7 + milliseconds / 6048e5;
                  case 'day':
                      return days + milliseconds / 864e5;
                  case 'hour':
                      return days * 24 + milliseconds / 36e5;
                  case 'minute':
                      return days * 1440 + milliseconds / 6e4;
                  case 'second':
                      return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond':
                      return Math.floor(days * 864e5) + milliseconds;
                  default:
                      throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function valueOf$1() {
          if (!this.isValid()) {
              return NaN;
          }
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs(alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y');

      function clone$1() {
          return createDuration(this);
      }

      function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
          return function () {
              return this.isValid() ? this._data[name] : NaN;
          };
      }

      var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');

      function weeks() {
          return absFloor(this.days() / 7);
      }

      var round = Math.round,
          thresholds = {
              ss: 44, // a few seconds to seconds
              s: 45, // seconds to minute
              m: 45, // minutes to hour
              h: 22, // hours to day
              d: 26, // days to month/week
              w: null, // weeks to month
              M: 11, // months to year
          };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
              seconds = round(duration.as('s')),
              minutes = round(duration.as('m')),
              hours = round(duration.as('h')),
              days = round(duration.as('d')),
              months = round(duration.as('M')),
              weeks = round(duration.as('w')),
              years = round(duration.as('y')),
              a =
                  (seconds <= thresholds.ss && ['s', seconds]) ||
                  (seconds < thresholds.s && ['ss', seconds]) ||
                  (minutes <= 1 && ['m']) ||
                  (minutes < thresholds.m && ['mm', minutes]) ||
                  (hours <= 1 && ['h']) ||
                  (hours < thresholds.h && ['hh', hours]) ||
                  (days <= 1 && ['d']) ||
                  (days < thresholds.d && ['dd', days]);

          if (thresholds.w != null) {
              a =
                  a ||
                  (weeks <= 1 && ['w']) ||
                  (weeks < thresholds.w && ['ww', weeks]);
          }
          a = a ||
              (months <= 1 && ['M']) ||
              (months < thresholds.M && ['MM', months]) ||
              (years <= 1 && ['y']) || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
              return round;
          }
          if (typeof roundingFunction === 'function') {
              round = roundingFunction;
              return true;
          }
          return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
              thresholds.ss = limit - 1;
          }
          return true;
      }

      function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var withSuffix = false,
              th = thresholds,
              locale,
              output;

          if (typeof argWithSuffix === 'object') {
              argThresholds = argWithSuffix;
              argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
              withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === 'object') {
              th = Object.assign({}, thresholds, argThresholds);
              if (argThresholds.s != null && argThresholds.ss == null) {
                  th.ss = argThresholds.s - 1;
              }
          }

          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
          return (x > 0) - (x < 0) || +x;
      }

      function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000,
              days = abs$1(this._days),
              months = abs$1(this._months),
              minutes,
              hours,
              years,
              s,
              total = this.asSeconds(),
              totalSign,
              ymSign,
              daysSign,
              hmsSign;

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

          return (
              totalSign +
              'P' +
              (years ? ymSign + years + 'Y' : '') +
              (months ? ymSign + months + 'M' : '') +
              (days ? daysSign + days + 'D' : '') +
              (hours || minutes || seconds ? 'T' : '') +
              (hours ? hmsSign + hours + 'H' : '') +
              (minutes ? hmsSign + minutes + 'M' : '') +
              (seconds ? hmsSign + s + 'S' : '')
          );
      }

      var proto$2 = Duration.prototype;

      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;

      proto$2.toIsoString = deprecate(
          'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
          toISOString$1
      );
      proto$2.lang = lang;

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      //! moment.js

      hooks.version = '2.29.1';

      setHookCallback(createLocal);

      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD', // <input type="date" />
          TIME: 'HH:mm', // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW', // <input type="week" />
          MONTH: 'YYYY-MM', // <input type="month" />
      };

      //! moment.js locale configuration

      hooks.defineLocale('af', {
          months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
          weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split(
              '_'
          ),
          weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
          weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
          meridiemParse: /vm|nm/i,
          isPM: function (input) {
              return /^nm$/i.test(input);
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours < 12) {
                  return isLower ? 'vm' : 'VM';
              } else {
                  return isLower ? 'nm' : 'NM';
              }
          },
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Vandag om] LT',
              nextDay: '[MÃ´re om] LT',
              nextWeek: 'dddd [om] LT',
              lastDay: '[Gister om] LT',
              lastWeek: '[Laas] dddd [om] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'oor %s',
              past: '%s gelede',
              s: "'n paar sekondes",
              ss: '%d sekondes',
              m: "'n minuut",
              mm: '%d minute',
              h: "'n uur",
              hh: '%d ure',
              d: "'n dag",
              dd: '%d dae',
              M: "'n maand",
              MM: '%d maande',
              y: "'n jaar",
              yy: '%d jaar',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
          ordinal: function (number) {
              return (
                  number +
                  (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
              ); // Thanks to Joris RÃ¶ling : https://github.com/jjupiter
          },
          week: {
              dow: 1, // Maandag is die eerste dag van die week.
              doy: 4, // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
          },
      });

      //! moment.js locale configuration

      var pluralForm = function (n) {
              return n === 0
                  ? 0
                  : n === 1
                  ? 1
                  : n === 2
                  ? 2
                  : n % 100 >= 3 && n % 100 <= 10
                  ? 3
                  : n % 100 >= 11
                  ? 4
                  : 5;
          },
          plurals = {
              s: [
                  'Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ©',
                  'Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©',
                  ['Ø«Ø§ÙÙØªØ§Ù', 'Ø«Ø§ÙÙØªÙÙ'],
                  '%d Ø«ÙØ§Ù',
                  '%d Ø«Ø§ÙÙØ©',
                  '%d Ø«Ø§ÙÙØ©',
              ],
              m: [
                  'Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©',
                  'Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©',
                  ['Ø¯ÙÙÙØªØ§Ù', 'Ø¯ÙÙÙØªÙÙ'],
                  '%d Ø¯ÙØ§Ø¦Ù',
                  '%d Ø¯ÙÙÙØ©',
                  '%d Ø¯ÙÙÙØ©',
              ],
              h: [
                  'Ø£ÙÙ ÙÙ Ø³Ø§Ø¹Ø©',
                  'Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©',
                  ['Ø³Ø§Ø¹ØªØ§Ù', 'Ø³Ø§Ø¹ØªÙÙ'],
                  '%d Ø³Ø§Ø¹Ø§Øª',
                  '%d Ø³Ø§Ø¹Ø©',
                  '%d Ø³Ø§Ø¹Ø©',
              ],
              d: [
                  'Ø£ÙÙ ÙÙ ÙÙÙ',
                  'ÙÙÙ ÙØ§Ø­Ø¯',
                  ['ÙÙÙØ§Ù', 'ÙÙÙÙÙ'],
                  '%d Ø£ÙØ§Ù',
                  '%d ÙÙÙÙØ§',
                  '%d ÙÙÙ',
              ],
              M: [
                  'Ø£ÙÙ ÙÙ Ø´ÙØ±',
                  'Ø´ÙØ± ÙØ§Ø­Ø¯',
                  ['Ø´ÙØ±Ø§Ù', 'Ø´ÙØ±ÙÙ'],
                  '%d Ø£Ø´ÙØ±',
                  '%d Ø´ÙØ±Ø§',
                  '%d Ø´ÙØ±',
              ],
              y: [
                  'Ø£ÙÙ ÙÙ Ø¹Ø§Ù',
                  'Ø¹Ø§Ù ÙØ§Ø­Ø¯',
                  ['Ø¹Ø§ÙØ§Ù', 'Ø¹Ø§ÙÙÙ'],
                  '%d Ø£Ø¹ÙØ§Ù',
                  '%d Ø¹Ø§ÙÙØ§',
                  '%d Ø¹Ø§Ù',
              ],
          },
          pluralize = function (u) {
              return function (number, withoutSuffix, string, isFuture) {
                  var f = pluralForm(number),
                      str = plurals[u][pluralForm(number)];
                  if (f === 2) {
                      str = str[withoutSuffix ? 0 : 1];
                  }
                  return str.replace(/%d/i, number);
              };
          },
          months$1 = [
              'Ø¬Ø§ÙÙÙ',
              'ÙÙÙØ±Ù',
              'ÙØ§Ø±Ø³',
              'Ø£ÙØ±ÙÙ',
              'ÙØ§Ù',
              'Ø¬ÙØ§Ù',
              'Ø¬ÙÙÙÙØ©',
              'Ø£ÙØª',
              'Ø³Ø¨ØªÙØ¨Ø±',
              'Ø£ÙØªÙØ¨Ø±',
              'ÙÙÙÙØ¨Ø±',
              'Ø¯ÙØ³ÙØ¨Ø±',
          ];

      hooks.defineLocale('ar-dz', {
          months: months$1,
          monthsShort: months$1,
          weekdays: 'Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª'.split('_'),
          weekdaysShort: 'Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª'.split('_'),
          weekdaysMin: 'Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'D/\u200FM/\u200FYYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          meridiemParse: /Øµ|Ù/,
          isPM: function (input) {
              return 'Ù' === input;
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'Øµ';
              } else {
                  return 'Ù';
              }
          },
          calendar: {
              sameDay: '[Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextDay: '[ØºØ¯ÙØ§ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextWeek: 'dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastDay: '[Ø£ÙØ³ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastWeek: 'dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ø¨Ø¹Ø¯ %s',
              past: 'ÙÙØ° %s',
              s: pluralize('s'),
              ss: pluralize('s'),
              m: pluralize('m'),
              mm: pluralize('m'),
              h: pluralize('h'),
              hh: pluralize('h'),
              d: pluralize('d'),
              dd: pluralize('d'),
              M: pluralize('M'),
              MM: pluralize('M'),
              y: pluralize('y'),
              yy: pluralize('y'),
          },
          postformat: function (string) {
              return string.replace(/,/g, 'Ø');
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ar-kw', {
          months: 'ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§Ù_ÙÙÙÙÙ_ÙÙÙÙÙØ²_ØºØ´Øª_Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø±'.split(
              '_'
          ),
          monthsShort: 'ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§Ù_ÙÙÙÙÙ_ÙÙÙÙÙØ²_ØºØ´Øª_Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø±'.split(
              '_'
          ),
          weekdays: 'Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥ØªÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª'.split('_'),
          weekdaysShort: 'Ø§Ø­Ø¯_Ø§ØªÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø§Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª'.split('_'),
          weekdaysMin: 'Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextDay: '[ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastDay: '[Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÙÙ %s',
              past: 'ÙÙØ° %s',
              s: 'Ø«ÙØ§Ù',
              ss: '%d Ø«Ø§ÙÙØ©',
              m: 'Ø¯ÙÙÙØ©',
              mm: '%d Ø¯ÙØ§Ø¦Ù',
              h: 'Ø³Ø§Ø¹Ø©',
              hh: '%d Ø³Ø§Ø¹Ø§Øª',
              d: 'ÙÙÙ',
              dd: '%d Ø£ÙØ§Ù',
              M: 'Ø´ÙØ±',
              MM: '%d Ø£Ø´ÙØ±',
              y: 'Ø³ÙØ©',
              yy: '%d Ø³ÙÙØ§Øª',
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap = {
              1: '1',
              2: '2',
              3: '3',
              4: '4',
              5: '5',
              6: '6',
              7: '7',
              8: '8',
              9: '9',
              0: '0',
          },
          pluralForm$1 = function (n) {
              return n === 0
                  ? 0
                  : n === 1
                  ? 1
                  : n === 2
                  ? 2
                  : n % 100 >= 3 && n % 100 <= 10
                  ? 3
                  : n % 100 >= 11
                  ? 4
                  : 5;
          },
          plurals$1 = {
              s: [
                  'Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ©',
                  'Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©',
                  ['Ø«Ø§ÙÙØªØ§Ù', 'Ø«Ø§ÙÙØªÙÙ'],
                  '%d Ø«ÙØ§Ù',
                  '%d Ø«Ø§ÙÙØ©',
                  '%d Ø«Ø§ÙÙØ©',
              ],
              m: [
                  'Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©',
                  'Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©',
                  ['Ø¯ÙÙÙØªØ§Ù', 'Ø¯ÙÙÙØªÙÙ'],
                  '%d Ø¯ÙØ§Ø¦Ù',
                  '%d Ø¯ÙÙÙØ©',
                  '%d Ø¯ÙÙÙØ©',
              ],
              h: [
                  'Ø£ÙÙ ÙÙ Ø³Ø§Ø¹Ø©',
                  'Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©',
                  ['Ø³Ø§Ø¹ØªØ§Ù', 'Ø³Ø§Ø¹ØªÙÙ'],
                  '%d Ø³Ø§Ø¹Ø§Øª',
                  '%d Ø³Ø§Ø¹Ø©',
                  '%d Ø³Ø§Ø¹Ø©',
              ],
              d: [
                  'Ø£ÙÙ ÙÙ ÙÙÙ',
                  'ÙÙÙ ÙØ§Ø­Ø¯',
                  ['ÙÙÙØ§Ù', 'ÙÙÙÙÙ'],
                  '%d Ø£ÙØ§Ù',
                  '%d ÙÙÙÙØ§',
                  '%d ÙÙÙ',
              ],
              M: [
                  'Ø£ÙÙ ÙÙ Ø´ÙØ±',
                  'Ø´ÙØ± ÙØ§Ø­Ø¯',
                  ['Ø´ÙØ±Ø§Ù', 'Ø´ÙØ±ÙÙ'],
                  '%d Ø£Ø´ÙØ±',
                  '%d Ø´ÙØ±Ø§',
                  '%d Ø´ÙØ±',
              ],
              y: [
                  'Ø£ÙÙ ÙÙ Ø¹Ø§Ù',
                  'Ø¹Ø§Ù ÙØ§Ø­Ø¯',
                  ['Ø¹Ø§ÙØ§Ù', 'Ø¹Ø§ÙÙÙ'],
                  '%d Ø£Ø¹ÙØ§Ù',
                  '%d Ø¹Ø§ÙÙØ§',
                  '%d Ø¹Ø§Ù',
              ],
          },
          pluralize$1 = function (u) {
              return function (number, withoutSuffix, string, isFuture) {
                  var f = pluralForm$1(number),
                      str = plurals$1[u][pluralForm$1(number)];
                  if (f === 2) {
                      str = str[withoutSuffix ? 0 : 1];
                  }
                  return str.replace(/%d/i, number);
              };
          },
          months$2 = [
              'ÙÙØ§ÙØ±',
              'ÙØ¨Ø±Ø§ÙØ±',
              'ÙØ§Ø±Ø³',
              'Ø£Ø¨Ø±ÙÙ',
              'ÙØ§ÙÙ',
              'ÙÙÙÙÙ',
              'ÙÙÙÙÙ',
              'Ø£ØºØ³Ø·Ø³',
              'Ø³Ø¨ØªÙØ¨Ø±',
              'Ø£ÙØªÙØ¨Ø±',
              'ÙÙÙÙØ¨Ø±',
              'Ø¯ÙØ³ÙØ¨Ø±',
          ];

      hooks.defineLocale('ar-ly', {
          months: months$2,
          monthsShort: months$2,
          weekdays: 'Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª'.split('_'),
          weekdaysShort: 'Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª'.split('_'),
          weekdaysMin: 'Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'D/\u200FM/\u200FYYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          meridiemParse: /Øµ|Ù/,
          isPM: function (input) {
              return 'Ù' === input;
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'Øµ';
              } else {
                  return 'Ù';
              }
          },
          calendar: {
              sameDay: '[Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextDay: '[ØºØ¯ÙØ§ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextWeek: 'dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastDay: '[Ø£ÙØ³ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastWeek: 'dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ø¨Ø¹Ø¯ %s',
              past: 'ÙÙØ° %s',
              s: pluralize$1('s'),
              ss: pluralize$1('s'),
              m: pluralize$1('m'),
              mm: pluralize$1('m'),
              h: pluralize$1('h'),
              hh: pluralize$1('h'),
              d: pluralize$1('d'),
              dd: pluralize$1('d'),
              M: pluralize$1('M'),
              MM: pluralize$1('M'),
              y: pluralize$1('y'),
              yy: pluralize$1('y'),
          },
          preparse: function (string) {
              return string.replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string
                  .replace(/\d/g, function (match) {
                      return symbolMap[match];
                  })
                  .replace(/,/g, 'Ø');
          },
          week: {
              dow: 6, // Saturday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ar-ma', {
          months: 'ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§Ù_ÙÙÙÙÙ_ÙÙÙÙÙØ²_ØºØ´Øª_Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø±'.split(
              '_'
          ),
          monthsShort: 'ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§Ù_ÙÙÙÙÙ_ÙÙÙÙÙØ²_ØºØ´Øª_Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø±'.split(
              '_'
          ),
          weekdays: 'Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª'.split('_'),
          weekdaysShort: 'Ø§Ø­Ø¯_Ø§Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø§Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª'.split('_'),
          weekdaysMin: 'Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextDay: '[ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastDay: '[Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÙÙ %s',
              past: 'ÙÙØ° %s',
              s: 'Ø«ÙØ§Ù',
              ss: '%d Ø«Ø§ÙÙØ©',
              m: 'Ø¯ÙÙÙØ©',
              mm: '%d Ø¯ÙØ§Ø¦Ù',
              h: 'Ø³Ø§Ø¹Ø©',
              hh: '%d Ø³Ø§Ø¹Ø§Øª',
              d: 'ÙÙÙ',
              dd: '%d Ø£ÙØ§Ù',
              M: 'Ø´ÙØ±',
              MM: '%d Ø£Ø´ÙØ±',
              y: 'Ø³ÙØ©',
              yy: '%d Ø³ÙÙØ§Øª',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$1 = {
              1: 'Ù¡',
              2: 'Ù¢',
              3: 'Ù£',
              4: 'Ù¤',
              5: 'Ù¥',
              6: 'Ù¦',
              7: 'Ù§',
              8: 'Ù¨',
              9: 'Ù©',
              0: 'Ù ',
          },
          numberMap = {
              'Ù¡': '1',
              'Ù¢': '2',
              'Ù£': '3',
              'Ù¤': '4',
              'Ù¥': '5',
              'Ù¦': '6',
              'Ù§': '7',
              'Ù¨': '8',
              'Ù©': '9',
              'Ù ': '0',
          };

      hooks.defineLocale('ar-sa', {
          months: 'ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§ÙÙ_ÙÙÙÙÙ_ÙÙÙÙÙ_Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±'.split(
              '_'
          ),
          monthsShort: 'ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§ÙÙ_ÙÙÙÙÙ_ÙÙÙÙÙ_Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±'.split(
              '_'
          ),
          weekdays: 'Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª'.split('_'),
          weekdaysShort: 'Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª'.split('_'),
          weekdaysMin: 'Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          meridiemParse: /Øµ|Ù/,
          isPM: function (input) {
              return 'Ù' === input;
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'Øµ';
              } else {
                  return 'Ù';
              }
          },
          calendar: {
              sameDay: '[Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextDay: '[ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastDay: '[Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÙÙ %s',
              past: 'ÙÙØ° %s',
              s: 'Ø«ÙØ§Ù',
              ss: '%d Ø«Ø§ÙÙØ©',
              m: 'Ø¯ÙÙÙØ©',
              mm: '%d Ø¯ÙØ§Ø¦Ù',
              h: 'Ø³Ø§Ø¹Ø©',
              hh: '%d Ø³Ø§Ø¹Ø§Øª',
              d: 'ÙÙÙ',
              dd: '%d Ø£ÙØ§Ù',
              M: 'Ø´ÙØ±',
              MM: '%d Ø£Ø´ÙØ±',
              y: 'Ø³ÙØ©',
              yy: '%d Ø³ÙÙØ§Øª',
          },
          preparse: function (string) {
              return string
                  .replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function (match) {
                      return numberMap[match];
                  })
                  .replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string
                  .replace(/\d/g, function (match) {
                      return symbolMap$1[match];
                  })
                  .replace(/,/g, 'Ø');
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ar-tn', {
          months: 'Ø¬Ø§ÙÙÙ_ÙÙÙØ±Ù_ÙØ§Ø±Ø³_Ø£ÙØ±ÙÙ_ÙØ§Ù_Ø¬ÙØ§Ù_Ø¬ÙÙÙÙØ©_Ø£ÙØª_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±'.split(
              '_'
          ),
          monthsShort: 'Ø¬Ø§ÙÙÙ_ÙÙÙØ±Ù_ÙØ§Ø±Ø³_Ø£ÙØ±ÙÙ_ÙØ§Ù_Ø¬ÙØ§Ù_Ø¬ÙÙÙÙØ©_Ø£ÙØª_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±'.split(
              '_'
          ),
          weekdays: 'Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª'.split('_'),
          weekdaysShort: 'Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª'.split('_'),
          weekdaysMin: 'Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextDay: '[ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastDay: '[Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastWeek: 'dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÙÙ %s',
              past: 'ÙÙØ° %s',
              s: 'Ø«ÙØ§Ù',
              ss: '%d Ø«Ø§ÙÙØ©',
              m: 'Ø¯ÙÙÙØ©',
              mm: '%d Ø¯ÙØ§Ø¦Ù',
              h: 'Ø³Ø§Ø¹Ø©',
              hh: '%d Ø³Ø§Ø¹Ø§Øª',
              d: 'ÙÙÙ',
              dd: '%d Ø£ÙØ§Ù',
              M: 'Ø´ÙØ±',
              MM: '%d Ø£Ø´ÙØ±',
              y: 'Ø³ÙØ©',
              yy: '%d Ø³ÙÙØ§Øª',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$2 = {
              1: 'Ù¡',
              2: 'Ù¢',
              3: 'Ù£',
              4: 'Ù¤',
              5: 'Ù¥',
              6: 'Ù¦',
              7: 'Ù§',
              8: 'Ù¨',
              9: 'Ù©',
              0: 'Ù ',
          },
          numberMap$1 = {
              'Ù¡': '1',
              'Ù¢': '2',
              'Ù£': '3',
              'Ù¤': '4',
              'Ù¥': '5',
              'Ù¦': '6',
              'Ù§': '7',
              'Ù¨': '8',
              'Ù©': '9',
              'Ù ': '0',
          },
          pluralForm$2 = function (n) {
              return n === 0
                  ? 0
                  : n === 1
                  ? 1
                  : n === 2
                  ? 2
                  : n % 100 >= 3 && n % 100 <= 10
                  ? 3
                  : n % 100 >= 11
                  ? 4
                  : 5;
          },
          plurals$2 = {
              s: [
                  'Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ©',
                  'Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©',
                  ['Ø«Ø§ÙÙØªØ§Ù', 'Ø«Ø§ÙÙØªÙÙ'],
                  '%d Ø«ÙØ§Ù',
                  '%d Ø«Ø§ÙÙØ©',
                  '%d Ø«Ø§ÙÙØ©',
              ],
              m: [
                  'Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©',
                  'Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©',
                  ['Ø¯ÙÙÙØªØ§Ù', 'Ø¯ÙÙÙØªÙÙ'],
                  '%d Ø¯ÙØ§Ø¦Ù',
                  '%d Ø¯ÙÙÙØ©',
                  '%d Ø¯ÙÙÙØ©',
              ],
              h: [
                  'Ø£ÙÙ ÙÙ Ø³Ø§Ø¹Ø©',
                  'Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©',
                  ['Ø³Ø§Ø¹ØªØ§Ù', 'Ø³Ø§Ø¹ØªÙÙ'],
                  '%d Ø³Ø§Ø¹Ø§Øª',
                  '%d Ø³Ø§Ø¹Ø©',
                  '%d Ø³Ø§Ø¹Ø©',
              ],
              d: [
                  'Ø£ÙÙ ÙÙ ÙÙÙ',
                  'ÙÙÙ ÙØ§Ø­Ø¯',
                  ['ÙÙÙØ§Ù', 'ÙÙÙÙÙ'],
                  '%d Ø£ÙØ§Ù',
                  '%d ÙÙÙÙØ§',
                  '%d ÙÙÙ',
              ],
              M: [
                  'Ø£ÙÙ ÙÙ Ø´ÙØ±',
                  'Ø´ÙØ± ÙØ§Ø­Ø¯',
                  ['Ø´ÙØ±Ø§Ù', 'Ø´ÙØ±ÙÙ'],
                  '%d Ø£Ø´ÙØ±',
                  '%d Ø´ÙØ±Ø§',
                  '%d Ø´ÙØ±',
              ],
              y: [
                  'Ø£ÙÙ ÙÙ Ø¹Ø§Ù',
                  'Ø¹Ø§Ù ÙØ§Ø­Ø¯',
                  ['Ø¹Ø§ÙØ§Ù', 'Ø¹Ø§ÙÙÙ'],
                  '%d Ø£Ø¹ÙØ§Ù',
                  '%d Ø¹Ø§ÙÙØ§',
                  '%d Ø¹Ø§Ù',
              ],
          },
          pluralize$2 = function (u) {
              return function (number, withoutSuffix, string, isFuture) {
                  var f = pluralForm$2(number),
                      str = plurals$2[u][pluralForm$2(number)];
                  if (f === 2) {
                      str = str[withoutSuffix ? 0 : 1];
                  }
                  return str.replace(/%d/i, number);
              };
          },
          months$3 = [
              'ÙÙØ§ÙØ±',
              'ÙØ¨Ø±Ø§ÙØ±',
              'ÙØ§Ø±Ø³',
              'Ø£Ø¨Ø±ÙÙ',
              'ÙØ§ÙÙ',
              'ÙÙÙÙÙ',
              'ÙÙÙÙÙ',
              'Ø£ØºØ³Ø·Ø³',
              'Ø³Ø¨ØªÙØ¨Ø±',
              'Ø£ÙØªÙØ¨Ø±',
              'ÙÙÙÙØ¨Ø±',
              'Ø¯ÙØ³ÙØ¨Ø±',
          ];

      hooks.defineLocale('ar', {
          months: months$3,
          monthsShort: months$3,
          weekdays: 'Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª'.split('_'),
          weekdaysShort: 'Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª'.split('_'),
          weekdaysMin: 'Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'D/\u200FM/\u200FYYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          meridiemParse: /Øµ|Ù/,
          isPM: function (input) {
              return 'Ù' === input;
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'Øµ';
              } else {
                  return 'Ù';
              }
          },
          calendar: {
              sameDay: '[Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextDay: '[ØºØ¯ÙØ§ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              nextWeek: 'dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastDay: '[Ø£ÙØ³ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              lastWeek: 'dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ø¨Ø¹Ø¯ %s',
              past: 'ÙÙØ° %s',
              s: pluralize$2('s'),
              ss: pluralize$2('s'),
              m: pluralize$2('m'),
              mm: pluralize$2('m'),
              h: pluralize$2('h'),
              hh: pluralize$2('h'),
              d: pluralize$2('d'),
              dd: pluralize$2('d'),
              M: pluralize$2('M'),
              MM: pluralize$2('M'),
              y: pluralize$2('y'),
              yy: pluralize$2('y'),
          },
          preparse: function (string) {
              return string
                  .replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function (match) {
                      return numberMap$1[match];
                  })
                  .replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string
                  .replace(/\d/g, function (match) {
                      return symbolMap$2[match];
                  })
                  .replace(/,/g, 'Ø');
          },
          week: {
              dow: 6, // Saturday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var suffixes = {
          1: '-inci',
          5: '-inci',
          8: '-inci',
          70: '-inci',
          80: '-inci',
          2: '-nci',
          7: '-nci',
          20: '-nci',
          50: '-nci',
          3: '-Ã¼ncÃ¼',
          4: '-Ã¼ncÃ¼',
          100: '-Ã¼ncÃ¼',
          6: '-ncÄ±',
          9: '-uncu',
          10: '-uncu',
          30: '-uncu',
          60: '-Ä±ncÄ±',
          90: '-Ä±ncÄ±',
      };

      hooks.defineLocale('az', {
          months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split(
              '_'
          ),
          monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
          weekdays: 'Bazar_Bazar ertÉsi_ÃÉrÅÉnbÉ axÅamÄ±_ÃÉrÅÉnbÉ_CÃ¼mÉ axÅamÄ±_CÃ¼mÉ_ÅÉnbÉ'.split(
              '_'
          ),
          weekdaysShort: 'Baz_BzE_ÃAx_ÃÉr_CAx_CÃ¼m_ÅÉn'.split('_'),
          weekdaysMin: 'Bz_BE_ÃA_ÃÉ_CA_CÃ¼_ÅÉ'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[bugÃ¼n saat] LT',
              nextDay: '[sabah saat] LT',
              nextWeek: '[gÉlÉn hÉftÉ] dddd [saat] LT',
              lastDay: '[dÃ¼nÉn] LT',
              lastWeek: '[keÃ§Én hÉftÉ] dddd [saat] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s sonra',
              past: '%s ÉvvÉl',
              s: 'bir neÃ§É saniyÉ',
              ss: '%d saniyÉ',
              m: 'bir dÉqiqÉ',
              mm: '%d dÉqiqÉ',
              h: 'bir saat',
              hh: '%d saat',
              d: 'bir gÃ¼n',
              dd: '%d gÃ¼n',
              M: 'bir ay',
              MM: '%d ay',
              y: 'bir il',
              yy: '%d il',
          },
          meridiemParse: /gecÉ|sÉhÉr|gÃ¼ndÃ¼z|axÅam/,
          isPM: function (input) {
              return /^(gÃ¼ndÃ¼z|axÅam)$/.test(input);
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'gecÉ';
              } else if (hour < 12) {
                  return 'sÉhÉr';
              } else if (hour < 17) {
                  return 'gÃ¼ndÃ¼z';
              } else {
                  return 'axÅam';
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(Ä±ncÄ±|inci|nci|Ã¼ncÃ¼|ncÄ±|uncu)/,
          ordinal: function (number) {
              if (number === 0) {
                  // special case for zero
                  return number + '-Ä±ncÄ±';
              }
              var a = number % 10,
                  b = (number % 100) - a,
                  c = number >= 100 ? 100 : null;
              return number + (suffixes[a] || suffixes[b] || suffixes[c]);
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function plural(word, num) {
          var forms = word.split('_');
          return num % 10 === 1 && num % 100 !== 11
              ? forms[0]
              : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
              ? forms[1]
              : forms[2];
      }
      function relativeTimeWithPlural(number, withoutSuffix, key) {
          var format = {
              ss: withoutSuffix ? 'ÑÐµÐºÑÐ½Ð´Ð°_ÑÐµÐºÑÐ½Ð´Ñ_ÑÐµÐºÑÐ½Ð´' : 'ÑÐµÐºÑÐ½Ð´Ñ_ÑÐµÐºÑÐ½Ð´Ñ_ÑÐµÐºÑÐ½Ð´',
              mm: withoutSuffix ? 'ÑÐ²ÑÐ»ÑÐ½Ð°_ÑÐ²ÑÐ»ÑÐ½Ñ_ÑÐ²ÑÐ»ÑÐ½' : 'ÑÐ²ÑÐ»ÑÐ½Ñ_ÑÐ²ÑÐ»ÑÐ½Ñ_ÑÐ²ÑÐ»ÑÐ½',
              hh: withoutSuffix ? 'Ð³Ð°Ð´Ð·ÑÐ½Ð°_Ð³Ð°Ð´Ð·ÑÐ½Ñ_Ð³Ð°Ð´Ð·ÑÐ½' : 'Ð³Ð°Ð´Ð·ÑÐ½Ñ_Ð³Ð°Ð´Ð·ÑÐ½Ñ_Ð³Ð°Ð´Ð·ÑÐ½',
              dd: 'Ð´Ð·ÐµÐ½Ñ_Ð´Ð½Ñ_Ð´Ð·ÑÐ½',
              MM: 'Ð¼ÐµÑÑÑ_Ð¼ÐµÑÑÑÑ_Ð¼ÐµÑÑÑÐ°Ñ',
              yy: 'Ð³Ð¾Ð´_Ð³Ð°Ð´Ñ_Ð³Ð°Ð´Ð¾Ñ',
          };
          if (key === 'm') {
              return withoutSuffix ? 'ÑÐ²ÑÐ»ÑÐ½Ð°' : 'ÑÐ²ÑÐ»ÑÐ½Ñ';
          } else if (key === 'h') {
              return withoutSuffix ? 'Ð³Ð°Ð´Ð·ÑÐ½Ð°' : 'Ð³Ð°Ð´Ð·ÑÐ½Ñ';
          } else {
              return number + ' ' + plural(format[key], +number);
          }
      }

      hooks.defineLocale('be', {
          months: {
              format: 'ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÐ°Ð³Ð°_ÑÐ°ÐºÐ°Ð²ÑÐºÐ°_ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°_ÑÑÐ°ÑÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÑÐ½Ñ_Ð²ÐµÑÐ°ÑÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°_Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°_ÑÐ½ÐµÐ¶Ð½Ñ'.split(
                  '_'
              ),
              standalone: 'ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÑ_ÑÐ°ÐºÐ°Ð²ÑÐº_ÐºÑÐ°ÑÐ°Ð²ÑÐº_ÑÑÐ°Ð²ÐµÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÐ²ÐµÐ½Ñ_Ð²ÐµÑÐ°ÑÐµÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐº_Ð»ÑÑÑÐ°Ð¿Ð°Ð´_ÑÐ½ÐµÐ¶Ð°Ð½Ñ'.split(
                  '_'
              ),
          },
          monthsShort: 'ÑÑÑÐ´_Ð»ÑÑ_ÑÐ°Ðº_ÐºÑÐ°Ñ_ÑÑÐ°Ð²_ÑÑÑÐ²_Ð»ÑÐ¿_Ð¶Ð½ÑÐ²_Ð²ÐµÑ_ÐºÐ°ÑÑ_Ð»ÑÑÑ_ÑÐ½ÐµÐ¶'.split(
              '_'
          ),
          weekdays: {
              format: 'Ð½ÑÐ´Ð·ÐµÐ»Ñ_Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº_Ð°ÑÑÐ¾ÑÐ°Ðº_ÑÐµÑÐ°Ð´Ñ_ÑÐ°ÑÐ²ÐµÑ_Ð¿ÑÑÐ½ÑÑÑ_ÑÑÐ±Ð¾ÑÑ'.split(
                  '_'
              ),
              standalone: 'Ð½ÑÐ´Ð·ÐµÐ»Ñ_Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº_Ð°ÑÑÐ¾ÑÐ°Ðº_ÑÐµÑÐ°Ð´Ð°_ÑÐ°ÑÐ²ÐµÑ_Ð¿ÑÑÐ½ÑÑÐ°_ÑÑÐ±Ð¾ÑÐ°'.split(
                  '_'
              ),
              isFormat: /\[ ?[Ð£ÑÑ] ?(?:Ð¼ÑÐ½ÑÐ»ÑÑ|Ð½Ð°ÑÑÑÐ¿Ð½ÑÑ)? ?\] ?dddd/,
          },
          weekdaysShort: 'Ð½Ð´_Ð¿Ð½_Ð°Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±'.split('_'),
          weekdaysMin: 'Ð½Ð´_Ð¿Ð½_Ð°Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY Ð³.',
              LLL: 'D MMMM YYYY Ð³., HH:mm',
              LLLL: 'dddd, D MMMM YYYY Ð³., HH:mm',
          },
          calendar: {
              sameDay: '[Ð¡ÑÐ½Ð½Ñ Ñ] LT',
              nextDay: '[ÐÐ°ÑÑÑÐ° Ñ] LT',
              lastDay: '[Ð£ÑÐ¾ÑÐ° Ñ] LT',
              nextWeek: function () {
                  return '[Ð£] dddd [Ñ] LT';
              },
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                      case 3:
                      case 5:
                      case 6:
                          return '[Ð£ Ð¼ÑÐ½ÑÐ»ÑÑ] dddd [Ñ] LT';
                      case 1:
                      case 2:
                      case 4:
                          return '[Ð£ Ð¼ÑÐ½ÑÐ»Ñ] dddd [Ñ] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ð¿ÑÐ°Ð· %s',
              past: '%s ÑÐ°Ð¼Ñ',
              s: 'Ð½ÐµÐºÐ°Ð»ÑÐºÑ ÑÐµÐºÑÐ½Ð´',
              m: relativeTimeWithPlural,
              mm: relativeTimeWithPlural,
              h: relativeTimeWithPlural,
              hh: relativeTimeWithPlural,
              d: 'Ð´Ð·ÐµÐ½Ñ',
              dd: relativeTimeWithPlural,
              M: 'Ð¼ÐµÑÑÑ',
              MM: relativeTimeWithPlural,
              y: 'Ð³Ð¾Ð´',
              yy: relativeTimeWithPlural,
          },
          meridiemParse: /Ð½Ð¾ÑÑ|ÑÐ°Ð½ÑÑÑ|Ð´Ð½Ñ|Ð²ÐµÑÐ°ÑÐ°/,
          isPM: function (input) {
              return /^(Ð´Ð½Ñ|Ð²ÐµÑÐ°ÑÐ°)$/.test(input);
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'Ð½Ð¾ÑÑ';
              } else if (hour < 12) {
                  return 'ÑÐ°Ð½ÑÑÑ';
              } else if (hour < 17) {
                  return 'Ð´Ð½Ñ';
              } else {
                  return 'Ð²ÐµÑÐ°ÑÐ°';
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(Ñ|Ñ|Ð³Ð°)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'M':
                  case 'd':
                  case 'DDD':
                  case 'w':
                  case 'W':
                      return (number % 10 === 2 || number % 10 === 3) &&
                          number % 100 !== 12 &&
                          number % 100 !== 13
                          ? number + '-Ñ'
                          : number + '-Ñ';
                  case 'D':
                      return number + '-Ð³Ð°';
                  default:
                      return number;
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('bg', {
          months: 'ÑÐ½ÑÐ°ÑÐ¸_ÑÐµÐ²ÑÑÐ°ÑÐ¸_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐ¸Ð»_Ð¼Ð°Ð¹_ÑÐ½Ð¸_ÑÐ»Ð¸_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸'.split(
              '_'
          ),
          monthsShort: 'ÑÐ½Ñ_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ð¹_ÑÐ½Ð¸_ÑÐ»Ð¸_Ð°Ð²Ð³_ÑÐµÐ¿_Ð¾ÐºÑ_Ð½Ð¾Ðµ_Ð´ÐµÐº'.split('_'),
          weekdays: 'Ð½ÐµÐ´ÐµÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÑÐ´Ð°_ÑÐµÑÐ²ÑÑÑÑÐº_Ð¿ÐµÑÑÐº_ÑÑÐ±Ð¾ÑÐ°'.split(
              '_'
          ),
          weekdaysShort: 'Ð½ÐµÐ´_Ð¿Ð¾Ð½_Ð²ÑÐ¾_ÑÑÑ_ÑÐµÑ_Ð¿ÐµÑ_ÑÑÐ±'.split('_'),
          weekdaysMin: 'Ð½Ð´_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'D.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY H:mm',
              LLLL: 'dddd, D MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[ÐÐ½ÐµÑ Ð²] LT',
              nextDay: '[Ð£ÑÑÐµ Ð²] LT',
              nextWeek: 'dddd [Ð²] LT',
              lastDay: '[ÐÑÐµÑÐ° Ð²] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                      case 3:
                      case 6:
                          return '[ÐÐ¸Ð½Ð°Ð»Ð°ÑÐ°] dddd [Ð²] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[ÐÐ¸Ð½Ð°Ð»Ð¸Ñ] dddd [Ð²] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÑÐ»ÐµÐ´ %s',
              past: 'Ð¿ÑÐµÐ´Ð¸ %s',
              s: 'Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸',
              ss: '%d ÑÐµÐºÑÐ½Ð´Ð¸',
              m: 'Ð¼Ð¸Ð½ÑÑÐ°',
              mm: '%d Ð¼Ð¸Ð½ÑÑÐ¸',
              h: 'ÑÐ°Ñ',
              hh: '%d ÑÐ°ÑÐ°',
              d: 'Ð´ÐµÐ½',
              dd: '%d Ð´ÐµÐ½Ð°',
              w: 'ÑÐµÐ´Ð¼Ð¸ÑÐ°',
              ww: '%d ÑÐµÐ´Ð¼Ð¸ÑÐ¸',
              M: 'Ð¼ÐµÑÐµÑ',
              MM: '%d Ð¼ÐµÑÐµÑÐ°',
              y: 'Ð³Ð¾Ð´Ð¸Ð½Ð°',
              yy: '%d Ð³Ð¾Ð´Ð¸Ð½Ð¸',
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(ÐµÐ²|ÐµÐ½|ÑÐ¸|Ð²Ð¸|ÑÐ¸|Ð¼Ð¸)/,
          ordinal: function (number) {
              var lastDigit = number % 10,
                  last2Digits = number % 100;
              if (number === 0) {
                  return number + '-ÐµÐ²';
              } else if (last2Digits === 0) {
                  return number + '-ÐµÐ½';
              } else if (last2Digits > 10 && last2Digits < 20) {
                  return number + '-ÑÐ¸';
              } else if (lastDigit === 1) {
                  return number + '-Ð²Ð¸';
              } else if (lastDigit === 2) {
                  return number + '-ÑÐ¸';
              } else if (lastDigit === 7 || lastDigit === 8) {
                  return number + '-Ð¼Ð¸';
              } else {
                  return number + '-ÑÐ¸';
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('bm', {
          months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_MÉkalo_ZuwÉnkalo_Zuluyekalo_Utikalo_SÉtanburukalo_ÉkutÉburukalo_Nowanburukalo_Desanburukalo'.split(
              '_'
          ),
          monthsShort: 'Zan_Few_Mar_Awi_MÉ_Zuw_Zul_Uti_SÉt_Éku_Now_Des'.split('_'),
          weekdays: 'Kari_NtÉnÉn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
          weekdaysShort: 'Kar_NtÉ_Tar_Ara_Ala_Jum_Sib'.split('_'),
          weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'MMMM [tile] D [san] YYYY',
              LLL: 'MMMM [tile] D [san] YYYY [lÉrÉ] HH:mm',
              LLLL: 'dddd MMMM [tile] D [san] YYYY [lÉrÉ] HH:mm',
          },
          calendar: {
              sameDay: '[Bi lÉrÉ] LT',
              nextDay: '[Sini lÉrÉ] LT',
              nextWeek: 'dddd [don lÉrÉ] LT',
              lastDay: '[Kunu lÉrÉ] LT',
              lastWeek: 'dddd [tÉmÉnen lÉrÉ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s kÉnÉ',
              past: 'a bÉ %s bÉ',
              s: 'sanga dama dama',
              ss: 'sekondi %d',
              m: 'miniti kelen',
              mm: 'miniti %d',
              h: 'lÉrÉ kelen',
              hh: 'lÉrÉ %d',
              d: 'tile kelen',
              dd: 'tile %d',
              M: 'kalo kelen',
              MM: 'kalo %d',
              y: 'san kelen',
              yy: 'san %d',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$3 = {
              1: 'à§§',
              2: 'à§¨',
              3: 'à§©',
              4: 'à§ª',
              5: 'à§«',
              6: 'à§¬',
              7: 'à§­',
              8: 'à§®',
              9: 'à§¯',
              0: 'à§¦',
          },
          numberMap$2 = {
              'à§§': '1',
              'à§¨': '2',
              'à§©': '3',
              'à§ª': '4',
              'à§«': '5',
              'à§¬': '6',
              'à§­': '7',
              'à§®': '8',
              'à§¯': '9',
              'à§¦': '0',
          };

      hooks.defineLocale('bn-bd', {
          months: 'à¦à¦¾à¦¨à§à§à¦¾à¦°à¦¿_à¦«à§à¦¬à§à¦°à§à§à¦¾à¦°à¦¿_à¦®à¦¾à¦°à§à¦_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§_à¦à§à¦¨_à¦à§à¦²à¦¾à¦_à¦à¦à¦¸à§à¦_à¦¸à§à¦ªà§à¦à§à¦®à§à¦¬à¦°_à¦à¦à§à¦à§à¦¬à¦°_à¦¨à¦­à§à¦®à§à¦¬à¦°_à¦¡à¦¿à¦¸à§à¦®à§à¦¬à¦°'.split(
              '_'
          ),
          monthsShort: 'à¦à¦¾à¦¨à§_à¦«à§à¦¬à§à¦°à§_à¦®à¦¾à¦°à§à¦_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§_à¦à§à¦¨_à¦à§à¦²à¦¾à¦_à¦à¦à¦¸à§à¦_à¦¸à§à¦ªà§à¦_à¦à¦à§à¦à§_à¦¨à¦­à§_à¦¡à¦¿à¦¸à§'.split(
              '_'
          ),
          weekdays: 'à¦°à¦¬à¦¿à¦¬à¦¾à¦°_à¦¸à§à¦®à¦¬à¦¾à¦°_à¦®à¦à§à¦à¦²à¦¬à¦¾à¦°_à¦¬à§à¦§à¦¬à¦¾à¦°_à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à¦¿à¦¬à¦¾à¦°_à¦¶à§à¦à§à¦°à¦¬à¦¾à¦°_à¦¶à¦¨à¦¿à¦¬à¦¾à¦°'.split(
              '_'
          ),
          weekdaysShort: 'à¦°à¦¬à¦¿_à¦¸à§à¦®_à¦®à¦à§à¦à¦²_à¦¬à§à¦§_à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à¦¿_à¦¶à§à¦à§à¦°_à¦¶à¦¨à¦¿'.split('_'),
          weekdaysMin: 'à¦°à¦¬à¦¿_à¦¸à§à¦®_à¦®à¦à§à¦à¦²_à¦¬à§à¦§_à¦¬à§à¦¹_à¦¶à§à¦à§à¦°_à¦¶à¦¨à¦¿'.split('_'),
          longDateFormat: {
              LT: 'A h:mm à¦¸à¦®à§',
              LTS: 'A h:mm:ss à¦¸à¦®à§',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm à¦¸à¦®à§',
              LLLL: 'dddd, D MMMM YYYY, A h:mm à¦¸à¦®à§',
          },
          calendar: {
              sameDay: '[à¦à¦] LT',
              nextDay: '[à¦à¦à¦¾à¦®à§à¦à¦¾à¦²] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à¦à¦¤à¦à¦¾à¦²] LT',
              lastWeek: '[à¦à¦¤] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à¦ªà¦°à§',
              past: '%s à¦à¦à§',
              s: 'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡',
              ss: '%d à¦¸à§à¦à§à¦¨à§à¦¡',
              m: 'à¦à¦ à¦®à¦¿à¦¨à¦¿à¦',
              mm: '%d à¦®à¦¿à¦¨à¦¿à¦',
              h: 'à¦à¦ à¦à¦¨à§à¦à¦¾',
              hh: '%d à¦à¦¨à§à¦à¦¾',
              d: 'à¦à¦ à¦¦à¦¿à¦¨',
              dd: '%d à¦¦à¦¿à¦¨',
              M: 'à¦à¦ à¦®à¦¾à¦¸',
              MM: '%d à¦®à¦¾à¦¸',
              y: 'à¦à¦ à¦¬à¦à¦°',
              yy: '%d à¦¬à¦à¦°',
          },
          preparse: function (string) {
              return string.replace(/[à§§à§¨à§©à§ªà§«à§¬à§­à§®à§¯à§¦]/g, function (match) {
                  return numberMap$2[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$3[match];
              });
          },

          meridiemParse: /à¦°à¦¾à¦¤|à¦­à§à¦°|à¦¸à¦à¦¾à¦²|à¦¦à§à¦ªà§à¦°|à¦¬à¦¿à¦à¦¾à¦²|à¦¸à¦¨à§à¦§à§à¦¯à¦¾|à¦°à¦¾à¦¤/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à¦°à¦¾à¦¤') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'à¦­à§à¦°') {
                  return hour;
              } else if (meridiem === 'à¦¸à¦à¦¾à¦²') {
                  return hour;
              } else if (meridiem === 'à¦¦à§à¦ªà§à¦°') {
                  return hour >= 3 ? hour : hour + 12;
              } else if (meridiem === 'à¦¬à¦¿à¦à¦¾à¦²') {
                  return hour + 12;
              } else if (meridiem === 'à¦¸à¦¨à§à¦§à§à¦¯à¦¾') {
                  return hour + 12;
              }
          },

          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à¦°à¦¾à¦¤';
              } else if (hour < 6) {
                  return 'à¦­à§à¦°';
              } else if (hour < 12) {
                  return 'à¦¸à¦à¦¾à¦²';
              } else if (hour < 15) {
                  return 'à¦¦à§à¦ªà§à¦°';
              } else if (hour < 18) {
                  return 'à¦¬à¦¿à¦à¦¾à¦²';
              } else if (hour < 20) {
                  return 'à¦¸à¦¨à§à¦§à§à¦¯à¦¾';
              } else {
                  return 'à¦°à¦¾à¦¤';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$4 = {
              1: 'à§§',
              2: 'à§¨',
              3: 'à§©',
              4: 'à§ª',
              5: 'à§«',
              6: 'à§¬',
              7: 'à§­',
              8: 'à§®',
              9: 'à§¯',
              0: 'à§¦',
          },
          numberMap$3 = {
              'à§§': '1',
              'à§¨': '2',
              'à§©': '3',
              'à§ª': '4',
              'à§«': '5',
              'à§¬': '6',
              'à§­': '7',
              'à§®': '8',
              'à§¯': '9',
              'à§¦': '0',
          };

      hooks.defineLocale('bn', {
          months: 'à¦à¦¾à¦¨à§à§à¦¾à¦°à¦¿_à¦«à§à¦¬à§à¦°à§à§à¦¾à¦°à¦¿_à¦®à¦¾à¦°à§à¦_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§_à¦à§à¦¨_à¦à§à¦²à¦¾à¦_à¦à¦à¦¸à§à¦_à¦¸à§à¦ªà§à¦à§à¦®à§à¦¬à¦°_à¦à¦à§à¦à§à¦¬à¦°_à¦¨à¦­à§à¦®à§à¦¬à¦°_à¦¡à¦¿à¦¸à§à¦®à§à¦¬à¦°'.split(
              '_'
          ),
          monthsShort: 'à¦à¦¾à¦¨à§_à¦«à§à¦¬à§à¦°à§_à¦®à¦¾à¦°à§à¦_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§_à¦à§à¦¨_à¦à§à¦²à¦¾à¦_à¦à¦à¦¸à§à¦_à¦¸à§à¦ªà§à¦_à¦à¦à§à¦à§_à¦¨à¦­à§_à¦¡à¦¿à¦¸à§'.split(
              '_'
          ),
          weekdays: 'à¦°à¦¬à¦¿à¦¬à¦¾à¦°_à¦¸à§à¦®à¦¬à¦¾à¦°_à¦®à¦à§à¦à¦²à¦¬à¦¾à¦°_à¦¬à§à¦§à¦¬à¦¾à¦°_à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à¦¿à¦¬à¦¾à¦°_à¦¶à§à¦à§à¦°à¦¬à¦¾à¦°_à¦¶à¦¨à¦¿à¦¬à¦¾à¦°'.split(
              '_'
          ),
          weekdaysShort: 'à¦°à¦¬à¦¿_à¦¸à§à¦®_à¦®à¦à§à¦à¦²_à¦¬à§à¦§_à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à¦¿_à¦¶à§à¦à§à¦°_à¦¶à¦¨à¦¿'.split('_'),
          weekdaysMin: 'à¦°à¦¬à¦¿_à¦¸à§à¦®_à¦®à¦à§à¦à¦²_à¦¬à§à¦§_à¦¬à§à¦¹_à¦¶à§à¦à§à¦°_à¦¶à¦¨à¦¿'.split('_'),
          longDateFormat: {
              LT: 'A h:mm à¦¸à¦®à§',
              LTS: 'A h:mm:ss à¦¸à¦®à§',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm à¦¸à¦®à§',
              LLLL: 'dddd, D MMMM YYYY, A h:mm à¦¸à¦®à§',
          },
          calendar: {
              sameDay: '[à¦à¦] LT',
              nextDay: '[à¦à¦à¦¾à¦®à§à¦à¦¾à¦²] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à¦à¦¤à¦à¦¾à¦²] LT',
              lastWeek: '[à¦à¦¤] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à¦ªà¦°à§',
              past: '%s à¦à¦à§',
              s: 'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡',
              ss: '%d à¦¸à§à¦à§à¦¨à§à¦¡',
              m: 'à¦à¦ à¦®à¦¿à¦¨à¦¿à¦',
              mm: '%d à¦®à¦¿à¦¨à¦¿à¦',
              h: 'à¦à¦ à¦à¦¨à§à¦à¦¾',
              hh: '%d à¦à¦¨à§à¦à¦¾',
              d: 'à¦à¦ à¦¦à¦¿à¦¨',
              dd: '%d à¦¦à¦¿à¦¨',
              M: 'à¦à¦ à¦®à¦¾à¦¸',
              MM: '%d à¦®à¦¾à¦¸',
              y: 'à¦à¦ à¦¬à¦à¦°',
              yy: '%d à¦¬à¦à¦°',
          },
          preparse: function (string) {
              return string.replace(/[à§§à§¨à§©à§ªà§«à§¬à§­à§®à§¯à§¦]/g, function (match) {
                  return numberMap$3[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$4[match];
              });
          },
          meridiemParse: /à¦°à¦¾à¦¤|à¦¸à¦à¦¾à¦²|à¦¦à§à¦ªà§à¦°|à¦¬à¦¿à¦à¦¾à¦²|à¦°à¦¾à¦¤/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (
                  (meridiem === 'à¦°à¦¾à¦¤' && hour >= 4) ||
                  (meridiem === 'à¦¦à§à¦ªà§à¦°' && hour < 5) ||
                  meridiem === 'à¦¬à¦¿à¦à¦¾à¦²'
              ) {
                  return hour + 12;
              } else {
                  return hour;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à¦°à¦¾à¦¤';
              } else if (hour < 10) {
                  return 'à¦¸à¦à¦¾à¦²';
              } else if (hour < 17) {
                  return 'à¦¦à§à¦ªà§à¦°';
              } else if (hour < 20) {
                  return 'à¦¬à¦¿à¦à¦¾à¦²';
              } else {
                  return 'à¦°à¦¾à¦¤';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$5 = {
              1: 'à¼¡',
              2: 'à¼¢',
              3: 'à¼£',
              4: 'à¼¤',
              5: 'à¼¥',
              6: 'à¼¦',
              7: 'à¼§',
              8: 'à¼¨',
              9: 'à¼©',
              0: 'à¼ ',
          },
          numberMap$4 = {
              'à¼¡': '1',
              'à¼¢': '2',
              'à¼£': '3',
              'à¼¤': '4',
              'à¼¥': '5',
              'à¼¦': '6',
              'à¼§': '7',
              'à¼¨': '8',
              'à¼©': '9',
              'à¼ ': '0',
          };

      hooks.defineLocale('bo', {
          months: 'à½à¾³à¼à½à¼à½à½à¼à½à½¼_à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½_à½à¾³à¼à½à¼à½à½¦à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½²à¼à½_à½à¾³à¼à½à¼à½£à¾à¼à½_à½à¾³à¼à½à¼à½à¾²à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à½à¼à½_à½à¾³à¼à½à¼à½à½¢à¾à¾±à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½¦à¼à½'.split(
              '_'
          ),
          monthsShort: 'à½à¾³à¼1_à½à¾³à¼2_à½à¾³à¼3_à½à¾³à¼4_à½à¾³à¼5_à½à¾³à¼6_à½à¾³à¼7_à½à¾³à¼8_à½à¾³à¼9_à½à¾³à¼10_à½à¾³à¼11_à½à¾³à¼12'.split(
              '_'
          ),
          monthsShortRegex: /^(à½à¾³à¼\d{1,2})/,
          monthsParseExact: true,
          weekdays: 'à½à½à½ à¼à½à½²à¼à½à¼_à½à½à½ à¼à½à¾³à¼à½à¼_à½à½à½ à¼à½à½²à½à¼à½à½à½¢à¼_à½à½à½ à¼à½£à¾·à½à¼à½à¼_à½à½à½ à¼à½à½´à½¢à¼à½à½´_à½à½à½ à¼à½à¼à½¦à½à½¦à¼_à½à½à½ à¼à½¦à¾¤à½ºà½à¼à½à¼'.split(
              '_'
          ),
          weekdaysShort: 'à½à½²à¼à½à¼_à½à¾³à¼à½à¼_à½à½²à½à¼à½à½à½¢à¼_à½£à¾·à½à¼à½à¼_à½à½´à½¢à¼à½à½´_à½à¼à½¦à½à½¦à¼_à½¦à¾¤à½ºà½à¼à½à¼'.split(
              '_'
          ),
          weekdaysMin: 'à½à½²_à½à¾³_à½à½²à½_à½£à¾·à½_à½à½´à½¢_à½¦à½à½¦_à½¦à¾¤à½ºà½'.split('_'),
          longDateFormat: {
              LT: 'A h:mm',
              LTS: 'A h:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm',
              LLLL: 'dddd, D MMMM YYYY, A h:mm',
          },
          calendar: {
              sameDay: '[à½à½²à¼à½¢à½²à½] LT',
              nextDay: '[à½¦à½à¼à½à½²à½] LT',
              nextWeek: '[à½à½à½´à½à¼à½à¾²à½à¼à½¢à¾à½ºà½¦à¼à½], LT',
              lastDay: '[à½à¼à½¦à½] LT',
              lastWeek: '[à½à½à½´à½à¼à½à¾²à½à¼à½à½à½ à¼à½] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à½£à¼',
              past: '%s à½¦à¾à½à¼à½£',
              s: 'à½£à½à¼à½¦à½',
              ss: '%d à½¦à¾à½¢à¼à½à¼',
              m: 'à½¦à¾à½¢à¼à½à¼à½à½à½²à½',
              mm: '%d à½¦à¾à½¢à¼à½',
              h: 'à½à½´à¼à½à½¼à½à¼à½à½à½²à½',
              hh: '%d à½à½´à¼à½à½¼à½',
              d: 'à½à½²à½à¼à½à½à½²à½',
              dd: '%d à½à½²à½à¼',
              M: 'à½à¾³à¼à½à¼à½à½à½²à½',
              MM: '%d à½à¾³à¼à½',
              y: 'à½£à½¼à¼à½à½à½²à½',
              yy: '%d à½£à½¼',
          },
          preparse: function (string) {
              return string.replace(/[à¼¡à¼¢à¼£à¼¤à¼¥à¼¦à¼§à¼¨à¼©à¼ ]/g, function (match) {
                  return numberMap$4[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$5[match];
              });
          },
          meridiemParse: /à½à½à½à¼à½à½¼|à½à½¼à½à½¦à¼à½à½¦|à½à½²à½à¼à½à½´à½|à½à½à½¼à½à¼à½à½|à½à½à½à¼à½à½¼/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (
                  (meridiem === 'à½à½à½à¼à½à½¼' && hour >= 4) ||
                  (meridiem === 'à½à½²à½à¼à½à½´à½' && hour < 5) ||
                  meridiem === 'à½à½à½¼à½à¼à½à½'
              ) {
                  return hour + 12;
              } else {
                  return hour;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à½à½à½à¼à½à½¼';
              } else if (hour < 10) {
                  return 'à½à½¼à½à½¦à¼à½à½¦';
              } else if (hour < 17) {
                  return 'à½à½²à½à¼à½à½´à½';
              } else if (hour < 20) {
                  return 'à½à½à½¼à½à¼à½à½';
              } else {
                  return 'à½à½à½à¼à½à½¼';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function relativeTimeWithMutation(number, withoutSuffix, key) {
          var format = {
              mm: 'munutenn',
              MM: 'miz',
              dd: 'devezh',
          };
          return number + ' ' + mutation(format[key], number);
      }
      function specialMutationForYears(number) {
          switch (lastNumber(number)) {
              case 1:
              case 3:
              case 4:
              case 5:
              case 9:
                  return number + ' bloaz';
              default:
                  return number + ' vloaz';
          }
      }
      function lastNumber(number) {
          if (number > 9) {
              return lastNumber(number % 10);
          }
          return number;
      }
      function mutation(text, number) {
          if (number === 2) {
              return softMutation(text);
          }
          return text;
      }
      function softMutation(text) {
          var mutationTable = {
              m: 'v',
              b: 'v',
              d: 'z',
          };
          if (mutationTable[text.charAt(0)] === undefined) {
              return text;
          }
          return mutationTable[text.charAt(0)] + text.substring(1);
      }

      var monthsParse = [
              /^gen/i,
              /^c[Ê¼\']hwe/i,
              /^meu/i,
              /^ebr/i,
              /^mae/i,
              /^(mez|eve)/i,
              /^gou/i,
              /^eos/i,
              /^gwe/i,
              /^her/i,
              /^du/i,
              /^ker/i,
          ],
          monthsRegex$1 = /^(genver|c[Ê¼\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[Ê¼\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
          monthsStrictRegex = /^(genver|c[Ê¼\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
          monthsShortStrictRegex = /^(gen|c[Ê¼\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
          fullWeekdaysParse = [
              /^sul/i,
              /^lun/i,
              /^meurzh/i,
              /^merc[Ê¼\']her/i,
              /^yaou/i,
              /^gwener/i,
              /^sadorn/i,
          ],
          shortWeekdaysParse = [
              /^Sul/i,
              /^Lun/i,
              /^Meu/i,
              /^Mer/i,
              /^Yao/i,
              /^Gwe/i,
              /^Sad/i,
          ],
          minWeekdaysParse = [
              /^Su/i,
              /^Lu/i,
              /^Me([^r]|$)/i,
              /^Mer/i,
              /^Ya/i,
              /^Gw/i,
              /^Sa/i,
          ];

      hooks.defineLocale('br', {
          months: 'Genver_CÊ¼hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split(
              '_'
          ),
          monthsShort: 'Gen_CÊ¼hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
          weekdays: 'Sul_Lun_Meurzh_MercÊ¼her_Yaou_Gwener_Sadorn'.split('_'),
          weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
          weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
          weekdaysParse: minWeekdaysParse,
          fullWeekdaysParse: fullWeekdaysParse,
          shortWeekdaysParse: shortWeekdaysParse,
          minWeekdaysParse: minWeekdaysParse,

          monthsRegex: monthsRegex$1,
          monthsShortRegex: monthsRegex$1,
          monthsStrictRegex: monthsStrictRegex,
          monthsShortStrictRegex: monthsShortStrictRegex,
          monthsParse: monthsParse,
          longMonthsParse: monthsParse,
          shortMonthsParse: monthsParse,

          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [a viz] MMMM YYYY',
              LLL: 'D [a viz] MMMM YYYY HH:mm',
              LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Hiziv da] LT',
              nextDay: '[WarcÊ¼hoazh da] LT',
              nextWeek: 'dddd [da] LT',
              lastDay: '[DecÊ¼h da] LT',
              lastWeek: 'dddd [paset da] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'a-benn %s',
              past: '%s Ê¼zo',
              s: 'un nebeud segondennoÃ¹',
              ss: '%d eilenn',
              m: 'ur vunutenn',
              mm: relativeTimeWithMutation,
              h: 'un eur',
              hh: '%d eur',
              d: 'un devezh',
              dd: relativeTimeWithMutation,
              M: 'ur miz',
              MM: relativeTimeWithMutation,
              y: 'ur bloaz',
              yy: specialMutationForYears,
          },
          dayOfMonthOrdinalParse: /\d{1,2}(aÃ±|vet)/,
          ordinal: function (number) {
              var output = number === 1 ? 'aÃ±' : 'vet';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
          meridiemParse: /a.m.|g.m./, // goude merenn | a-raok merenn
          isPM: function (token) {
              return token === 'g.m.';
          },
          meridiem: function (hour, minute, isLower) {
              return hour < 12 ? 'a.m.' : 'g.m.';
          },
      });

      //! moment.js locale configuration

      function translate(number, withoutSuffix, key) {
          var result = number + ' ';
          switch (key) {
              case 'ss':
                  if (number === 1) {
                      result += 'sekunda';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'sekunde';
                  } else {
                      result += 'sekundi';
                  }
                  return result;
              case 'm':
                  return withoutSuffix ? 'jedna minuta' : 'jedne minute';
              case 'mm':
                  if (number === 1) {
                      result += 'minuta';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'minute';
                  } else {
                      result += 'minuta';
                  }
                  return result;
              case 'h':
                  return withoutSuffix ? 'jedan sat' : 'jednog sata';
              case 'hh':
                  if (number === 1) {
                      result += 'sat';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'sata';
                  } else {
                      result += 'sati';
                  }
                  return result;
              case 'dd':
                  if (number === 1) {
                      result += 'dan';
                  } else {
                      result += 'dana';
                  }
                  return result;
              case 'MM':
                  if (number === 1) {
                      result += 'mjesec';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'mjeseca';
                  } else {
                      result += 'mjeseci';
                  }
                  return result;
              case 'yy':
                  if (number === 1) {
                      result += 'godina';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'godine';
                  } else {
                      result += 'godina';
                  }
                  return result;
          }
      }

      hooks.defineLocale('bs', {
          months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split(
              '_'
          ),
          monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota'.split(
              '_'
          ),
          weekdaysShort: 'ned._pon._uto._sri._Äet._pet._sub.'.split('_'),
          weekdaysMin: 'ne_po_ut_sr_Äe_pe_su'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY H:mm',
              LLLL: 'dddd, D. MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[danas u] LT',
              nextDay: '[sutra u] LT',
              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[u] [nedjelju] [u] LT';
                      case 3:
                          return '[u] [srijedu] [u] LT';
                      case 6:
                          return '[u] [subotu] [u] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[u] dddd [u] LT';
                  }
              },
              lastDay: '[juÄer u] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                      case 3:
                          return '[proÅ¡lu] dddd [u] LT';
                      case 6:
                          return '[proÅ¡le] [subote] [u] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[proÅ¡li] dddd [u] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'za %s',
              past: 'prije %s',
              s: 'par sekundi',
              ss: translate,
              m: translate,
              mm: translate,
              h: translate,
              hh: translate,
              d: 'dan',
              dd: translate,
              M: 'mjesec',
              MM: translate,
              y: 'godinu',
              yy: translate,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ca', {
          months: {
              standalone: 'gener_febrer_marÃ§_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split(
                  '_'
              ),
              format: "de gener_de febrer_de marÃ§_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
                  '_'
              ),
              isFormat: /D[oD]?(\s)+MMMM/,
          },
          monthsShort: 'gen._febr._marÃ§_abr._maig_juny_jul._ag._set._oct._nov._des.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split(
              '_'
          ),
          weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
          weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM [de] YYYY',
              ll: 'D MMM YYYY',
              LLL: 'D MMMM [de] YYYY [a les] H:mm',
              lll: 'D MMM YYYY, H:mm',
              LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
              llll: 'ddd D MMM YYYY, H:mm',
          },
          calendar: {
              sameDay: function () {
                  return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
              },
              nextDay: function () {
                  return '[demÃ  a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
              },
              nextWeek: function () {
                  return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
              },
              lastDay: function () {
                  return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
              },
              lastWeek: function () {
                  return (
                      '[el] dddd [passat a ' +
                      (this.hours() !== 1 ? 'les' : 'la') +
                      '] LT'
                  );
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: "d'aquÃ­ %s",
              past: 'fa %s',
              s: 'uns segons',
              ss: '%d segons',
              m: 'un minut',
              mm: '%d minuts',
              h: 'una hora',
              hh: '%d hores',
              d: 'un dia',
              dd: '%d dies',
              M: 'un mes',
              MM: '%d mesos',
              y: 'un any',
              yy: '%d anys',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|Ã¨|a)/,
          ordinal: function (number, period) {
              var output =
                  number === 1
                      ? 'r'
                      : number === 2
                      ? 'n'
                      : number === 3
                      ? 'r'
                      : number === 4
                      ? 't'
                      : 'Ã¨';
              if (period === 'w' || period === 'W') {
                  output = 'a';
              }
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var months$4 = 'leden_Ãºnor_bÅezen_duben_kvÄten_Äerven_Äervenec_srpen_zÃ¡ÅÃ­_ÅÃ­jen_listopad_prosinec'.split(
              '_'
          ),
          monthsShort = 'led_Ãºno_bÅe_dub_kvÄ_Ävn_Ävc_srp_zÃ¡Å_ÅÃ­j_lis_pro'.split('_'),
          monthsParse$1 = [
              /^led/i,
              /^Ãºno/i,
              /^bÅe/i,
              /^dub/i,
              /^kvÄ/i,
              /^(Ävn|Äerven$|Äervna)/i,
              /^(Ävc|Äervenec|Äervence)/i,
              /^srp/i,
              /^zÃ¡Å/i,
              /^ÅÃ­j/i,
              /^lis/i,
              /^pro/i,
          ],
          // NOTE: 'Äerven' is substring of 'Äervenec'; therefore 'Äervenec' must precede 'Äerven' in the regex to be fully matched.
          // Otherwise parser matches '1. Äervenec' as '1. Äerven' + 'ec'.
          monthsRegex$2 = /^(leden|Ãºnor|bÅezen|duben|kvÄten|Äervenec|Äervence|Äerven|Äervna|srpen|zÃ¡ÅÃ­|ÅÃ­jen|listopad|prosinec|led|Ãºno|bÅe|dub|kvÄ|Ävn|Ävc|srp|zÃ¡Å|ÅÃ­j|lis|pro)/i;

      function plural$1(n) {
          return n > 1 && n < 5 && ~~(n / 10) !== 1;
      }
      function translate$1(number, withoutSuffix, key, isFuture) {
          var result = number + ' ';
          switch (key) {
              case 's': // a few seconds / in a few seconds / a few seconds ago
                  return withoutSuffix || isFuture ? 'pÃ¡r sekund' : 'pÃ¡r sekundami';
              case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$1(number) ? 'sekundy' : 'sekund');
                  } else {
                      return result + 'sekundami';
                  }
              case 'm': // a minute / in a minute / a minute ago
                  return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
              case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$1(number) ? 'minuty' : 'minut');
                  } else {
                      return result + 'minutami';
                  }
              case 'h': // an hour / in an hour / an hour ago
                  return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
              case 'hh': // 9 hours / in 9 hours / 9 hours ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$1(number) ? 'hodiny' : 'hodin');
                  } else {
                      return result + 'hodinami';
                  }
              case 'd': // a day / in a day / a day ago
                  return withoutSuffix || isFuture ? 'den' : 'dnem';
              case 'dd': // 9 days / in 9 days / 9 days ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$1(number) ? 'dny' : 'dnÃ­');
                  } else {
                      return result + 'dny';
                  }
              case 'M': // a month / in a month / a month ago
                  return withoutSuffix || isFuture ? 'mÄsÃ­c' : 'mÄsÃ­cem';
              case 'MM': // 9 months / in 9 months / 9 months ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$1(number) ? 'mÄsÃ­ce' : 'mÄsÃ­cÅ¯');
                  } else {
                      return result + 'mÄsÃ­ci';
                  }
              case 'y': // a year / in a year / a year ago
                  return withoutSuffix || isFuture ? 'rok' : 'rokem';
              case 'yy': // 9 years / in 9 years / 9 years ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$1(number) ? 'roky' : 'let');
                  } else {
                      return result + 'lety';
                  }
          }
      }

      hooks.defineLocale('cs', {
          months: months$4,
          monthsShort: monthsShort,
          monthsRegex: monthsRegex$2,
          monthsShortRegex: monthsRegex$2,
          // NOTE: 'Äerven' is substring of 'Äervenec'; therefore 'Äervenec' must precede 'Äerven' in the regex to be fully matched.
          // Otherwise parser matches '1. Äervenec' as '1. Äerven' + 'ec'.
          monthsStrictRegex: /^(leden|ledna|Ãºnora|Ãºnor|bÅezen|bÅezna|duben|dubna|kvÄten|kvÄtna|Äervenec|Äervence|Äerven|Äervna|srpen|srpna|zÃ¡ÅÃ­|ÅÃ­jen|ÅÃ­jna|listopadu|listopad|prosinec|prosince)/i,
          monthsShortStrictRegex: /^(led|Ãºno|bÅe|dub|kvÄ|Ävn|Ävc|srp|zÃ¡Å|ÅÃ­j|lis|pro)/i,
          monthsParse: monthsParse$1,
          longMonthsParse: monthsParse$1,
          shortMonthsParse: monthsParse$1,
          weekdays: 'nedÄle_pondÄlÃ­_ÃºterÃ½_stÅeda_Ätvrtek_pÃ¡tek_sobota'.split('_'),
          weekdaysShort: 'ne_po_Ãºt_st_Ät_pÃ¡_so'.split('_'),
          weekdaysMin: 'ne_po_Ãºt_st_Ät_pÃ¡_so'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY H:mm',
              LLLL: 'dddd D. MMMM YYYY H:mm',
              l: 'D. M. YYYY',
          },
          calendar: {
              sameDay: '[dnes v] LT',
              nextDay: '[zÃ­tra v] LT',
              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[v nedÄli v] LT';
                      case 1:
                      case 2:
                          return '[v] dddd [v] LT';
                      case 3:
                          return '[ve stÅedu v] LT';
                      case 4:
                          return '[ve Ätvrtek v] LT';
                      case 5:
                          return '[v pÃ¡tek v] LT';
                      case 6:
                          return '[v sobotu v] LT';
                  }
              },
              lastDay: '[vÄera v] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[minulou nedÄli v] LT';
                      case 1:
                      case 2:
                          return '[minulÃ©] dddd [v] LT';
                      case 3:
                          return '[minulou stÅedu v] LT';
                      case 4:
                      case 5:
                          return '[minulÃ½] dddd [v] LT';
                      case 6:
                          return '[minulou sobotu v] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'za %s',
              past: 'pÅed %s',
              s: translate$1,
              ss: translate$1,
              m: translate$1,
              mm: translate$1,
              h: translate$1,
              hh: translate$1,
              d: translate$1,
              dd: translate$1,
              M: translate$1,
              MM: translate$1,
              y: translate$1,
              yy: translate$1,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('cv', {
          months: 'ÐºÓÑÐ»Ð°Ñ_Ð½Ð°ÑÓÑ_Ð¿ÑÑ_Ð°ÐºÐ°_Ð¼Ð°Ð¹_Ò«ÓÑÑÐ¼Ðµ_ÑÑÓ_Ò«ÑÑÐ»Ð°_Ð°Ð²ÓÐ½_ÑÐ¿Ð°_ÑÓ³Ðº_ÑÐ°ÑÑÐ°Ð²'.split(
              '_'
          ),
          monthsShort: 'ÐºÓÑ_Ð½Ð°Ñ_Ð¿ÑÑ_Ð°ÐºÐ°_Ð¼Ð°Ð¹_Ò«ÓÑ_ÑÑÓ_Ò«ÑÑ_Ð°Ð²Ð½_ÑÐ¿Ð°_ÑÓ³Ðº_ÑÐ°Ñ'.split('_'),
          weekdays: 'Ð²ÑÑÑÐ°ÑÐ½Ð¸ÐºÑÐ½_ÑÑÐ½ÑÐ¸ÐºÑÐ½_ÑÑÐ»Ð°ÑÐ¸ÐºÑÐ½_ÑÐ½ÐºÑÐ½_ÐºÓÒ«Ð½ÐµÑÐ½Ð¸ÐºÑÐ½_ÑÑÐ½ÐµÐºÑÐ½_ÑÓÐ¼Ð°ÑÐºÑÐ½'.split(
              '_'
          ),
          weekdaysShort: 'Ð²ÑÑ_ÑÑÐ½_ÑÑÐ»_ÑÐ½_ÐºÓÒ«_ÑÑÐ½_ÑÓÐ¼'.split('_'),
          weekdaysMin: 'Ð²Ñ_ÑÐ½_ÑÑ_ÑÐ½_ÐºÒ«_ÑÑ_ÑÐ¼'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD-MM-YYYY',
              LL: 'YYYY [Ò«ÑÐ»ÑÐ¸] MMMM [ÑÐ¹ÓÑÓÐ½] D[-Ð¼ÓÑÓ]',
              LLL: 'YYYY [Ò«ÑÐ»ÑÐ¸] MMMM [ÑÐ¹ÓÑÓÐ½] D[-Ð¼ÓÑÓ], HH:mm',
              LLLL: 'dddd, YYYY [Ò«ÑÐ»ÑÐ¸] MMMM [ÑÐ¹ÓÑÓÐ½] D[-Ð¼ÓÑÓ], HH:mm',
          },
          calendar: {
              sameDay: '[ÐÐ°ÑÐ½] LT [ÑÐµÑÐµÑÑÐµ]',
              nextDay: '[Ð«ÑÐ°Ð½] LT [ÑÐµÑÐµÑÑÐµ]',
              lastDay: '[ÓÐ½ÐµÑ] LT [ÑÐµÑÐµÑÑÐµ]',
              nextWeek: '[ÒªÐ¸ÑÐµÑ] dddd LT [ÑÐµÑÐµÑÑÐµ]',
              lastWeek: '[ÐÑÑÐ½Ó] dddd LT [ÑÐµÑÐµÑÑÐµ]',
              sameElse: 'L',
          },
          relativeTime: {
              future: function (output) {
                  var affix = /ÑÐµÑÐµÑ$/i.exec(output)
                      ? 'ÑÐµÐ½'
                      : /Ò«ÑÐ»$/i.exec(output)
                      ? 'ÑÐ°Ð½'
                      : 'ÑÐ°Ð½';
                  return output + affix;
              },
              past: '%s ÐºÐ°ÑÐ»Ð»Ð°',
              s: 'Ð¿ÓÑ-Ð¸Ðº Ò«ÐµÐºÐºÑÐ½Ñ',
              ss: '%d Ò«ÐµÐºÐºÑÐ½Ñ',
              m: 'Ð¿ÓÑ Ð¼Ð¸Ð½ÑÑ',
              mm: '%d Ð¼Ð¸Ð½ÑÑ',
              h: 'Ð¿ÓÑ ÑÐµÑÐµÑ',
              hh: '%d ÑÐµÑÐµÑ',
              d: 'Ð¿ÓÑ ÐºÑÐ½',
              dd: '%d ÐºÑÐ½',
              M: 'Ð¿ÓÑ ÑÐ¹ÓÑ',
              MM: '%d ÑÐ¹ÓÑ',
              y: 'Ð¿ÓÑ Ò«ÑÐ»',
              yy: '%d Ò«ÑÐ»',
          },
          dayOfMonthOrdinalParse: /\d{1,2}-Ð¼ÓÑ/,
          ordinal: '%d-Ð¼ÓÑ',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('cy', {
          months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split(
              '_'
          ),
          monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split(
              '_'
          ),
          weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split(
              '_'
          ),
          weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
          weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
          weekdaysParseExact: true,
          // time formats are the same as en-gb
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Heddiw am] LT',
              nextDay: '[Yfory am] LT',
              nextWeek: 'dddd [am] LT',
              lastDay: '[Ddoe am] LT',
              lastWeek: 'dddd [diwethaf am] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'mewn %s',
              past: '%s yn Ã´l',
              s: 'ychydig eiliadau',
              ss: '%d eiliad',
              m: 'munud',
              mm: '%d munud',
              h: 'awr',
              hh: '%d awr',
              d: 'diwrnod',
              dd: '%d diwrnod',
              M: 'mis',
              MM: '%d mis',
              y: 'blwyddyn',
              yy: '%d flynedd',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
          // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
          ordinal: function (number) {
              var b = number,
                  output = '',
                  lookup = [
                      '',
                      'af',
                      'il',
                      'ydd',
                      'ydd',
                      'ed',
                      'ed',
                      'ed',
                      'fed',
                      'fed',
                      'fed', // 1af to 10fed
                      'eg',
                      'fed',
                      'eg',
                      'eg',
                      'fed',
                      'eg',
                      'eg',
                      'fed',
                      'eg',
                      'fed', // 11eg to 20fed
                  ];
              if (b > 20) {
                  if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                      output = 'fed'; // not 30ain, 70ain or 90ain
                  } else {
                      output = 'ain';
                  }
              } else if (b > 0) {
                  output = lookup[b];
              }
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('da', {
          months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split(
              '_'
          ),
          monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
          weekdays: 'sÃ¸ndag_mandag_tirsdag_onsdag_torsdag_fredag_lÃ¸rdag'.split('_'),
          weekdaysShort: 'sÃ¸n_man_tir_ons_tor_fre_lÃ¸r'.split('_'),
          weekdaysMin: 'sÃ¸_ma_ti_on_to_fr_lÃ¸'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY HH:mm',
              LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm',
          },
          calendar: {
              sameDay: '[i dag kl.] LT',
              nextDay: '[i morgen kl.] LT',
              nextWeek: 'pÃ¥ dddd [kl.] LT',
              lastDay: '[i gÃ¥r kl.] LT',
              lastWeek: '[i] dddd[s kl.] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'om %s',
              past: '%s siden',
              s: 'fÃ¥ sekunder',
              ss: '%d sekunder',
              m: 'et minut',
              mm: '%d minutter',
              h: 'en time',
              hh: '%d timer',
              d: 'en dag',
              dd: '%d dage',
              M: 'en mÃ¥ned',
              MM: '%d mÃ¥neder',
              y: 'et Ã¥r',
              yy: '%d Ã¥r',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
          var format = {
              m: ['eine Minute', 'einer Minute'],
              h: ['eine Stunde', 'einer Stunde'],
              d: ['ein Tag', 'einem Tag'],
              dd: [number + ' Tage', number + ' Tagen'],
              w: ['eine Woche', 'einer Woche'],
              M: ['ein Monat', 'einem Monat'],
              MM: [number + ' Monate', number + ' Monaten'],
              y: ['ein Jahr', 'einem Jahr'],
              yy: [number + ' Jahre', number + ' Jahren'],
          };
          return withoutSuffix ? format[key][0] : format[key][1];
      }

      hooks.defineLocale('de-at', {
          months: 'JÃ¤nner_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
              '_'
          ),
          monthsShort: 'JÃ¤n._Feb._MÃ¤rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
              '_'
          ),
          weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
          weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY HH:mm',
              LLLL: 'dddd, D. MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[heute um] LT [Uhr]',
              sameElse: 'L',
              nextDay: '[morgen um] LT [Uhr]',
              nextWeek: 'dddd [um] LT [Uhr]',
              lastDay: '[gestern um] LT [Uhr]',
              lastWeek: '[letzten] dddd [um] LT [Uhr]',
          },
          relativeTime: {
              future: 'in %s',
              past: 'vor %s',
              s: 'ein paar Sekunden',
              ss: '%d Sekunden',
              m: processRelativeTime,
              mm: '%d Minuten',
              h: processRelativeTime,
              hh: '%d Stunden',
              d: processRelativeTime,
              dd: processRelativeTime,
              w: processRelativeTime,
              ww: '%d Wochen',
              M: processRelativeTime,
              MM: processRelativeTime,
              y: processRelativeTime,
              yy: processRelativeTime,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
          var format = {
              m: ['eine Minute', 'einer Minute'],
              h: ['eine Stunde', 'einer Stunde'],
              d: ['ein Tag', 'einem Tag'],
              dd: [number + ' Tage', number + ' Tagen'],
              w: ['eine Woche', 'einer Woche'],
              M: ['ein Monat', 'einem Monat'],
              MM: [number + ' Monate', number + ' Monaten'],
              y: ['ein Jahr', 'einem Jahr'],
              yy: [number + ' Jahre', number + ' Jahren'],
          };
          return withoutSuffix ? format[key][0] : format[key][1];
      }

      hooks.defineLocale('de-ch', {
          months: 'Januar_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
              '_'
          ),
          monthsShort: 'Jan._Feb._MÃ¤rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
              '_'
          ),
          weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
          weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY HH:mm',
              LLLL: 'dddd, D. MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[heute um] LT [Uhr]',
              sameElse: 'L',
              nextDay: '[morgen um] LT [Uhr]',
              nextWeek: 'dddd [um] LT [Uhr]',
              lastDay: '[gestern um] LT [Uhr]',
              lastWeek: '[letzten] dddd [um] LT [Uhr]',
          },
          relativeTime: {
              future: 'in %s',
              past: 'vor %s',
              s: 'ein paar Sekunden',
              ss: '%d Sekunden',
              m: processRelativeTime$1,
              mm: '%d Minuten',
              h: processRelativeTime$1,
              hh: '%d Stunden',
              d: processRelativeTime$1,
              dd: processRelativeTime$1,
              w: processRelativeTime$1,
              ww: '%d Wochen',
              M: processRelativeTime$1,
              MM: processRelativeTime$1,
              y: processRelativeTime$1,
              yy: processRelativeTime$1,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
          var format = {
              m: ['eine Minute', 'einer Minute'],
              h: ['eine Stunde', 'einer Stunde'],
              d: ['ein Tag', 'einem Tag'],
              dd: [number + ' Tage', number + ' Tagen'],
              w: ['eine Woche', 'einer Woche'],
              M: ['ein Monat', 'einem Monat'],
              MM: [number + ' Monate', number + ' Monaten'],
              y: ['ein Jahr', 'einem Jahr'],
              yy: [number + ' Jahre', number + ' Jahren'],
          };
          return withoutSuffix ? format[key][0] : format[key][1];
      }

      hooks.defineLocale('de', {
          months: 'Januar_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
              '_'
          ),
          monthsShort: 'Jan._Feb._MÃ¤rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
              '_'
          ),
          weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
          weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY HH:mm',
              LLLL: 'dddd, D. MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[heute um] LT [Uhr]',
              sameElse: 'L',
              nextDay: '[morgen um] LT [Uhr]',
              nextWeek: 'dddd [um] LT [Uhr]',
              lastDay: '[gestern um] LT [Uhr]',
              lastWeek: '[letzten] dddd [um] LT [Uhr]',
          },
          relativeTime: {
              future: 'in %s',
              past: 'vor %s',
              s: 'ein paar Sekunden',
              ss: '%d Sekunden',
              m: processRelativeTime$2,
              mm: '%d Minuten',
              h: processRelativeTime$2,
              hh: '%d Stunden',
              d: processRelativeTime$2,
              dd: processRelativeTime$2,
              w: processRelativeTime$2,
              ww: '%d Wochen',
              M: processRelativeTime$2,
              MM: processRelativeTime$2,
              y: processRelativeTime$2,
              yy: processRelativeTime$2,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var months$5 = [
              'ÞÞ¬ÞÞªÞÞ¦ÞÞ©',
              'ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ©',
              'ÞÞ§ÞÞ¨ÞÞª',
              'ÞÞ­ÞÞ°ÞÞ©ÞÞª',
              'ÞÞ­',
              'ÞÞ«ÞÞ°',
              'ÞÞªÞÞ¦ÞÞ¨',
              'ÞÞ¯ÞÞ¦ÞÞ°ÞÞª',
              'ÞÞ¬ÞÞ°ÞÞ¬ÞÞ°ÞÞ¦ÞÞª',
              'ÞÞ®ÞÞ°ÞÞ¯ÞÞ¦ÞÞª',
              'ÞÞ®ÞÞ¬ÞÞ°ÞÞ¦ÞÞª',
              'ÞÞ¨ÞÞ¬ÞÞ°ÞÞ¦ÞÞª',
          ],
          weekdays = [
              'ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦',
              'ÞÞ¯ÞÞ¦',
              'ÞÞ¦ÞÞ°ÞÞ§ÞÞ¦',
              'ÞÞªÞÞ¦',
              'ÞÞªÞÞ§ÞÞ°ÞÞ¦ÞÞ¨',
              'ÞÞªÞÞªÞÞª',
              'ÞÞ®ÞÞ¨ÞÞ¨ÞÞª',
          ];

      hooks.defineLocale('dv', {
          months: months$5,
          monthsShort: months$5,
          weekdays: weekdays,
          weekdaysShort: weekdays,
          weekdaysMin: 'ÞÞ§ÞÞ¨_ÞÞ¯ÞÞ¦_ÞÞ¦ÞÞ°_ÞÞªÞÞ¦_ÞÞªÞÞ§_ÞÞªÞÞª_ÞÞ®ÞÞ¨'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'D/M/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          meridiemParse: /ÞÞ|ÞÞ/,
          isPM: function (input) {
              return 'ÞÞ' === input;
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'ÞÞ';
              } else {
                  return 'ÞÞ';
              }
          },
          calendar: {
              sameDay: '[ÞÞ¨ÞÞ¦ÞÞª] LT',
              nextDay: '[ÞÞ§ÞÞ¦ÞÞ§] LT',
              nextWeek: 'dddd LT',
              lastDay: '[ÞÞ¨ÞÞ°ÞÞ¬] LT',
              lastWeek: '[ÞÞ§ÞÞ¨ÞÞªÞÞ¨] dddd LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÞÞ¬ÞÞ­ÞÞ¦ÞÞ¨ %s',
              past: 'ÞÞªÞÞ¨ÞÞ° %s',
              s: 'ÞÞ¨ÞÞªÞÞ°ÞÞªÞÞ®ÞÞ¬ÞÞ°',
              ss: 'd% ÞÞ¨ÞÞªÞÞ°ÞÞª',
              m: 'ÞÞ¨ÞÞ¨ÞÞ¬ÞÞ°',
              mm: 'ÞÞ¨ÞÞ¨ÞÞª %d',
              h: 'ÞÞ¦ÞÞ¨ÞÞ¨ÞÞ¬ÞÞ°',
              hh: 'ÞÞ¦ÞÞ¨ÞÞ¨ÞÞª %d',
              d: 'ÞÞªÞÞ¦ÞÞ¬ÞÞ°',
              dd: 'ÞÞªÞÞ¦ÞÞ° %d',
              M: 'ÞÞ¦ÞÞ¬ÞÞ°',
              MM: 'ÞÞ¦ÞÞ° %d',
              y: 'ÞÞ¦ÞÞ¦ÞÞ¬ÞÞ°',
              yy: 'ÞÞ¦ÞÞ¦ÞÞª %d',
          },
          preparse: function (string) {
              return string.replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string.replace(/,/g, 'Ø');
          },
          week: {
              dow: 7, // Sunday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function isFunction$1(input) {
          return (
              (typeof Function !== 'undefined' && input instanceof Function) ||
              Object.prototype.toString.call(input) === '[object Function]'
          );
      }

      hooks.defineLocale('el', {
          monthsNominativeEl: 'ÎÎ±Î½Î¿ÏÎ¬ÏÎ¹Î¿Ï_Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï_ÎÎ¬ÏÏÎ¹Î¿Ï_ÎÏÏÎ¯Î»Î¹Î¿Ï_ÎÎ¬Î¹Î¿Ï_ÎÎ¿ÏÎ½Î¹Î¿Ï_ÎÎ¿ÏÎ»Î¹Î¿Ï_ÎÏÎ³Î¿ÏÏÏÎ¿Ï_Î£ÎµÏÏÎ­Î¼Î²ÏÎ¹Î¿Ï_ÎÎºÏÏÎ²ÏÎ¹Î¿Ï_ÎÎ¿Î­Î¼Î²ÏÎ¹Î¿Ï_ÎÎµÎºÎ­Î¼Î²ÏÎ¹Î¿Ï'.split(
              '_'
          ),
          monthsGenitiveEl: 'ÎÎ±Î½Î¿ÏÎ±ÏÎ¯Î¿Ï_Î¦ÎµÎ²ÏÎ¿ÏÎ±ÏÎ¯Î¿Ï_ÎÎ±ÏÏÎ¯Î¿Ï_ÎÏÏÎ¹Î»Î¯Î¿Ï_ÎÎ±ÎÎ¿Ï_ÎÎ¿ÏÎ½Î¯Î¿Ï_ÎÎ¿ÏÎ»Î¯Î¿Ï_ÎÏÎ³Î¿ÏÏÏÎ¿Ï_Î£ÎµÏÏÎµÎ¼Î²ÏÎ¯Î¿Ï_ÎÎºÏÏÎ²ÏÎ¯Î¿Ï_ÎÎ¿ÎµÎ¼Î²ÏÎ¯Î¿Ï_ÎÎµÎºÎµÎ¼Î²ÏÎ¯Î¿Ï'.split(
              '_'
          ),
          months: function (momentToFormat, format) {
              if (!momentToFormat) {
                  return this._monthsNominativeEl;
              } else if (
                  typeof format === 'string' &&
                  /D/.test(format.substring(0, format.indexOf('MMMM')))
              ) {
                  // if there is a day number before 'MMMM'
                  return this._monthsGenitiveEl[momentToFormat.month()];
              } else {
                  return this._monthsNominativeEl[momentToFormat.month()];
              }
          },
          monthsShort: 'ÎÎ±Î½_Î¦ÎµÎ²_ÎÎ±Ï_ÎÏÏ_ÎÎ±Ï_ÎÎ¿ÏÎ½_ÎÎ¿ÏÎ»_ÎÏÎ³_Î£ÎµÏ_ÎÎºÏ_ÎÎ¿Îµ_ÎÎµÎº'.split('_'),
          weekdays: 'ÎÏÏÎ¹Î±ÎºÎ®_ÎÎµÏÏÎ­ÏÎ±_Î¤ÏÎ¯ÏÎ·_Î¤ÎµÏÎ¬ÏÏÎ·_Î Î­Î¼ÏÏÎ·_Î Î±ÏÎ±ÏÎºÎµÏÎ®_Î£Î¬Î²Î²Î±ÏÎ¿'.split(
              '_'
          ),
          weekdaysShort: 'ÎÏÏ_ÎÎµÏ_Î¤ÏÎ¹_Î¤ÎµÏ_Î ÎµÎ¼_Î Î±Ï_Î£Î±Î²'.split('_'),
          weekdaysMin: 'ÎÏ_ÎÎµ_Î¤Ï_Î¤Îµ_Î Îµ_Î Î±_Î£Î±'.split('_'),
          meridiem: function (hours, minutes, isLower) {
              if (hours > 11) {
                  return isLower ? 'Î¼Î¼' : 'ÎÎ';
              } else {
                  return isLower ? 'ÏÎ¼' : 'Î Î';
              }
          },
          isPM: function (input) {
              return (input + '').toLowerCase()[0] === 'Î¼';
          },
          meridiemParse: /[Î Î]\.?Î?\.?/i,
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY h:mm A',
              LLLL: 'dddd, D MMMM YYYY h:mm A',
          },
          calendarEl: {
              sameDay: '[Î£Î®Î¼ÎµÏÎ± {}] LT',
              nextDay: '[ÎÏÏÎ¹Î¿ {}] LT',
              nextWeek: 'dddd [{}] LT',
              lastDay: '[Î§Î¸ÎµÏ {}] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 6:
                          return '[ÏÎ¿ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿] dddd [{}] LT';
                      default:
                          return '[ÏÎ·Î½ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î·] dddd [{}] LT';
                  }
              },
              sameElse: 'L',
          },
          calendar: function (key, mom) {
              var output = this._calendarEl[key],
                  hours = mom && mom.hours();
              if (isFunction$1(output)) {
                  output = output.apply(mom);
              }
              return output.replace('{}', hours % 12 === 1 ? 'ÏÏÎ·' : 'ÏÏÎ¹Ï');
          },
          relativeTime: {
              future: 'ÏÎµ %s',
              past: '%s ÏÏÎ¹Î½',
              s: 'Î»Î¯Î³Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±',
              ss: '%d Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±',
              m: 'Î­Î½Î± Î»ÎµÏÏÏ',
              mm: '%d Î»ÎµÏÏÎ¬',
              h: 'Î¼Î¯Î± ÏÏÎ±',
              hh: '%d ÏÏÎµÏ',
              d: 'Î¼Î¯Î± Î¼Î­ÏÎ±',
              dd: '%d Î¼Î­ÏÎµÏ',
              M: 'Î­Î½Î±Ï Î¼Î®Î½Î±Ï',
              MM: '%d Î¼Î®Î½ÎµÏ',
              y: 'Î­Î½Î±Ï ÏÏÏÎ½Î¿Ï',
              yy: '%d ÏÏÏÎ½Î¹Î±',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Î·/,
          ordinal: '%dÎ·',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4st is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-au', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY h:mm A',
              LLLL: 'dddd, D MMMM YYYY h:mm A',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-ca', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'YYYY-MM-DD',
              LL: 'MMMM D, YYYY',
              LLL: 'MMMM D, YYYY h:mm A',
              LLLL: 'dddd, MMMM D, YYYY h:mm A',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-gb', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-ie', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-il', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-in', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY h:mm A',
              LLLL: 'dddd, D MMMM YYYY h:mm A',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 1st is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-nz', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY h:mm A',
              LLLL: 'dddd, D MMMM YYYY h:mm A',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('en-sg', {
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('eo', {
          months: 'januaro_februaro_marto_aprilo_majo_junio_julio_aÅ­gusto_septembro_oktobro_novembro_decembro'.split(
              '_'
          ),
          monthsShort: 'jan_feb_mart_apr_maj_jun_jul_aÅ­g_sept_okt_nov_dec'.split('_'),
          weekdays: 'dimanÄo_lundo_mardo_merkredo_ÄµaÅ­do_vendredo_sabato'.split('_'),
          weekdaysShort: 'dim_lun_mard_merk_ÄµaÅ­_ven_sab'.split('_'),
          weekdaysMin: 'di_lu_ma_me_Äµa_ve_sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY-MM-DD',
              LL: '[la] D[-an de] MMMM, YYYY',
              LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
              LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
              llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm',
          },
          meridiemParse: /[ap]\.t\.m/i,
          isPM: function (input) {
              return input.charAt(0).toLowerCase() === 'p';
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours > 11) {
                  return isLower ? 'p.t.m.' : 'P.T.M.';
              } else {
                  return isLower ? 'a.t.m.' : 'A.T.M.';
              }
          },
          calendar: {
              sameDay: '[HodiaÅ­ je] LT',
              nextDay: '[MorgaÅ­ je] LT',
              nextWeek: 'dddd[n je] LT',
              lastDay: '[HieraÅ­ je] LT',
              lastWeek: '[pasintan] dddd[n je] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'post %s',
              past: 'antaÅ­ %s',
              s: 'kelkaj sekundoj',
              ss: '%d sekundoj',
              m: 'unu minuto',
              mm: '%d minutoj',
              h: 'unu horo',
              hh: '%d horoj',
              d: 'unu tago', //ne 'diurno', Äar estas uzita por proksimumo
              dd: '%d tagoj',
              M: 'unu monato',
              MM: '%d monatoj',
              y: 'unu jaro',
              yy: '%d jaroj',
          },
          dayOfMonthOrdinalParse: /\d{1,2}a/,
          ordinal: '%da',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
              '_'
          ),
          monthsShort$1 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
          monthsParse$2 = [
              /^ene/i,
              /^feb/i,
              /^mar/i,
              /^abr/i,
              /^may/i,
              /^jun/i,
              /^jul/i,
              /^ago/i,
              /^sep/i,
              /^oct/i,
              /^nov/i,
              /^dic/i,
          ],
          monthsRegex$3 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

      hooks.defineLocale('es-do', {
          months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortDot;
              } else if (/-MMM-/.test(format)) {
                  return monthsShort$1[m.month()];
              } else {
                  return monthsShortDot[m.month()];
              }
          },
          monthsRegex: monthsRegex$3,
          monthsShortRegex: monthsRegex$3,
          monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
          monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
          monthsParse: monthsParse$2,
          longMonthsParse: monthsParse$2,
          shortMonthsParse: monthsParse$2,
          weekdays: 'domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado'.split('_'),
          weekdaysShort: 'dom._lun._mar._miÃ©._jue._vie._sÃ¡b.'.split('_'),
          weekdaysMin: 'do_lu_ma_mi_ju_vi_sÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'DD/MM/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY h:mm A',
              LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
          },
          calendar: {
              sameDay: function () {
                  return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextDay: function () {
                  return '[maÃ±ana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextWeek: function () {
                  return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastDay: function () {
                  return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastWeek: function () {
                  return (
                      '[el] dddd [pasado a la' +
                      (this.hours() !== 1 ? 's' : '') +
                      '] LT'
                  );
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'en %s',
              past: 'hace %s',
              s: 'unos segundos',
              ss: '%d segundos',
              m: 'un minuto',
              mm: '%d minutos',
              h: 'una hora',
              hh: '%d horas',
              d: 'un dÃ­a',
              dd: '%d dÃ­as',
              w: 'una semana',
              ww: '%d semanas',
              M: 'un mes',
              MM: '%d meses',
              y: 'un aÃ±o',
              yy: '%d aÃ±os',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsShortDot$1 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
              '_'
          ),
          monthsShort$2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
          monthsParse$3 = [
              /^ene/i,
              /^feb/i,
              /^mar/i,
              /^abr/i,
              /^may/i,
              /^jun/i,
              /^jul/i,
              /^ago/i,
              /^sep/i,
              /^oct/i,
              /^nov/i,
              /^dic/i,
          ],
          monthsRegex$4 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

      hooks.defineLocale('es-mx', {
          months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortDot$1;
              } else if (/-MMM-/.test(format)) {
                  return monthsShort$2[m.month()];
              } else {
                  return monthsShortDot$1[m.month()];
              }
          },
          monthsRegex: monthsRegex$4,
          monthsShortRegex: monthsRegex$4,
          monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
          monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
          monthsParse: monthsParse$3,
          longMonthsParse: monthsParse$3,
          shortMonthsParse: monthsParse$3,
          weekdays: 'domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado'.split('_'),
          weekdaysShort: 'dom._lun._mar._miÃ©._jue._vie._sÃ¡b.'.split('_'),
          weekdaysMin: 'do_lu_ma_mi_ju_vi_sÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY H:mm',
              LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
          },
          calendar: {
              sameDay: function () {
                  return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextDay: function () {
                  return '[maÃ±ana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextWeek: function () {
                  return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastDay: function () {
                  return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastWeek: function () {
                  return (
                      '[el] dddd [pasado a la' +
                      (this.hours() !== 1 ? 's' : '') +
                      '] LT'
                  );
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'en %s',
              past: 'hace %s',
              s: 'unos segundos',
              ss: '%d segundos',
              m: 'un minuto',
              mm: '%d minutos',
              h: 'una hora',
              hh: '%d horas',
              d: 'un dÃ­a',
              dd: '%d dÃ­as',
              w: 'una semana',
              ww: '%d semanas',
              M: 'un mes',
              MM: '%d meses',
              y: 'un aÃ±o',
              yy: '%d aÃ±os',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
          invalidDate: 'Fecha invÃ¡lida',
      });

      //! moment.js locale configuration

      var monthsShortDot$2 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
              '_'
          ),
          monthsShort$3 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
          monthsParse$4 = [
              /^ene/i,
              /^feb/i,
              /^mar/i,
              /^abr/i,
              /^may/i,
              /^jun/i,
              /^jul/i,
              /^ago/i,
              /^sep/i,
              /^oct/i,
              /^nov/i,
              /^dic/i,
          ],
          monthsRegex$5 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

      hooks.defineLocale('es-us', {
          months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortDot$2;
              } else if (/-MMM-/.test(format)) {
                  return monthsShort$3[m.month()];
              } else {
                  return monthsShortDot$2[m.month()];
              }
          },
          monthsRegex: monthsRegex$5,
          monthsShortRegex: monthsRegex$5,
          monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
          monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
          monthsParse: monthsParse$4,
          longMonthsParse: monthsParse$4,
          shortMonthsParse: monthsParse$4,
          weekdays: 'domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado'.split('_'),
          weekdaysShort: 'dom._lun._mar._miÃ©._jue._vie._sÃ¡b.'.split('_'),
          weekdaysMin: 'do_lu_ma_mi_ju_vi_sÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'MM/DD/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY h:mm A',
              LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
          },
          calendar: {
              sameDay: function () {
                  return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextDay: function () {
                  return '[maÃ±ana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextWeek: function () {
                  return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastDay: function () {
                  return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastWeek: function () {
                  return (
                      '[el] dddd [pasado a la' +
                      (this.hours() !== 1 ? 's' : '') +
                      '] LT'
                  );
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'en %s',
              past: 'hace %s',
              s: 'unos segundos',
              ss: '%d segundos',
              m: 'un minuto',
              mm: '%d minutos',
              h: 'una hora',
              hh: '%d horas',
              d: 'un dÃ­a',
              dd: '%d dÃ­as',
              w: 'una semana',
              ww: '%d semanas',
              M: 'un mes',
              MM: '%d meses',
              y: 'un aÃ±o',
              yy: '%d aÃ±os',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsShortDot$3 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
              '_'
          ),
          monthsShort$4 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
          monthsParse$5 = [
              /^ene/i,
              /^feb/i,
              /^mar/i,
              /^abr/i,
              /^may/i,
              /^jun/i,
              /^jul/i,
              /^ago/i,
              /^sep/i,
              /^oct/i,
              /^nov/i,
              /^dic/i,
          ],
          monthsRegex$6 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

      hooks.defineLocale('es', {
          months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortDot$3;
              } else if (/-MMM-/.test(format)) {
                  return monthsShort$4[m.month()];
              } else {
                  return monthsShortDot$3[m.month()];
              }
          },
          monthsRegex: monthsRegex$6,
          monthsShortRegex: monthsRegex$6,
          monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
          monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
          monthsParse: monthsParse$5,
          longMonthsParse: monthsParse$5,
          shortMonthsParse: monthsParse$5,
          weekdays: 'domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado'.split('_'),
          weekdaysShort: 'dom._lun._mar._miÃ©._jue._vie._sÃ¡b.'.split('_'),
          weekdaysMin: 'do_lu_ma_mi_ju_vi_sÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY H:mm',
              LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
          },
          calendar: {
              sameDay: function () {
                  return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextDay: function () {
                  return '[maÃ±ana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextWeek: function () {
                  return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastDay: function () {
                  return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastWeek: function () {
                  return (
                      '[el] dddd [pasado a la' +
                      (this.hours() !== 1 ? 's' : '') +
                      '] LT'
                  );
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'en %s',
              past: 'hace %s',
              s: 'unos segundos',
              ss: '%d segundos',
              m: 'un minuto',
              mm: '%d minutos',
              h: 'una hora',
              hh: '%d horas',
              d: 'un dÃ­a',
              dd: '%d dÃ­as',
              w: 'una semana',
              ww: '%d semanas',
              M: 'un mes',
              MM: '%d meses',
              y: 'un aÃ±o',
              yy: '%d aÃ±os',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
          invalidDate: 'Fecha invÃ¡lida',
      });

      //! moment.js locale configuration

      function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
          var format = {
              s: ['mÃµne sekundi', 'mÃµni sekund', 'paar sekundit'],
              ss: [number + 'sekundi', number + 'sekundit'],
              m: ['Ã¼he minuti', 'Ã¼ks minut'],
              mm: [number + ' minuti', number + ' minutit'],
              h: ['Ã¼he tunni', 'tund aega', 'Ã¼ks tund'],
              hh: [number + ' tunni', number + ' tundi'],
              d: ['Ã¼he pÃ¤eva', 'Ã¼ks pÃ¤ev'],
              M: ['kuu aja', 'kuu aega', 'Ã¼ks kuu'],
              MM: [number + ' kuu', number + ' kuud'],
              y: ['Ã¼he aasta', 'aasta', 'Ã¼ks aasta'],
              yy: [number + ' aasta', number + ' aastat'],
          };
          if (withoutSuffix) {
              return format[key][2] ? format[key][2] : format[key][1];
          }
          return isFuture ? format[key][0] : format[key][1];
      }

      hooks.defineLocale('et', {
          months: 'jaanuar_veebruar_mÃ¤rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split(
              '_'
          ),
          monthsShort: 'jaan_veebr_mÃ¤rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split(
              '_'
          ),
          weekdays: 'pÃ¼hapÃ¤ev_esmaspÃ¤ev_teisipÃ¤ev_kolmapÃ¤ev_neljapÃ¤ev_reede_laupÃ¤ev'.split(
              '_'
          ),
          weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
          weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY H:mm',
              LLLL: 'dddd, D. MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[TÃ¤na,] LT',
              nextDay: '[Homme,] LT',
              nextWeek: '[JÃ¤rgmine] dddd LT',
              lastDay: '[Eile,] LT',
              lastWeek: '[Eelmine] dddd LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s pÃ¤rast',
              past: '%s tagasi',
              s: processRelativeTime$3,
              ss: processRelativeTime$3,
              m: processRelativeTime$3,
              mm: processRelativeTime$3,
              h: processRelativeTime$3,
              hh: processRelativeTime$3,
              d: processRelativeTime$3,
              dd: '%d pÃ¤eva',
              M: processRelativeTime$3,
              MM: processRelativeTime$3,
              y: processRelativeTime$3,
              yy: processRelativeTime$3,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('eu', {
          months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split(
              '_'
          ),
          monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split(
              '_'
          ),
          weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
          weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY-MM-DD',
              LL: 'YYYY[ko] MMMM[ren] D[a]',
              LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
              LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
              l: 'YYYY-M-D',
              ll: 'YYYY[ko] MMM D[a]',
              lll: 'YYYY[ko] MMM D[a] HH:mm',
              llll: 'ddd, YYYY[ko] MMM D[a] HH:mm',
          },
          calendar: {
              sameDay: '[gaur] LT[etan]',
              nextDay: '[bihar] LT[etan]',
              nextWeek: 'dddd LT[etan]',
              lastDay: '[atzo] LT[etan]',
              lastWeek: '[aurreko] dddd LT[etan]',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s barru',
              past: 'duela %s',
              s: 'segundo batzuk',
              ss: '%d segundo',
              m: 'minutu bat',
              mm: '%d minutu',
              h: 'ordu bat',
              hh: '%d ordu',
              d: 'egun bat',
              dd: '%d egun',
              M: 'hilabete bat',
              MM: '%d hilabete',
              y: 'urte bat',
              yy: '%d urte',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$6 = {
              1: 'Û±',
              2: 'Û²',
              3: 'Û³',
              4: 'Û´',
              5: 'Ûµ',
              6: 'Û¶',
              7: 'Û·',
              8: 'Û¸',
              9: 'Û¹',
              0: 'Û°',
          },
          numberMap$5 = {
              'Û±': '1',
              'Û²': '2',
              'Û³': '3',
              'Û´': '4',
              'Ûµ': '5',
              'Û¶': '6',
              'Û·': '7',
              'Û¸': '8',
              'Û¹': '9',
              'Û°': '0',
          };

      hooks.defineLocale('fa', {
          months: 'ÚØ§ÙÙÛÙ_ÙÙØ±ÛÙ_ÙØ§Ø±Ø³_Ø¢ÙØ±ÛÙ_ÙÙ_ÚÙØ¦Ù_ÚÙØ¦ÛÙ_Ø§ÙØª_Ø³Ù¾ØªØ§ÙØ¨Ø±_Ø§Ú©ØªØ¨Ø±_ÙÙØ§ÙØ¨Ø±_Ø¯Ø³Ø§ÙØ¨Ø±'.split(
              '_'
          ),
          monthsShort: 'ÚØ§ÙÙÛÙ_ÙÙØ±ÛÙ_ÙØ§Ø±Ø³_Ø¢ÙØ±ÛÙ_ÙÙ_ÚÙØ¦Ù_ÚÙØ¦ÛÙ_Ø§ÙØª_Ø³Ù¾ØªØ§ÙØ¨Ø±_Ø§Ú©ØªØ¨Ø±_ÙÙØ§ÙØ¨Ø±_Ø¯Ø³Ø§ÙØ¨Ø±'.split(
              '_'
          ),
          weekdays: 'ÛÚ©\u200cØ´ÙØ¨Ù_Ø¯ÙØ´ÙØ¨Ù_Ø³Ù\u200cØ´ÙØ¨Ù_ÚÙØ§Ø±Ø´ÙØ¨Ù_Ù¾ÙØ¬\u200cØ´ÙØ¨Ù_Ø¬ÙØ¹Ù_Ø´ÙØ¨Ù'.split(
              '_'
          ),
          weekdaysShort: 'ÛÚ©\u200cØ´ÙØ¨Ù_Ø¯ÙØ´ÙØ¨Ù_Ø³Ù\u200cØ´ÙØ¨Ù_ÚÙØ§Ø±Ø´ÙØ¨Ù_Ù¾ÙØ¬\u200cØ´ÙØ¨Ù_Ø¬ÙØ¹Ù_Ø´ÙØ¨Ù'.split(
              '_'
          ),
          weekdaysMin: 'Û_Ø¯_Ø³_Ú_Ù¾_Ø¬_Ø´'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          meridiemParse: /ÙØ¨Ù Ø§Ø² Ø¸ÙØ±|Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±/,
          isPM: function (input) {
              return /Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±/.test(input);
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'ÙØ¨Ù Ø§Ø² Ø¸ÙØ±';
              } else {
                  return 'Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±';
              }
          },
          calendar: {
              sameDay: '[Ø§ÙØ±ÙØ² Ø³Ø§Ø¹Øª] LT',
              nextDay: '[ÙØ±Ø¯Ø§ Ø³Ø§Ø¹Øª] LT',
              nextWeek: 'dddd [Ø³Ø§Ø¹Øª] LT',
              lastDay: '[Ø¯ÛØ±ÙØ² Ø³Ø§Ø¹Øª] LT',
              lastWeek: 'dddd [Ù¾ÛØ´] [Ø³Ø§Ø¹Øª] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ø¯Ø± %s',
              past: '%s Ù¾ÛØ´',
              s: 'ÚÙØ¯ Ø«Ø§ÙÛÙ',
              ss: '%d Ø«Ø§ÙÛÙ',
              m: 'ÛÚ© Ø¯ÙÛÙÙ',
              mm: '%d Ø¯ÙÛÙÙ',
              h: 'ÛÚ© Ø³Ø§Ø¹Øª',
              hh: '%d Ø³Ø§Ø¹Øª',
              d: 'ÛÚ© Ø±ÙØ²',
              dd: '%d Ø±ÙØ²',
              M: 'ÛÚ© ÙØ§Ù',
              MM: '%d ÙØ§Ù',
              y: 'ÛÚ© Ø³Ø§Ù',
              yy: '%d Ø³Ø§Ù',
          },
          preparse: function (string) {
              return string
                  .replace(/[Û°-Û¹]/g, function (match) {
                      return numberMap$5[match];
                  })
                  .replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string
                  .replace(/\d/g, function (match) {
                      return symbolMap$6[match];
                  })
                  .replace(/,/g, 'Ø');
          },
          dayOfMonthOrdinalParse: /\d{1,2}Ù/,
          ordinal: '%dÙ',
          week: {
              dow: 6, // Saturday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var numbersPast = 'nolla yksi kaksi kolme neljÃ¤ viisi kuusi seitsemÃ¤n kahdeksan yhdeksÃ¤n'.split(
              ' '
          ),
          numbersFuture = [
              'nolla',
              'yhden',
              'kahden',
              'kolmen',
              'neljÃ¤n',
              'viiden',
              'kuuden',
              numbersPast[7],
              numbersPast[8],
              numbersPast[9],
          ];
      function translate$2(number, withoutSuffix, key, isFuture) {
          var result = '';
          switch (key) {
              case 's':
                  return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
              case 'ss':
                  result = isFuture ? 'sekunnin' : 'sekuntia';
                  break;
              case 'm':
                  return isFuture ? 'minuutin' : 'minuutti';
              case 'mm':
                  result = isFuture ? 'minuutin' : 'minuuttia';
                  break;
              case 'h':
                  return isFuture ? 'tunnin' : 'tunti';
              case 'hh':
                  result = isFuture ? 'tunnin' : 'tuntia';
                  break;
              case 'd':
                  return isFuture ? 'pÃ¤ivÃ¤n' : 'pÃ¤ivÃ¤';
              case 'dd':
                  result = isFuture ? 'pÃ¤ivÃ¤n' : 'pÃ¤ivÃ¤Ã¤';
                  break;
              case 'M':
                  return isFuture ? 'kuukauden' : 'kuukausi';
              case 'MM':
                  result = isFuture ? 'kuukauden' : 'kuukautta';
                  break;
              case 'y':
                  return isFuture ? 'vuoden' : 'vuosi';
              case 'yy':
                  result = isFuture ? 'vuoden' : 'vuotta';
                  break;
          }
          result = verbalNumber(number, isFuture) + ' ' + result;
          return result;
      }
      function verbalNumber(number, isFuture) {
          return number < 10
              ? isFuture
                  ? numbersFuture[number]
                  : numbersPast[number]
              : number;
      }

      hooks.defineLocale('fi', {
          months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesÃ¤kuu_heinÃ¤kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split(
              '_'
          ),
          monthsShort: 'tammi_helmi_maalis_huhti_touko_kesÃ¤_heinÃ¤_elo_syys_loka_marras_joulu'.split(
              '_'
          ),
          weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split(
              '_'
          ),
          weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
          weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
          longDateFormat: {
              LT: 'HH.mm',
              LTS: 'HH.mm.ss',
              L: 'DD.MM.YYYY',
              LL: 'Do MMMM[ta] YYYY',
              LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
              LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
              l: 'D.M.YYYY',
              ll: 'Do MMM YYYY',
              lll: 'Do MMM YYYY, [klo] HH.mm',
              llll: 'ddd, Do MMM YYYY, [klo] HH.mm',
          },
          calendar: {
              sameDay: '[tÃ¤nÃ¤Ã¤n] [klo] LT',
              nextDay: '[huomenna] [klo] LT',
              nextWeek: 'dddd [klo] LT',
              lastDay: '[eilen] [klo] LT',
              lastWeek: '[viime] dddd[na] [klo] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s pÃ¤Ã¤stÃ¤',
              past: '%s sitten',
              s: translate$2,
              ss: translate$2,
              m: translate$2,
              mm: translate$2,
              h: translate$2,
              hh: translate$2,
              d: translate$2,
              dd: translate$2,
              M: translate$2,
              MM: translate$2,
              y: translate$2,
              yy: translate$2,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('fil', {
          months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
              '_'
          ),
          monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
          weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
              '_'
          ),
          weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
          weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'MM/D/YYYY',
              LL: 'MMMM D, YYYY',
              LLL: 'MMMM D, YYYY HH:mm',
              LLLL: 'dddd, MMMM DD, YYYY HH:mm',
          },
          calendar: {
              sameDay: 'LT [ngayong araw]',
              nextDay: '[Bukas ng] LT',
              nextWeek: 'LT [sa susunod na] dddd',
              lastDay: 'LT [kahapon]',
              lastWeek: 'LT [noong nakaraang] dddd',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'sa loob ng %s',
              past: '%s ang nakalipas',
              s: 'ilang segundo',
              ss: '%d segundo',
              m: 'isang minuto',
              mm: '%d minuto',
              h: 'isang oras',
              hh: '%d oras',
              d: 'isang araw',
              dd: '%d araw',
              M: 'isang buwan',
              MM: '%d buwan',
              y: 'isang taon',
              yy: '%d taon',
          },
          dayOfMonthOrdinalParse: /\d{1,2}/,
          ordinal: function (number) {
              return number;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('fo', {
          months: 'januar_februar_mars_aprÃ­l_mai_juni_juli_august_september_oktober_november_desember'.split(
              '_'
          ),
          monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
          weekdays: 'sunnudagur_mÃ¡nadagur_tÃ½sdagur_mikudagur_hÃ³sdagur_frÃ­ggjadagur_leygardagur'.split(
              '_'
          ),
          weekdaysShort: 'sun_mÃ¡n_tÃ½s_mik_hÃ³s_frÃ­_ley'.split('_'),
          weekdaysMin: 'su_mÃ¡_tÃ½_mi_hÃ³_fr_le'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D. MMMM, YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Ã dag kl.] LT',
              nextDay: '[Ã morgin kl.] LT',
              nextWeek: 'dddd [kl.] LT',
              lastDay: '[Ã gjÃ¡r kl.] LT',
              lastWeek: '[sÃ­Ã°stu] dddd [kl] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'um %s',
              past: '%s sÃ­Ã°ani',
              s: 'fÃ¡ sekund',
              ss: '%d sekundir',
              m: 'ein minuttur',
              mm: '%d minuttir',
              h: 'ein tÃ­mi',
              hh: '%d tÃ­mar',
              d: 'ein dagur',
              dd: '%d dagar',
              M: 'ein mÃ¡naÃ°ur',
              MM: '%d mÃ¡naÃ°ir',
              y: 'eitt Ã¡r',
              yy: '%d Ã¡r',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('fr-ca', {
          months: 'janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre'.split(
              '_'
          ),
          monthsShort: 'janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
          weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
          weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY-MM-DD',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Aujourdâhui Ã ] LT',
              nextDay: '[Demain Ã ] LT',
              nextWeek: 'dddd [Ã ] LT',
              lastDay: '[Hier Ã ] LT',
              lastWeek: 'dddd [dernier Ã ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'dans %s',
              past: 'il y a %s',
              s: 'quelques secondes',
              ss: '%d secondes',
              m: 'une minute',
              mm: '%d minutes',
              h: 'une heure',
              hh: '%d heures',
              d: 'un jour',
              dd: '%d jours',
              M: 'un mois',
              MM: '%d mois',
              y: 'un an',
              yy: '%d ans',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
          ordinal: function (number, period) {
              switch (period) {
                  // Words with masculine grammatical gender: mois, trimestre, jour
                  default:
                  case 'M':
                  case 'Q':
                  case 'D':
                  case 'DDD':
                  case 'd':
                      return number + (number === 1 ? 'er' : 'e');

                  // Words with feminine grammatical gender: semaine
                  case 'w':
                  case 'W':
                      return number + (number === 1 ? 're' : 'e');
              }
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('fr-ch', {
          months: 'janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre'.split(
              '_'
          ),
          monthsShort: 'janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
          weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
          weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Aujourdâhui Ã ] LT',
              nextDay: '[Demain Ã ] LT',
              nextWeek: 'dddd [Ã ] LT',
              lastDay: '[Hier Ã ] LT',
              lastWeek: 'dddd [dernier Ã ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'dans %s',
              past: 'il y a %s',
              s: 'quelques secondes',
              ss: '%d secondes',
              m: 'une minute',
              mm: '%d minutes',
              h: 'une heure',
              hh: '%d heures',
              d: 'un jour',
              dd: '%d jours',
              M: 'un mois',
              MM: '%d mois',
              y: 'un an',
              yy: '%d ans',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
          ordinal: function (number, period) {
              switch (period) {
                  // Words with masculine grammatical gender: mois, trimestre, jour
                  default:
                  case 'M':
                  case 'Q':
                  case 'D':
                  case 'DDD':
                  case 'd':
                      return number + (number === 1 ? 'er' : 'e');

                  // Words with feminine grammatical gender: semaine
                  case 'w':
                  case 'W':
                      return number + (number === 1 ? 're' : 'e');
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsStrictRegex$1 = /^(janvier|fÃ©vrier|mars|avril|mai|juin|juillet|aoÃ»t|septembre|octobre|novembre|dÃ©cembre)/i,
          monthsShortStrictRegex$1 = /(janv\.?|fÃ©vr\.?|mars|avr\.?|mai|juin|juil\.?|aoÃ»t|sept\.?|oct\.?|nov\.?|dÃ©c\.?)/i,
          monthsRegex$7 = /(janv\.?|fÃ©vr\.?|mars|avr\.?|mai|juin|juil\.?|aoÃ»t|sept\.?|oct\.?|nov\.?|dÃ©c\.?|janvier|fÃ©vrier|mars|avril|mai|juin|juillet|aoÃ»t|septembre|octobre|novembre|dÃ©cembre)/i,
          monthsParse$6 = [
              /^janv/i,
              /^fÃ©vr/i,
              /^mars/i,
              /^avr/i,
              /^mai/i,
              /^juin/i,
              /^juil/i,
              /^aoÃ»t/i,
              /^sept/i,
              /^oct/i,
              /^nov/i,
              /^dÃ©c/i,
          ];

      hooks.defineLocale('fr', {
          months: 'janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre'.split(
              '_'
          ),
          monthsShort: 'janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.'.split(
              '_'
          ),
          monthsRegex: monthsRegex$7,
          monthsShortRegex: monthsRegex$7,
          monthsStrictRegex: monthsStrictRegex$1,
          monthsShortStrictRegex: monthsShortStrictRegex$1,
          monthsParse: monthsParse$6,
          longMonthsParse: monthsParse$6,
          shortMonthsParse: monthsParse$6,
          weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
          weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
          weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Aujourdâhui Ã ] LT',
              nextDay: '[Demain Ã ] LT',
              nextWeek: 'dddd [Ã ] LT',
              lastDay: '[Hier Ã ] LT',
              lastWeek: 'dddd [dernier Ã ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'dans %s',
              past: 'il y a %s',
              s: 'quelques secondes',
              ss: '%d secondes',
              m: 'une minute',
              mm: '%d minutes',
              h: 'une heure',
              hh: '%d heures',
              d: 'un jour',
              dd: '%d jours',
              w: 'une semaine',
              ww: '%d semaines',
              M: 'un mois',
              MM: '%d mois',
              y: 'un an',
              yy: '%d ans',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
          ordinal: function (number, period) {
              switch (period) {
                  // TODO: Return 'e' when day of month > 1. Move this case inside
                  // block for masculine words below.
                  // See https://github.com/moment/moment/issues/3375
                  case 'D':
                      return number + (number === 1 ? 'er' : '');

                  // Words with masculine grammatical gender: mois, trimestre, jour
                  default:
                  case 'M':
                  case 'Q':
                  case 'DDD':
                  case 'd':
                      return number + (number === 1 ? 'er' : 'e');

                  // Words with feminine grammatical gender: semaine
                  case 'w':
                  case 'W':
                      return number + (number === 1 ? 're' : 'e');
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split(
              '_'
          ),
          monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split(
              '_'
          );

      hooks.defineLocale('fy', {
          months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortWithDots;
              } else if (/-MMM-/.test(format)) {
                  return monthsShortWithoutDots[m.month()];
              } else {
                  return monthsShortWithDots[m.month()];
              }
          },
          monthsParseExact: true,
          weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split(
              '_'
          ),
          weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
          weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD-MM-YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[hjoed om] LT',
              nextDay: '[moarn om] LT',
              nextWeek: 'dddd [om] LT',
              lastDay: '[juster om] LT',
              lastWeek: '[Ã´frÃ»ne] dddd [om] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'oer %s',
              past: '%s lyn',
              s: 'in pear sekonden',
              ss: '%d sekonden',
              m: 'ien minÃºt',
              mm: '%d minuten',
              h: 'ien oere',
              hh: '%d oeren',
              d: 'ien dei',
              dd: '%d dagen',
              M: 'ien moanne',
              MM: '%d moannen',
              y: 'ien jier',
              yy: '%d jierren',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
          ordinal: function (number) {
              return (
                  number +
                  (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
              );
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var months$6 = [
              'EanÃ¡ir',
              'Feabhra',
              'MÃ¡rta',
              'AibreÃ¡n',
              'Bealtaine',
              'Meitheamh',
              'IÃºil',
              'LÃºnasa',
              'MeÃ¡n FÃ³mhair',
              'Deireadh FÃ³mhair',
              'Samhain',
              'Nollaig',
          ],
          monthsShort$5 = [
              'Ean',
              'Feabh',
              'MÃ¡rt',
              'Aib',
              'Beal',
              'Meith',
              'IÃºil',
              'LÃºn',
              'M.F.',
              'D.F.',
              'Samh',
              'Noll',
          ],
          weekdays$1 = [
              'DÃ© Domhnaigh',
              'DÃ© Luain',
              'DÃ© MÃ¡irt',
              'DÃ© CÃ©adaoin',
              'DÃ©ardaoin',
              'DÃ© hAoine',
              'DÃ© Sathairn',
          ],
          weekdaysShort = ['Domh', 'Luan', 'MÃ¡irt', 'CÃ©ad', 'DÃ©ar', 'Aoine', 'Sath'],
          weekdaysMin = ['Do', 'Lu', 'MÃ¡', 'CÃ©', 'DÃ©', 'A', 'Sa'];

      hooks.defineLocale('ga', {
          months: months$6,
          monthsShort: monthsShort$5,
          monthsParseExact: true,
          weekdays: weekdays$1,
          weekdaysShort: weekdaysShort,
          weekdaysMin: weekdaysMin,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Inniu ag] LT',
              nextDay: '[AmÃ¡rach ag] LT',
              nextWeek: 'dddd [ag] LT',
              lastDay: '[InnÃ© ag] LT',
              lastWeek: 'dddd [seo caite] [ag] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'i %s',
              past: '%s Ã³ shin',
              s: 'cÃºpla soicind',
              ss: '%d soicind',
              m: 'nÃ³imÃ©ad',
              mm: '%d nÃ³imÃ©ad',
              h: 'uair an chloig',
              hh: '%d uair an chloig',
              d: 'lÃ¡',
              dd: '%d lÃ¡',
              M: 'mÃ­',
              MM: '%d mÃ­onna',
              y: 'bliain',
              yy: '%d bliain',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
          ordinal: function (number) {
              var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var months$7 = [
              'Am Faoilleach',
              'An Gearran',
              'Am MÃ rt',
              'An Giblean',
              'An CÃ¨itean',
              'An t-Ãgmhios',
              'An t-Iuchar',
              'An LÃ¹nastal',
              'An t-Sultain',
              'An DÃ mhair',
              'An t-Samhain',
              'An DÃ¹bhlachd',
          ],
          monthsShort$6 = [
              'Faoi',
              'Gear',
              'MÃ rt',
              'Gibl',
              'CÃ¨it',
              'Ãgmh',
              'Iuch',
              'LÃ¹n',
              'Sult',
              'DÃ mh',
              'Samh',
              'DÃ¹bh',
          ],
          weekdays$2 = [
              'DidÃ²mhnaich',
              'Diluain',
              'DimÃ irt',
              'Diciadain',
              'Diardaoin',
              'Dihaoine',
              'Disathairne',
          ],
          weekdaysShort$1 = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
          weekdaysMin$1 = ['DÃ²', 'Lu', 'MÃ ', 'Ci', 'Ar', 'Ha', 'Sa'];

      hooks.defineLocale('gd', {
          months: months$7,
          monthsShort: monthsShort$6,
          monthsParseExact: true,
          weekdays: weekdays$2,
          weekdaysShort: weekdaysShort$1,
          weekdaysMin: weekdaysMin$1,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[An-diugh aig] LT',
              nextDay: '[A-mÃ ireach aig] LT',
              nextWeek: 'dddd [aig] LT',
              lastDay: '[An-dÃ¨ aig] LT',
              lastWeek: 'dddd [seo chaidh] [aig] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ann an %s',
              past: 'bho chionn %s',
              s: 'beagan diogan',
              ss: '%d diogan',
              m: 'mionaid',
              mm: '%d mionaidean',
              h: 'uair',
              hh: '%d uairean',
              d: 'latha',
              dd: '%d latha',
              M: 'mÃ¬os',
              MM: '%d mÃ¬osan',
              y: 'bliadhna',
              yy: '%d bliadhna',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
          ordinal: function (number) {
              var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('gl', {
          months: 'xaneiro_febreiro_marzo_abril_maio_xuÃ±o_xullo_agosto_setembro_outubro_novembro_decembro'.split(
              '_'
          ),
          monthsShort: 'xan._feb._mar._abr._mai._xuÃ±._xul._ago._set._out._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'domingo_luns_martes_mÃ©rcores_xoves_venres_sÃ¡bado'.split('_'),
          weekdaysShort: 'dom._lun._mar._mÃ©r._xov._ven._sÃ¡b.'.split('_'),
          weekdaysMin: 'do_lu_ma_mÃ©_xo_ve_sÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY H:mm',
              LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
          },
          calendar: {
              sameDay: function () {
                  return '[hoxe ' + (this.hours() !== 1 ? 'Ã¡s' : 'Ã¡') + '] LT';
              },
              nextDay: function () {
                  return '[maÃ±Ã¡ ' + (this.hours() !== 1 ? 'Ã¡s' : 'Ã¡') + '] LT';
              },
              nextWeek: function () {
                  return 'dddd [' + (this.hours() !== 1 ? 'Ã¡s' : 'a') + '] LT';
              },
              lastDay: function () {
                  return '[onte ' + (this.hours() !== 1 ? 'Ã¡' : 'a') + '] LT';
              },
              lastWeek: function () {
                  return (
                      '[o] dddd [pasado ' + (this.hours() !== 1 ? 'Ã¡s' : 'a') + '] LT'
                  );
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: function (str) {
                  if (str.indexOf('un') === 0) {
                      return 'n' + str;
                  }
                  return 'en ' + str;
              },
              past: 'hai %s',
              s: 'uns segundos',
              ss: '%d segundos',
              m: 'un minuto',
              mm: '%d minutos',
              h: 'unha hora',
              hh: '%d horas',
              d: 'un dÃ­a',
              dd: '%d dÃ­as',
              M: 'un mes',
              MM: '%d meses',
              y: 'un ano',
              yy: '%d anos',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
          var format = {
              s: ['à¤¥à¥à¤¡à¤¯à¤¾ à¤¸à¥à¤à¤à¤¡à¤¾à¤à¤¨à¥', 'à¤¥à¥à¤¡à¥ à¤¸à¥à¤à¤à¤¡'],
              ss: [number + ' à¤¸à¥à¤à¤à¤¡à¤¾à¤à¤¨à¥', number + ' à¤¸à¥à¤à¤à¤¡'],
              m: ['à¤à¤à¤¾ à¤®à¤¿à¤£à¤à¤¾à¤¨', 'à¤à¤ à¤®à¤¿à¤¨à¥à¤'],
              mm: [number + ' à¤®à¤¿à¤£à¤à¤¾à¤à¤¨à¥', number + ' à¤®à¤¿à¤£à¤à¤¾à¤'],
              h: ['à¤à¤à¤¾ à¤µà¤°à¤¾à¤¨', 'à¤à¤ à¤µà¤°'],
              hh: [number + ' à¤µà¤°à¤¾à¤à¤¨à¥', number + ' à¤µà¤°à¤¾à¤'],
              d: ['à¤à¤à¤¾ à¤¦à¤¿à¤¸à¤¾à¤¨', 'à¤à¤ à¤¦à¥à¤¸'],
              dd: [number + ' à¤¦à¤¿à¤¸à¤¾à¤à¤¨à¥', number + ' à¤¦à¥à¤¸'],
              M: ['à¤à¤à¤¾ à¤®à¥à¤¹à¤¯à¤¨à¥à¤¯à¤¾à¤¨', 'à¤à¤ à¤®à¥à¤¹à¤¯à¤¨à¥'],
              MM: [number + ' à¤®à¥à¤¹à¤¯à¤¨à¥à¤¯à¤¾à¤¨à¥', number + ' à¤®à¥à¤¹à¤¯à¤¨à¥'],
              y: ['à¤à¤à¤¾ à¤µà¤°à¥à¤¸à¤¾à¤¨', 'à¤à¤ à¤µà¤°à¥à¤¸'],
              yy: [number + ' à¤µà¤°à¥à¤¸à¤¾à¤à¤¨à¥', number + ' à¤µà¤°à¥à¤¸à¤¾à¤'],
          };
          return isFuture ? format[key][0] : format[key][1];
      }

      hooks.defineLocale('gom-deva', {
          months: {
              standalone: 'à¤à¤¾à¤¨à¥à¤µà¤¾à¤°à¥_à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥à¤²_à¤®à¥_à¤à¥à¤¨_à¤à¥à¤²à¤¯_à¤à¤à¤¸à¥à¤_à¤¸à¤ªà¥à¤à¥à¤à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¥à¤µà¥à¤¹à¥à¤à¤¬à¤°_à¤¡à¤¿à¤¸à¥à¤à¤¬à¤°'.split(
                  '_'
              ),
              format: 'à¤à¤¾à¤¨à¥à¤µà¤¾à¤°à¥à¤à¥à¤¯à¤¾_à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥à¤à¥à¤¯à¤¾_à¤®à¤¾à¤°à¥à¤à¤¾à¤à¥à¤¯à¤¾_à¤à¤ªà¥à¤°à¥à¤²à¤¾à¤à¥à¤¯à¤¾_à¤®à¥à¤¯à¤¾à¤à¥à¤¯à¤¾_à¤à¥à¤¨à¤¾à¤à¥à¤¯à¤¾_à¤à¥à¤²à¤¯à¤¾à¤à¥à¤¯à¤¾_à¤à¤à¤¸à¥à¤à¤¾à¤à¥à¤¯à¤¾_à¤¸à¤ªà¥à¤à¥à¤à¤¬à¤°à¤¾à¤à¥à¤¯à¤¾_à¤à¤à¥à¤à¥à¤¬à¤°à¤¾à¤à¥à¤¯à¤¾_à¤¨à¥à¤µà¥à¤¹à¥à¤à¤¬à¤°à¤¾à¤à¥à¤¯à¤¾_à¤¡à¤¿à¤¸à¥à¤à¤¬à¤°à¤¾à¤à¥à¤¯à¤¾'.split(
                  '_'
              ),
              isFormat: /MMMM(\s)+D[oD]?/,
          },
          monthsShort: 'à¤à¤¾à¤¨à¥._à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥._à¤®à¥_à¤à¥à¤¨_à¤à¥à¤²._à¤à¤._à¤¸à¤ªà¥à¤à¥à¤._à¤à¤à¥à¤à¥._à¤¨à¥à¤µà¥à¤¹à¥à¤._à¤¡à¤¿à¤¸à¥à¤.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'à¤à¤¯à¤¤à¤¾à¤°_à¤¸à¥à¤®à¤¾à¤°_à¤®à¤à¤à¤³à¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤¬à¤¿à¤°à¥à¤¸à¥à¤¤à¤¾à¤°_à¤¸à¥à¤à¥à¤°à¤¾à¤°_à¤¶à¥à¤¨à¤µà¤¾à¤°'.split('_'),
          weekdaysShort: 'à¤à¤¯à¤¤._à¤¸à¥à¤®._à¤®à¤à¤à¤³._à¤¬à¥à¤§._à¤¬à¥à¤°à¥à¤¸à¥à¤¤._à¤¸à¥à¤à¥à¤°._à¤¶à¥à¤¨.'.split('_'),
          weekdaysMin: 'à¤_à¤¸à¥_à¤®à¤_à¤¬à¥_à¤¬à¥à¤°à¥_à¤¸à¥_à¤¶à¥'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'A h:mm [à¤µà¤¾à¤à¤¤à¤¾à¤]',
              LTS: 'A h:mm:ss [à¤µà¤¾à¤à¤¤à¤¾à¤]',
              L: 'DD-MM-YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY A h:mm [à¤µà¤¾à¤à¤¤à¤¾à¤]',
              LLLL: 'dddd, MMMM Do, YYYY, A h:mm [à¤µà¤¾à¤à¤¤à¤¾à¤]',
              llll: 'ddd, D MMM YYYY, A h:mm [à¤µà¤¾à¤à¤¤à¤¾à¤]',
          },
          calendar: {
              sameDay: '[à¤à¤¯à¤] LT',
              nextDay: '[à¤«à¤¾à¤²à¥à¤¯à¤¾à¤] LT',
              nextWeek: '[à¤«à¥à¤¡à¤²à¥] dddd[,] LT',
              lastDay: '[à¤à¤¾à¤²] LT',
              lastWeek: '[à¤«à¤¾à¤à¤²à¥] dddd[,] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s',
              past: '%s à¤à¤¦à¥à¤',
              s: processRelativeTime$4,
              ss: processRelativeTime$4,
              m: processRelativeTime$4,
              mm: processRelativeTime$4,
              h: processRelativeTime$4,
              hh: processRelativeTime$4,
              d: processRelativeTime$4,
              dd: processRelativeTime$4,
              M: processRelativeTime$4,
              MM: processRelativeTime$4,
              y: processRelativeTime$4,
              yy: processRelativeTime$4,
          },
          dayOfMonthOrdinalParse: /\d{1,2}(à¤µà¥à¤°)/,
          ordinal: function (number, period) {
              switch (period) {
                  // the ordinal 'à¤µà¥à¤°' only applies to day of the month
                  case 'D':
                      return number + 'à¤µà¥à¤°';
                  default:
                  case 'M':
                  case 'Q':
                  case 'DDD':
                  case 'd':
                  case 'w':
                  case 'W':
                      return number;
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week
              doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
          },
          meridiemParse: /à¤°à¤¾à¤¤à¥|à¤¸à¤à¤¾à¤³à¥à¤|à¤¦à¤¨à¤ªà¤¾à¤°à¤¾à¤|à¤¸à¤¾à¤à¤à¥/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à¤°à¤¾à¤¤à¥') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'à¤¸à¤à¤¾à¤³à¥à¤') {
                  return hour;
              } else if (meridiem === 'à¤¦à¤¨à¤ªà¤¾à¤°à¤¾à¤') {
                  return hour > 12 ? hour : hour + 12;
              } else if (meridiem === 'à¤¸à¤¾à¤à¤à¥') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à¤°à¤¾à¤¤à¥';
              } else if (hour < 12) {
                  return 'à¤¸à¤à¤¾à¤³à¥à¤';
              } else if (hour < 16) {
                  return 'à¤¦à¤¨à¤ªà¤¾à¤°à¤¾à¤';
              } else if (hour < 20) {
                  return 'à¤¸à¤¾à¤à¤à¥';
              } else {
                  return 'à¤°à¤¾à¤¤à¥';
              }
          },
      });

      //! moment.js locale configuration

      function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
          var format = {
              s: ['thoddea sekondamni', 'thodde sekond'],
              ss: [number + ' sekondamni', number + ' sekond'],
              m: ['eka mintan', 'ek minut'],
              mm: [number + ' mintamni', number + ' mintam'],
              h: ['eka voran', 'ek vor'],
              hh: [number + ' voramni', number + ' voram'],
              d: ['eka disan', 'ek dis'],
              dd: [number + ' disamni', number + ' dis'],
              M: ['eka mhoinean', 'ek mhoino'],
              MM: [number + ' mhoineamni', number + ' mhoine'],
              y: ['eka vorsan', 'ek voros'],
              yy: [number + ' vorsamni', number + ' vorsam'],
          };
          return isFuture ? format[key][0] : format[key][1];
      }

      hooks.defineLocale('gom-latn', {
          months: {
              standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split(
                  '_'
              ),
              format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split(
                  '_'
              ),
              isFormat: /MMMM(\s)+D[oD]?/,
          },
          monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
          weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
          weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'A h:mm [vazta]',
              LTS: 'A h:mm:ss [vazta]',
              L: 'DD-MM-YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY A h:mm [vazta]',
              LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
              llll: 'ddd, D MMM YYYY, A h:mm [vazta]',
          },
          calendar: {
              sameDay: '[Aiz] LT',
              nextDay: '[Faleam] LT',
              nextWeek: '[Fuddlo] dddd[,] LT',
              lastDay: '[Kal] LT',
              lastWeek: '[Fattlo] dddd[,] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s',
              past: '%s adim',
              s: processRelativeTime$5,
              ss: processRelativeTime$5,
              m: processRelativeTime$5,
              mm: processRelativeTime$5,
              h: processRelativeTime$5,
              hh: processRelativeTime$5,
              d: processRelativeTime$5,
              dd: processRelativeTime$5,
              M: processRelativeTime$5,
              MM: processRelativeTime$5,
              y: processRelativeTime$5,
              yy: processRelativeTime$5,
          },
          dayOfMonthOrdinalParse: /\d{1,2}(er)/,
          ordinal: function (number, period) {
              switch (period) {
                  // the ordinal 'er' only applies to day of the month
                  case 'D':
                      return number + 'er';
                  default:
                  case 'M':
                  case 'Q':
                  case 'DDD':
                  case 'd':
                  case 'w':
                  case 'W':
                      return number;
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week
              doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
          },
          meridiemParse: /rati|sokallim|donparam|sanje/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'rati') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'sokallim') {
                  return hour;
              } else if (meridiem === 'donparam') {
                  return hour > 12 ? hour : hour + 12;
              } else if (meridiem === 'sanje') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'rati';
              } else if (hour < 12) {
                  return 'sokallim';
              } else if (hour < 16) {
                  return 'donparam';
              } else if (hour < 20) {
                  return 'sanje';
              } else {
                  return 'rati';
              }
          },
      });

      //! moment.js locale configuration

      var symbolMap$7 = {
              1: 'à«§',
              2: 'à«¨',
              3: 'à«©',
              4: 'à«ª',
              5: 'à««',
              6: 'à«¬',
              7: 'à«­',
              8: 'à«®',
              9: 'à«¯',
              0: 'à«¦',
          },
          numberMap$6 = {
              'à«§': '1',
              'à«¨': '2',
              'à«©': '3',
              'à«ª': '4',
              'à««': '5',
              'à«¬': '6',
              'à«­': '7',
              'à«®': '8',
              'à«¯': '9',
              'à«¦': '0',
          };

      hooks.defineLocale('gu', {
          months: 'àªàª¾àª¨à«àª¯à«àªàª°à«_àª«à«àª¬à«àª°à«àªàª°à«_àª®àª¾àª°à«àª_àªàªªà«àª°àª¿àª²_àª®à«_àªà«àª¨_àªà«àª²àª¾àª_àªàªàª¸à«àª_àª¸àªªà«àªà«àª®à«àª¬àª°_àªàªà«àªà«àª¬àª°_àª¨àªµà«àª®à«àª¬àª°_àª¡àª¿àª¸à«àª®à«àª¬àª°'.split(
              '_'
          ),
          monthsShort: 'àªàª¾àª¨à«àª¯à«._àª«à«àª¬à«àª°à«._àª®àª¾àª°à«àª_àªàªªà«àª°àª¿._àª®à«_àªà«àª¨_àªà«àª²àª¾._àªàª._àª¸àªªà«àªà«._àªàªà«àªà«._àª¨àªµà«._àª¡àª¿àª¸à«.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'àª°àªµàª¿àªµàª¾àª°_àª¸à«àª®àªµàª¾àª°_àª®àªàªàª³àªµàª¾àª°_àª¬à«àª§à«àªµàª¾àª°_àªà«àª°à«àªµàª¾àª°_àª¶à«àªà«àª°àªµàª¾àª°_àª¶àª¨àª¿àªµàª¾àª°'.split(
              '_'
          ),
          weekdaysShort: 'àª°àªµàª¿_àª¸à«àª®_àª®àªàªàª³_àª¬à«àª§à«_àªà«àª°à«_àª¶à«àªà«àª°_àª¶àª¨àª¿'.split('_'),
          weekdaysMin: 'àª°_àª¸à«_àª®àª_àª¬à«_àªà«_àª¶à«_àª¶'.split('_'),
          longDateFormat: {
              LT: 'A h:mm àªµàª¾àªà«àª¯à«',
              LTS: 'A h:mm:ss àªµàª¾àªà«àª¯à«',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm àªµàª¾àªà«àª¯à«',
              LLLL: 'dddd, D MMMM YYYY, A h:mm àªµàª¾àªà«àª¯à«',
          },
          calendar: {
              sameDay: '[àªàª] LT',
              nextDay: '[àªàª¾àª²à«] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[àªàªàªàª¾àª²à«] LT',
              lastWeek: '[àªªàª¾àªàª²àª¾] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s àª®àª¾',
              past: '%s àªªàª¹à«àª²àª¾',
              s: 'àªàª®à«àª àªªàª³à«',
              ss: '%d àª¸à«àªàªàª¡',
              m: 'àªàª àª®àª¿àª¨àª¿àª',
              mm: '%d àª®àª¿àª¨àª¿àª',
              h: 'àªàª àªàª²àª¾àª',
              hh: '%d àªàª²àª¾àª',
              d: 'àªàª àª¦àª¿àªµàª¸',
              dd: '%d àª¦àª¿àªµàª¸',
              M: 'àªàª àª®àª¹àª¿àª¨à«',
              MM: '%d àª®àª¹àª¿àª¨à«',
              y: 'àªàª àªµàª°à«àª·',
              yy: '%d àªµàª°à«àª·',
          },
          preparse: function (string) {
              return string.replace(/[à«§à«¨à«©à«ªà««à«¬à«­à«®à«¯à«¦]/g, function (match) {
                  return numberMap$6[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$7[match];
              });
          },
          // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
          // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
          meridiemParse: /àª°àª¾àª¤|àª¬àªªà«àª°|àª¸àªµàª¾àª°|àª¸àª¾àªàª/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'àª°àª¾àª¤') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'àª¸àªµàª¾àª°') {
                  return hour;
              } else if (meridiem === 'àª¬àªªà«àª°') {
                  return hour >= 10 ? hour : hour + 12;
              } else if (meridiem === 'àª¸àª¾àªàª') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'àª°àª¾àª¤';
              } else if (hour < 10) {
                  return 'àª¸àªµàª¾àª°';
              } else if (hour < 17) {
                  return 'àª¬àªªà«àª°';
              } else if (hour < 20) {
                  return 'àª¸àª¾àªàª';
              } else {
                  return 'àª°àª¾àª¤';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('he', {
          months: '×× ×××¨_×¤××¨×××¨_××¨×¥_××¤×¨××_×××_××× ×_××××_×××××¡×_×¡×¤××××¨_×××§××××¨_× ×××××¨_××¦×××¨'.split(
              '_'
          ),
          monthsShort: '×× ××³_×¤××¨×³_××¨×¥_××¤×¨×³_×××_××× ×_××××_××××³_×¡×¤××³_×××§×³_× ×××³_××¦××³'.split(
              '_'
          ),
          weekdays: '×¨××©××_×©× ×_×©×××©×_×¨×××¢×_××××©×_×©××©×_×©××ª'.split('_'),
          weekdaysShort: '××³_××³_××³_××³_××³_××³_×©×³'.split('_'),
          weekdaysMin: '×_×_×_×_×_×_×©'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [×]MMMM YYYY',
              LLL: 'D [×]MMMM YYYY HH:mm',
              LLLL: 'dddd, D [×]MMMM YYYY HH:mm',
              l: 'D/M/YYYY',
              ll: 'D MMM YYYY',
              lll: 'D MMM YYYY HH:mm',
              llll: 'ddd, D MMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[×××× ×Ö¾]LT',
              nextDay: '[×××¨ ×Ö¾]LT',
              nextWeek: 'dddd [××©×¢×] LT',
              lastDay: '[××ª××× ×Ö¾]LT',
              lastWeek: '[××××] dddd [××××¨×× ××©×¢×] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '××¢×× %s',
              past: '××¤× × %s',
              s: '××¡×¤×¨ ×©× ×××ª',
              ss: '%d ×©× ×××ª',
              m: '××§×',
              mm: '%d ××§××ª',
              h: '×©×¢×',
              hh: function (number) {
                  if (number === 2) {
                      return '×©×¢×ª×××';
                  }
                  return number + ' ×©×¢××ª';
              },
              d: '×××',
              dd: function (number) {
                  if (number === 2) {
                      return '××××××';
                  }
                  return number + ' ××××';
              },
              M: '××××©',
              MM: function (number) {
                  if (number === 2) {
                      return '××××©×××';
                  }
                  return number + ' ××××©××';
              },
              y: '×©× ×',
              yy: function (number) {
                  if (number === 2) {
                      return '×©× ×ª×××';
                  } else if (number % 10 === 0 && number !== 10) {
                      return number + ' ×©× ×';
                  }
                  return number + ' ×©× ××';
              },
          },
          meridiemParse: /×××"×¦|××¤× ×"×¦|×××¨× ××¦××¨×××|××¤× × ××¦××¨×××|××¤× ××ª ×××§×¨|××××§×¨|××¢×¨×/i,
          isPM: function (input) {
              return /^(×××"×¦|×××¨× ××¦××¨×××|××¢×¨×)$/.test(input);
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 5) {
                  return '××¤× ××ª ×××§×¨';
              } else if (hour < 10) {
                  return '××××§×¨';
              } else if (hour < 12) {
                  return isLower ? '××¤× ×"×¦' : '××¤× × ××¦××¨×××';
              } else if (hour < 18) {
                  return isLower ? '×××"×¦' : '×××¨× ××¦××¨×××';
              } else {
                  return '××¢×¨×';
              }
          },
      });

      //! moment.js locale configuration

      var symbolMap$8 = {
              1: 'à¥§',
              2: 'à¥¨',
              3: 'à¥©',
              4: 'à¥ª',
              5: 'à¥«',
              6: 'à¥¬',
              7: 'à¥­',
              8: 'à¥®',
              9: 'à¥¯',
              0: 'à¥¦',
          },
          numberMap$7 = {
              'à¥§': '1',
              'à¥¨': '2',
              'à¥©': '3',
              'à¥ª': '4',
              'à¥«': '5',
              'à¥¬': '6',
              'à¥­': '7',
              'à¥®': '8',
              'à¥¯': '9',
              'à¥¦': '0',
          },
          monthsParse$7 = [
              /^à¤à¤¨/i,
              /^à¤«à¤¼à¤°|à¤«à¤°/i,
              /^à¤®à¤¾à¤°à¥à¤/i,
              /^à¤à¤ªà¥à¤°à¥/i,
              /^à¤®à¤/i,
              /^à¤à¥à¤¨/i,
              /^à¤à¥à¤²/i,
              /^à¤à¤/i,
              /^à¤¸à¤¿à¤¤à¤|à¤¸à¤¿à¤¤/i,
              /^à¤à¤à¥à¤à¥/i,
              /^à¤¨à¤µ|à¤¨à¤µà¤/i,
              /^à¤¦à¤¿à¤¸à¤|à¤¦à¤¿à¤¸/i,
          ],
          shortMonthsParse = [
              /^à¤à¤¨/i,
              /^à¤«à¤¼à¤°/i,
              /^à¤®à¤¾à¤°à¥à¤/i,
              /^à¤à¤ªà¥à¤°à¥/i,
              /^à¤®à¤/i,
              /^à¤à¥à¤¨/i,
              /^à¤à¥à¤²/i,
              /^à¤à¤/i,
              /^à¤¸à¤¿à¤¤/i,
              /^à¤à¤à¥à¤à¥/i,
              /^à¤¨à¤µ/i,
              /^à¤¦à¤¿à¤¸/i,
          ];

      hooks.defineLocale('hi', {
          months: {
              format: 'à¤à¤¨à¤µà¤°à¥_à¤«à¤¼à¤°à¤µà¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥à¤²_à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤_à¤à¤à¤¸à¥à¤¤_à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¤µà¤®à¥à¤¬à¤°_à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°'.split(
                  '_'
              ),
              standalone: 'à¤à¤¨à¤µà¤°à¥_à¤«à¤°à¤µà¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥à¤²_à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤_à¤à¤à¤¸à¥à¤¤_à¤¸à¤¿à¤¤à¤à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¤µà¤à¤¬à¤°_à¤¦à¤¿à¤¸à¤à¤¬à¤°'.split(
                  '_'
              ),
          },
          monthsShort: 'à¤à¤¨._à¤«à¤¼à¤°._à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥._à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²._à¤à¤._à¤¸à¤¿à¤¤._à¤à¤à¥à¤à¥._à¤¨à¤µ._à¤¦à¤¿à¤¸.'.split(
              '_'
          ),
          weekdays: 'à¤°à¤µà¤¿à¤µà¤¾à¤°_à¤¸à¥à¤®à¤µà¤¾à¤°_à¤®à¤à¤à¤²à¤µà¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤à¥à¤°à¥à¤µà¤¾à¤°_à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤°_à¤¶à¤¨à¤¿à¤µà¤¾à¤°'.split('_'),
          weekdaysShort: 'à¤°à¤µà¤¿_à¤¸à¥à¤®_à¤®à¤à¤à¤²_à¤¬à¥à¤§_à¤à¥à¤°à¥_à¤¶à¥à¤à¥à¤°_à¤¶à¤¨à¤¿'.split('_'),
          weekdaysMin: 'à¤°_à¤¸à¥_à¤®à¤_à¤¬à¥_à¤à¥_à¤¶à¥_à¤¶'.split('_'),
          longDateFormat: {
              LT: 'A h:mm à¤¬à¤à¥',
              LTS: 'A h:mm:ss à¤¬à¤à¥',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm à¤¬à¤à¥',
              LLLL: 'dddd, D MMMM YYYY, A h:mm à¤¬à¤à¥',
          },

          monthsParse: monthsParse$7,
          longMonthsParse: monthsParse$7,
          shortMonthsParse: shortMonthsParse,

          monthsRegex: /^(à¤à¤¨à¤µà¤°à¥|à¤à¤¨\.?|à¤«à¤¼à¤°à¤µà¤°à¥|à¤«à¤°à¤µà¤°à¥|à¤«à¤¼à¤°\.?|à¤®à¤¾à¤°à¥à¤?|à¤à¤ªà¥à¤°à¥à¤²|à¤à¤ªà¥à¤°à¥\.?|à¤®à¤?|à¤à¥à¤¨?|à¤à¥à¤²à¤¾à¤|à¤à¥à¤²\.?|à¤à¤à¤¸à¥à¤¤|à¤à¤\.?|à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°|à¤¸à¤¿à¤¤à¤à¤¬à¤°|à¤¸à¤¿à¤¤\.?|à¤à¤à¥à¤à¥à¤¬à¤°|à¤à¤à¥à¤à¥\.?|à¤¨à¤µà¤®à¥à¤¬à¤°|à¤¨à¤µà¤à¤¬à¤°|à¤¨à¤µ\.?|à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°|à¤¦à¤¿à¤¸à¤à¤¬à¤°|à¤¦à¤¿à¤¸\.?)/i,

          monthsShortRegex: /^(à¤à¤¨à¤µà¤°à¥|à¤à¤¨\.?|à¤«à¤¼à¤°à¤µà¤°à¥|à¤«à¤°à¤µà¤°à¥|à¤«à¤¼à¤°\.?|à¤®à¤¾à¤°à¥à¤?|à¤à¤ªà¥à¤°à¥à¤²|à¤à¤ªà¥à¤°à¥\.?|à¤®à¤?|à¤à¥à¤¨?|à¤à¥à¤²à¤¾à¤|à¤à¥à¤²\.?|à¤à¤à¤¸à¥à¤¤|à¤à¤\.?|à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°|à¤¸à¤¿à¤¤à¤à¤¬à¤°|à¤¸à¤¿à¤¤\.?|à¤à¤à¥à¤à¥à¤¬à¤°|à¤à¤à¥à¤à¥\.?|à¤¨à¤µà¤®à¥à¤¬à¤°|à¤¨à¤µà¤à¤¬à¤°|à¤¨à¤µ\.?|à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°|à¤¦à¤¿à¤¸à¤à¤¬à¤°|à¤¦à¤¿à¤¸\.?)/i,

          monthsStrictRegex: /^(à¤à¤¨à¤µà¤°à¥?|à¤«à¤¼à¤°à¤µà¤°à¥|à¤«à¤°à¤µà¤°à¥?|à¤®à¤¾à¤°à¥à¤?|à¤à¤ªà¥à¤°à¥à¤²?|à¤®à¤?|à¤à¥à¤¨?|à¤à¥à¤²à¤¾à¤?|à¤à¤à¤¸à¥à¤¤?|à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°|à¤¸à¤¿à¤¤à¤à¤¬à¤°|à¤¸à¤¿à¤¤?\.?|à¤à¤à¥à¤à¥à¤¬à¤°|à¤à¤à¥à¤à¥\.?|à¤¨à¤µà¤®à¥à¤¬à¤°|à¤¨à¤µà¤à¤¬à¤°?|à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°|à¤¦à¤¿à¤¸à¤à¤¬à¤°?)/i,

          monthsShortStrictRegex: /^(à¤à¤¨\.?|à¤«à¤¼à¤°\.?|à¤®à¤¾à¤°à¥à¤?|à¤à¤ªà¥à¤°à¥\.?|à¤®à¤?|à¤à¥à¤¨?|à¤à¥à¤²\.?|à¤à¤\.?|à¤¸à¤¿à¤¤\.?|à¤à¤à¥à¤à¥\.?|à¤¨à¤µ\.?|à¤¦à¤¿à¤¸\.?)/i,

          calendar: {
              sameDay: '[à¤à¤] LT',
              nextDay: '[à¤à¤²] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à¤à¤²] LT',
              lastWeek: '[à¤ªà¤¿à¤à¤²à¥] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à¤®à¥à¤',
              past: '%s à¤ªà¤¹à¤²à¥',
              s: 'à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£',
              ss: '%d à¤¸à¥à¤à¤à¤¡',
              m: 'à¤à¤ à¤®à¤¿à¤¨à¤',
              mm: '%d à¤®à¤¿à¤¨à¤',
              h: 'à¤à¤ à¤à¤à¤à¤¾',
              hh: '%d à¤à¤à¤à¥',
              d: 'à¤à¤ à¤¦à¤¿à¤¨',
              dd: '%d à¤¦à¤¿à¤¨',
              M: 'à¤à¤ à¤®à¤¹à¥à¤¨à¥',
              MM: '%d à¤®à¤¹à¥à¤¨à¥',
              y: 'à¤à¤ à¤µà¤°à¥à¤·',
              yy: '%d à¤µà¤°à¥à¤·',
          },
          preparse: function (string) {
              return string.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function (match) {
                  return numberMap$7[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$8[match];
              });
          },
          // Hindi notation for meridiems are quite fuzzy in practice. While there exists
          // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
          meridiemParse: /à¤°à¤¾à¤¤|à¤¸à¥à¤¬à¤¹|à¤¦à¥à¤ªà¤¹à¤°|à¤¶à¤¾à¤®/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à¤°à¤¾à¤¤') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'à¤¸à¥à¤¬à¤¹') {
                  return hour;
              } else if (meridiem === 'à¤¦à¥à¤ªà¤¹à¤°') {
                  return hour >= 10 ? hour : hour + 12;
              } else if (meridiem === 'à¤¶à¤¾à¤®') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à¤°à¤¾à¤¤';
              } else if (hour < 10) {
                  return 'à¤¸à¥à¤¬à¤¹';
              } else if (hour < 17) {
                  return 'à¤¦à¥à¤ªà¤¹à¤°';
              } else if (hour < 20) {
                  return 'à¤¶à¤¾à¤®';
              } else {
                  return 'à¤°à¤¾à¤¤';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function translate$3(number, withoutSuffix, key) {
          var result = number + ' ';
          switch (key) {
              case 'ss':
                  if (number === 1) {
                      result += 'sekunda';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'sekunde';
                  } else {
                      result += 'sekundi';
                  }
                  return result;
              case 'm':
                  return withoutSuffix ? 'jedna minuta' : 'jedne minute';
              case 'mm':
                  if (number === 1) {
                      result += 'minuta';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'minute';
                  } else {
                      result += 'minuta';
                  }
                  return result;
              case 'h':
                  return withoutSuffix ? 'jedan sat' : 'jednog sata';
              case 'hh':
                  if (number === 1) {
                      result += 'sat';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'sata';
                  } else {
                      result += 'sati';
                  }
                  return result;
              case 'dd':
                  if (number === 1) {
                      result += 'dan';
                  } else {
                      result += 'dana';
                  }
                  return result;
              case 'MM':
                  if (number === 1) {
                      result += 'mjesec';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'mjeseca';
                  } else {
                      result += 'mjeseci';
                  }
                  return result;
              case 'yy':
                  if (number === 1) {
                      result += 'godina';
                  } else if (number === 2 || number === 3 || number === 4) {
                      result += 'godine';
                  } else {
                      result += 'godina';
                  }
                  return result;
          }
      }

      hooks.defineLocale('hr', {
          months: {
              format: 'sijeÄnja_veljaÄe_oÅ¾ujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split(
                  '_'
              ),
              standalone: 'sijeÄanj_veljaÄa_oÅ¾ujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split(
                  '_'
              ),
          },
          monthsShort: 'sij._velj._oÅ¾u._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota'.split(
              '_'
          ),
          weekdaysShort: 'ned._pon._uto._sri._Äet._pet._sub.'.split('_'),
          weekdaysMin: 'ne_po_ut_sr_Äe_pe_su'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'Do MMMM YYYY',
              LLL: 'Do MMMM YYYY H:mm',
              LLLL: 'dddd, Do MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[danas u] LT',
              nextDay: '[sutra u] LT',
              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[u] [nedjelju] [u] LT';
                      case 3:
                          return '[u] [srijedu] [u] LT';
                      case 6:
                          return '[u] [subotu] [u] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[u] dddd [u] LT';
                  }
              },
              lastDay: '[juÄer u] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[proÅ¡lu] [nedjelju] [u] LT';
                      case 3:
                          return '[proÅ¡lu] [srijedu] [u] LT';
                      case 6:
                          return '[proÅ¡le] [subote] [u] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[proÅ¡li] dddd [u] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'za %s',
              past: 'prije %s',
              s: 'par sekundi',
              ss: translate$3,
              m: translate$3,
              mm: translate$3,
              h: translate$3,
              hh: translate$3,
              d: 'dan',
              dd: translate$3,
              M: 'mjesec',
              MM: translate$3,
              y: 'godinu',
              yy: translate$3,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var weekEndings = 'vasÃ¡rnap hÃ©tfÅn kedden szerdÃ¡n csÃ¼tÃ¶rtÃ¶kÃ¶n pÃ©nteken szombaton'.split(
          ' '
      );
      function translate$4(number, withoutSuffix, key, isFuture) {
          var num = number;
          switch (key) {
              case 's':
                  return isFuture || withoutSuffix
                      ? 'nÃ©hÃ¡ny mÃ¡sodperc'
                      : 'nÃ©hÃ¡ny mÃ¡sodperce';
              case 'ss':
                  return num + (isFuture || withoutSuffix)
                      ? ' mÃ¡sodperc'
                      : ' mÃ¡sodperce';
              case 'm':
                  return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
              case 'mm':
                  return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
              case 'h':
                  return 'egy' + (isFuture || withoutSuffix ? ' Ã³ra' : ' Ã³rÃ¡ja');
              case 'hh':
                  return num + (isFuture || withoutSuffix ? ' Ã³ra' : ' Ã³rÃ¡ja');
              case 'd':
                  return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
              case 'dd':
                  return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
              case 'M':
                  return 'egy' + (isFuture || withoutSuffix ? ' hÃ³nap' : ' hÃ³napja');
              case 'MM':
                  return num + (isFuture || withoutSuffix ? ' hÃ³nap' : ' hÃ³napja');
              case 'y':
                  return 'egy' + (isFuture || withoutSuffix ? ' Ã©v' : ' Ã©ve');
              case 'yy':
                  return num + (isFuture || withoutSuffix ? ' Ã©v' : ' Ã©ve');
          }
          return '';
      }
      function week(isFuture) {
          return (
              (isFuture ? '' : '[mÃºlt] ') +
              '[' +
              weekEndings[this.day()] +
              '] LT[-kor]'
          );
      }

      hooks.defineLocale('hu', {
          months: 'januÃ¡r_februÃ¡r_mÃ¡rcius_Ã¡prilis_mÃ¡jus_jÃºnius_jÃºlius_augusztus_szeptember_oktÃ³ber_november_december'.split(
              '_'
          ),
          monthsShort: 'jan._feb._mÃ¡rc._Ã¡pr._mÃ¡j._jÃºn._jÃºl._aug._szept._okt._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'vasÃ¡rnap_hÃ©tfÅ_kedd_szerda_csÃ¼tÃ¶rtÃ¶k_pÃ©ntek_szombat'.split('_'),
          weekdaysShort: 'vas_hÃ©t_kedd_sze_csÃ¼t_pÃ©n_szo'.split('_'),
          weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'YYYY.MM.DD.',
              LL: 'YYYY. MMMM D.',
              LLL: 'YYYY. MMMM D. H:mm',
              LLLL: 'YYYY. MMMM D., dddd H:mm',
          },
          meridiemParse: /de|du/i,
          isPM: function (input) {
              return input.charAt(1).toLowerCase() === 'u';
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours < 12) {
                  return isLower === true ? 'de' : 'DE';
              } else {
                  return isLower === true ? 'du' : 'DU';
              }
          },
          calendar: {
              sameDay: '[ma] LT[-kor]',
              nextDay: '[holnap] LT[-kor]',
              nextWeek: function () {
                  return week.call(this, true);
              },
              lastDay: '[tegnap] LT[-kor]',
              lastWeek: function () {
                  return week.call(this, false);
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s mÃºlva',
              past: '%s',
              s: translate$4,
              ss: translate$4,
              m: translate$4,
              mm: translate$4,
              h: translate$4,
              hh: translate$4,
              d: translate$4,
              dd: translate$4,
              M: translate$4,
              MM: translate$4,
              y: translate$4,
              yy: translate$4,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('hy-am', {
          months: {
              format: 'Õ°Õ¸ÖÕ¶Õ¾Õ¡ÖÕ«_ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ«_Õ´Õ¡ÖÕ¿Õ«_Õ¡ÕºÖÕ«Õ¬Õ«_Õ´Õ¡ÕµÕ«Õ½Õ«_Õ°Õ¸ÖÕ¶Õ«Õ½Õ«_Õ°Õ¸ÖÕ¬Õ«Õ½Õ«_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½Õ«_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥ÖÕ«_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«'.split(
                  '_'
              ),
              standalone: 'Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö_ÖÕ¥Õ¿ÖÕ¾Õ¡Ö_Õ´Õ¡ÖÕ¿_Õ¡ÕºÖÕ«Õ¬_Õ´Õ¡ÕµÕ«Õ½_Õ°Õ¸ÖÕ¶Õ«Õ½_Õ°Õ¸ÖÕ¬Õ«Õ½_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö'.split(
                  '_'
              ),
          },
          monthsShort: 'Õ°Õ¶Õ¾_ÖÕ¿Ö_Õ´ÖÕ¿_Õ¡ÕºÖ_Õ´ÕµÕ½_Õ°Õ¶Õ½_Õ°Õ¬Õ½_ÖÕ£Õ½_Õ½ÕºÕ¿_Õ°Õ¯Õ¿_Õ¶Õ´Õ¢_Õ¤Õ¯Õ¿'.split('_'),
          weekdays: 'Õ¯Õ«ÖÕ¡Õ¯Õ«_Õ¥ÖÕ¯Õ¸ÖÕ·Õ¡Õ¢Õ©Õ«_Õ¥ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«_Õ¹Õ¸ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«_Õ°Õ«Õ¶Õ£Õ·Õ¡Õ¢Õ©Õ«_Õ¸ÖÖÕ¢Õ¡Õ©_Õ·Õ¡Õ¢Õ¡Õ©'.split(
              '_'
          ),
          weekdaysShort: 'Õ¯ÖÕ¯_Õ¥ÖÕ¯_Õ¥ÖÖ_Õ¹ÖÖ_Õ°Õ¶Õ£_Õ¸ÖÖÕ¢_Õ·Õ¢Õ©'.split('_'),
          weekdaysMin: 'Õ¯ÖÕ¯_Õ¥ÖÕ¯_Õ¥ÖÖ_Õ¹ÖÖ_Õ°Õ¶Õ£_Õ¸ÖÖÕ¢_Õ·Õ¢Õ©'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY Õ©.',
              LLL: 'D MMMM YYYY Õ©., HH:mm',
              LLLL: 'dddd, D MMMM YYYY Õ©., HH:mm',
          },
          calendar: {
              sameDay: '[Õ¡ÕµÕ½ÖÖ] LT',
              nextDay: '[Õ¾Õ¡Õ²Õ¨] LT',
              lastDay: '[Õ¥ÖÕ¥Õ¯] LT',
              nextWeek: function () {
                  return 'dddd [ÖÖÕ¨ ÕªÕ¡Õ´Õ¨] LT';
              },
              lastWeek: function () {
                  return '[Õ¡Õ¶ÖÕ¡Õ®] dddd [ÖÖÕ¨ ÕªÕ¡Õ´Õ¨] LT';
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s Õ°Õ¥Õ¿Õ¸',
              past: '%s Õ¡Õ¼Õ¡Õ»',
              s: 'Õ´Õ« ÖÕ¡Õ¶Õ« Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶',
              ss: '%d Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶',
              m: 'ÖÕ¸ÕºÕ¥',
              mm: '%d ÖÕ¸ÕºÕ¥',
              h: 'ÕªÕ¡Õ´',
              hh: '%d ÕªÕ¡Õ´',
              d: 'ÖÖ',
              dd: '%d ÖÖ',
              M: 'Õ¡Õ´Õ«Õ½',
              MM: '%d Õ¡Õ´Õ«Õ½',
              y: 'Õ¿Õ¡ÖÕ«',
              yy: '%d Õ¿Õ¡ÖÕ«',
          },
          meridiemParse: /Õ£Õ«Õ·Õ¥ÖÕ¾Õ¡|Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡|ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡|Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶/,
          isPM: function (input) {
              return /^(ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡|Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶)$/.test(input);
          },
          meridiem: function (hour) {
              if (hour < 4) {
                  return 'Õ£Õ«Õ·Õ¥ÖÕ¾Õ¡';
              } else if (hour < 12) {
                  return 'Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡';
              } else if (hour < 17) {
                  return 'ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡';
              } else {
                  return 'Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶';
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(Õ«Õ¶|ÖÕ¤)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'DDD':
                  case 'w':
                  case 'W':
                  case 'DDDo':
                      if (number === 1) {
                          return number + '-Õ«Õ¶';
                      }
                      return number + '-ÖÕ¤';
                  default:
                      return number;
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('id', {
          months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
          weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
          weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
          weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
          longDateFormat: {
              LT: 'HH.mm',
              LTS: 'HH.mm.ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY [pukul] HH.mm',
              LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
          },
          meridiemParse: /pagi|siang|sore|malam/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'pagi') {
                  return hour;
              } else if (meridiem === 'siang') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'sore' || meridiem === 'malam') {
                  return hour + 12;
              }
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours < 11) {
                  return 'pagi';
              } else if (hours < 15) {
                  return 'siang';
              } else if (hours < 19) {
                  return 'sore';
              } else {
                  return 'malam';
              }
          },
          calendar: {
              sameDay: '[Hari ini pukul] LT',
              nextDay: '[Besok pukul] LT',
              nextWeek: 'dddd [pukul] LT',
              lastDay: '[Kemarin pukul] LT',
              lastWeek: 'dddd [lalu pukul] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'dalam %s',
              past: '%s yang lalu',
              s: 'beberapa detik',
              ss: '%d detik',
              m: 'semenit',
              mm: '%d menit',
              h: 'sejam',
              hh: '%d jam',
              d: 'sehari',
              dd: '%d hari',
              M: 'sebulan',
              MM: '%d bulan',
              y: 'setahun',
              yy: '%d tahun',
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function plural$2(n) {
          if (n % 100 === 11) {
              return true;
          } else if (n % 10 === 1) {
              return false;
          }
          return true;
      }
      function translate$5(number, withoutSuffix, key, isFuture) {
          var result = number + ' ';
          switch (key) {
              case 's':
                  return withoutSuffix || isFuture
                      ? 'nokkrar sekÃºndur'
                      : 'nokkrum sekÃºndum';
              case 'ss':
                  if (plural$2(number)) {
                      return (
                          result +
                          (withoutSuffix || isFuture ? 'sekÃºndur' : 'sekÃºndum')
                      );
                  }
                  return result + 'sekÃºnda';
              case 'm':
                  return withoutSuffix ? 'mÃ­nÃºta' : 'mÃ­nÃºtu';
              case 'mm':
                  if (plural$2(number)) {
                      return (
                          result + (withoutSuffix || isFuture ? 'mÃ­nÃºtur' : 'mÃ­nÃºtum')
                      );
                  } else if (withoutSuffix) {
                      return result + 'mÃ­nÃºta';
                  }
                  return result + 'mÃ­nÃºtu';
              case 'hh':
                  if (plural$2(number)) {
                      return (
                          result +
                          (withoutSuffix || isFuture
                              ? 'klukkustundir'
                              : 'klukkustundum')
                      );
                  }
                  return result + 'klukkustund';
              case 'd':
                  if (withoutSuffix) {
                      return 'dagur';
                  }
                  return isFuture ? 'dag' : 'degi';
              case 'dd':
                  if (plural$2(number)) {
                      if (withoutSuffix) {
                          return result + 'dagar';
                      }
                      return result + (isFuture ? 'daga' : 'dÃ¶gum');
                  } else if (withoutSuffix) {
                      return result + 'dagur';
                  }
                  return result + (isFuture ? 'dag' : 'degi');
              case 'M':
                  if (withoutSuffix) {
                      return 'mÃ¡nuÃ°ur';
                  }
                  return isFuture ? 'mÃ¡nuÃ°' : 'mÃ¡nuÃ°i';
              case 'MM':
                  if (plural$2(number)) {
                      if (withoutSuffix) {
                          return result + 'mÃ¡nuÃ°ir';
                      }
                      return result + (isFuture ? 'mÃ¡nuÃ°i' : 'mÃ¡nuÃ°um');
                  } else if (withoutSuffix) {
                      return result + 'mÃ¡nuÃ°ur';
                  }
                  return result + (isFuture ? 'mÃ¡nuÃ°' : 'mÃ¡nuÃ°i');
              case 'y':
                  return withoutSuffix || isFuture ? 'Ã¡r' : 'Ã¡ri';
              case 'yy':
                  if (plural$2(number)) {
                      return result + (withoutSuffix || isFuture ? 'Ã¡r' : 'Ã¡rum');
                  }
                  return result + (withoutSuffix || isFuture ? 'Ã¡r' : 'Ã¡ri');
          }
      }

      hooks.defineLocale('is', {
          months: 'janÃºar_febrÃºar_mars_aprÃ­l_maÃ­_jÃºnÃ­_jÃºlÃ­_Ã¡gÃºst_september_oktÃ³ber_nÃ³vember_desember'.split(
              '_'
          ),
          monthsShort: 'jan_feb_mar_apr_maÃ­_jÃºn_jÃºl_Ã¡gÃº_sep_okt_nÃ³v_des'.split('_'),
          weekdays: 'sunnudagur_mÃ¡nudagur_Ã¾riÃ°judagur_miÃ°vikudagur_fimmtudagur_fÃ¶studagur_laugardagur'.split(
              '_'
          ),
          weekdaysShort: 'sun_mÃ¡n_Ã¾ri_miÃ°_fim_fÃ¶s_lau'.split('_'),
          weekdaysMin: 'Su_MÃ¡_Ãr_Mi_Fi_FÃ¶_La'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY [kl.] H:mm',
              LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm',
          },
          calendar: {
              sameDay: '[Ã­ dag kl.] LT',
              nextDay: '[Ã¡ morgun kl.] LT',
              nextWeek: 'dddd [kl.] LT',
              lastDay: '[Ã­ gÃ¦r kl.] LT',
              lastWeek: '[sÃ­Ã°asta] dddd [kl.] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'eftir %s',
              past: 'fyrir %s sÃ­Ã°an',
              s: translate$5,
              ss: translate$5,
              m: translate$5,
              mm: translate$5,
              h: 'klukkustund',
              hh: translate$5,
              d: translate$5,
              dd: translate$5,
              M: translate$5,
              MM: translate$5,
              y: translate$5,
              yy: translate$5,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('it-ch', {
          months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
              '_'
          ),
          monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
          weekdays: 'domenica_lunedÃ¬_martedÃ¬_mercoledÃ¬_giovedÃ¬_venerdÃ¬_sabato'.split(
              '_'
          ),
          weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
          weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Oggi alle] LT',
              nextDay: '[Domani alle] LT',
              nextWeek: 'dddd [alle] LT',
              lastDay: '[Ieri alle] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[la scorsa] dddd [alle] LT';
                      default:
                          return '[lo scorso] dddd [alle] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: function (s) {
                  return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
              },
              past: '%s fa',
              s: 'alcuni secondi',
              ss: '%d secondi',
              m: 'un minuto',
              mm: '%d minuti',
              h: "un'ora",
              hh: '%d ore',
              d: 'un giorno',
              dd: '%d giorni',
              M: 'un mese',
              MM: '%d mesi',
              y: 'un anno',
              yy: '%d anni',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('it', {
          months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
              '_'
          ),
          monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
          weekdays: 'domenica_lunedÃ¬_martedÃ¬_mercoledÃ¬_giovedÃ¬_venerdÃ¬_sabato'.split(
              '_'
          ),
          weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
          weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: function () {
                  return (
                      '[Oggi a' +
                      (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                      ']LT'
                  );
              },
              nextDay: function () {
                  return (
                      '[Domani a' +
                      (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                      ']LT'
                  );
              },
              nextWeek: function () {
                  return (
                      'dddd [a' +
                      (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                      ']LT'
                  );
              },
              lastDay: function () {
                  return (
                      '[Ieri a' +
                      (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                      ']LT'
                  );
              },
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return (
                              '[La scorsa] dddd [a' +
                              (this.hours() > 1
                                  ? 'lle '
                                  : this.hours() === 0
                                  ? ' '
                                  : "ll'") +
                              ']LT'
                          );
                      default:
                          return (
                              '[Lo scorso] dddd [a' +
                              (this.hours() > 1
                                  ? 'lle '
                                  : this.hours() === 0
                                  ? ' '
                                  : "ll'") +
                              ']LT'
                          );
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'tra %s',
              past: '%s fa',
              s: 'alcuni secondi',
              ss: '%d secondi',
              m: 'un minuto',
              mm: '%d minuti',
              h: "un'ora",
              hh: '%d ore',
              d: 'un giorno',
              dd: '%d giorni',
              w: 'una settimana',
              ww: '%d settimane',
              M: 'un mese',
              MM: '%d mesi',
              y: 'un anno',
              yy: '%d anni',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ja', {
          eras: [
              {
                  since: '2019-05-01',
                  offset: 1,
                  name: 'ä»¤å',
                  narrow: 'ã¿',
                  abbr: 'R',
              },
              {
                  since: '1989-01-08',
                  until: '2019-04-30',
                  offset: 1,
                  name: 'å¹³æ',
                  narrow: 'ã»',
                  abbr: 'H',
              },
              {
                  since: '1926-12-25',
                  until: '1989-01-07',
                  offset: 1,
                  name: 'æ­å',
                  narrow: 'ã¼',
                  abbr: 'S',
              },
              {
                  since: '1912-07-30',
                  until: '1926-12-24',
                  offset: 1,
                  name: 'å¤§æ­£',
                  narrow: 'ã½',
                  abbr: 'T',
              },
              {
                  since: '1873-01-01',
                  until: '1912-07-29',
                  offset: 6,
                  name: 'ææ²»',
                  narrow: 'ã¾',
                  abbr: 'M',
              },
              {
                  since: '0001-01-01',
                  until: '1873-12-31',
                  offset: 1,
                  name: 'è¥¿æ¦',
                  narrow: 'AD',
                  abbr: 'AD',
              },
              {
                  since: '0000-12-31',
                  until: -Infinity,
                  offset: 1,
                  name: 'ç´åå',
                  narrow: 'BC',
                  abbr: 'BC',
              },
          ],
          eraYearOrdinalRegex: /(å|\d+)å¹´/,
          eraYearOrdinalParse: function (input, match) {
              return match[1] === 'å' ? 1 : parseInt(match[1] || input, 10);
          },
          months: '1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ'.split('_'),
          monthsShort: '1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ'.split(
              '_'
          ),
          weekdays: 'æ¥ææ¥_æææ¥_ç«ææ¥_æ°´ææ¥_æ¨ææ¥_éææ¥_åææ¥'.split('_'),
          weekdaysShort: 'æ¥_æ_ç«_æ°´_æ¨_é_å'.split('_'),
          weekdaysMin: 'æ¥_æ_ç«_æ°´_æ¨_é_å'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY/MM/DD',
              LL: 'YYYYå¹´MæDæ¥',
              LLL: 'YYYYå¹´MæDæ¥ HH:mm',
              LLLL: 'YYYYå¹´MæDæ¥ dddd HH:mm',
              l: 'YYYY/MM/DD',
              ll: 'YYYYå¹´MæDæ¥',
              lll: 'YYYYå¹´MæDæ¥ HH:mm',
              llll: 'YYYYå¹´MæDæ¥(ddd) HH:mm',
          },
          meridiemParse: /åå|åå¾/i,
          isPM: function (input) {
              return input === 'åå¾';
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'åå';
              } else {
                  return 'åå¾';
              }
          },
          calendar: {
              sameDay: '[ä»æ¥] LT',
              nextDay: '[ææ¥] LT',
              nextWeek: function (now) {
                  if (now.week() !== this.week()) {
                      return '[æ¥é±]dddd LT';
                  } else {
                      return 'dddd LT';
                  }
              },
              lastDay: '[æ¨æ¥] LT',
              lastWeek: function (now) {
                  if (this.week() !== now.week()) {
                      return '[åé±]dddd LT';
                  } else {
                      return 'dddd LT';
                  }
              },
              sameElse: 'L',
          },
          dayOfMonthOrdinalParse: /\d{1,2}æ¥/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'y':
                      return number === 1 ? 'åå¹´' : number + 'å¹´';
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + 'æ¥';
                  default:
                      return number;
              }
          },
          relativeTime: {
              future: '%så¾',
              past: '%så',
              s: 'æ°ç§',
              ss: '%dç§',
              m: '1å',
              mm: '%då',
              h: '1æé',
              hh: '%dæé',
              d: '1æ¥',
              dd: '%dæ¥',
              M: '1ã¶æ',
              MM: '%dã¶æ',
              y: '1å¹´',
              yy: '%då¹´',
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('jv', {
          months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
          weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
          weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
          weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
          longDateFormat: {
              LT: 'HH.mm',
              LTS: 'HH.mm.ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY [pukul] HH.mm',
              LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
          },
          meridiemParse: /enjing|siyang|sonten|ndalu/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'enjing') {
                  return hour;
              } else if (meridiem === 'siyang') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                  return hour + 12;
              }
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours < 11) {
                  return 'enjing';
              } else if (hours < 15) {
                  return 'siyang';
              } else if (hours < 19) {
                  return 'sonten';
              } else {
                  return 'ndalu';
              }
          },
          calendar: {
              sameDay: '[Dinten puniko pukul] LT',
              nextDay: '[Mbenjang pukul] LT',
              nextWeek: 'dddd [pukul] LT',
              lastDay: '[Kala wingi pukul] LT',
              lastWeek: 'dddd [kepengker pukul] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'wonten ing %s',
              past: '%s ingkang kepengker',
              s: 'sawetawis detik',
              ss: '%d detik',
              m: 'setunggal menit',
              mm: '%d menit',
              h: 'setunggal jam',
              hh: '%d jam',
              d: 'sedinten',
              dd: '%d dinten',
              M: 'sewulan',
              MM: '%d wulan',
              y: 'setaun',
              yy: '%d taun',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ka', {
          months: 'áááááá á_ááááá áááá_ááá á¢á_ááá ááá_áááá¡á_ááááá¡á_ááááá¡á_ááááá¡á¢á_á¡áá¥á¢ááááá á_áá¥á¢ááááá á_ááááááá á_áááááááá á'.split(
              '_'
          ),
          monthsShort: 'ááá_ááá_ááá _ááá _ááá_ááá_ááá_ááá_á¡áá¥_áá¥á¢_ááá_ááá'.split('_'),
          weekdays: {
              standalone: 'áááá á_áá á¨ááááá_á¡ááá¨ááááá_ááá®á¨ááááá_á®á£áá¨ááááá_ááá áá¡áááá_á¨ááááá'.split(
                  '_'
              ),
              format: 'áááá áá¡_áá á¨ááááá¡_á¡ááá¨ááááá¡_ááá®á¨ááááá¡_á®á£áá¨ááááá¡_ááá áá¡áááá¡_á¨ááááá¡'.split(
                  '_'
              ),
              isFormat: /(á¬ááá|á¨ááááá)/,
          },
          weekdaysShort: 'ááá_áá á¨_á¡áá_ááá®_á®á£á_ááá _á¨áá'.split('_'),
          weekdaysMin: 'áá_áá _á¡á_áá_á®á£_áá_á¨á'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[áá¦áá¡] LT[-áá]',
              nextDay: '[á®ááá] LT[-áá]',
              lastDay: '[áá£á¨áá] LT[-áá]',
              nextWeek: '[á¨ááááá] dddd LT[-áá]',
              lastWeek: '[á¬ááá] dddd LT-áá',
              sameElse: 'L',
          },
          relativeTime: {
              future: function (s) {
                  return s.replace(/(á¬áá|á¬á£á|á¡ááá|á¬áá|áá¦|áá)(á|á)/, function (
                      $0,
                      $1,
                      $2
                  ) {
                      return $2 === 'á' ? $1 + 'á¨á' : $1 + $2 + 'á¨á';
                  });
              },
              past: function (s) {
                  if (/(á¬ááá|á¬á£áá|á¡áááá|áá¦á|ááá)/.test(s)) {
                      return s.replace(/(á|á)$/, 'áá¡ á¬áá');
                  }
                  if (/á¬ááá/.test(s)) {
                      return s.replace(/á¬ááá$/, 'á¬ááá¡ á¬áá');
                  }
                  return s;
              },
              s: 'á áááááááá á¬ááá',
              ss: '%d á¬ááá',
              m: 'á¬á£áá',
              mm: '%d á¬á£áá',
              h: 'á¡áááá',
              hh: '%d á¡áááá',
              d: 'áá¦á',
              dd: '%d áá¦á',
              M: 'ááá',
              MM: '%d ááá',
              y: 'á¬ááá',
              yy: '%d á¬ááá',
          },
          dayOfMonthOrdinalParse: /0|1-áá|áá-\d{1,2}|\d{1,2}-á/,
          ordinal: function (number) {
              if (number === 0) {
                  return number;
              }
              if (number === 1) {
                  return number + '-áá';
              }
              if (
                  number < 20 ||
                  (number <= 100 && number % 20 === 0) ||
                  number % 100 === 0
              ) {
                  return 'áá-' + number;
              }
              return number + '-á';
          },
          week: {
              dow: 1,
              doy: 7,
          },
      });

      //! moment.js locale configuration

      var suffixes$1 = {
          0: '-ÑÑ',
          1: '-ÑÑ',
          2: '-ÑÑ',
          3: '-ÑÑ',
          4: '-ÑÑ',
          5: '-ÑÑ',
          6: '-ÑÑ',
          7: '-ÑÑ',
          8: '-ÑÑ',
          9: '-ÑÑ',
          10: '-ÑÑ',
          20: '-ÑÑ',
          30: '-ÑÑ',
          40: '-ÑÑ',
          50: '-ÑÑ',
          60: '-ÑÑ',
          70: '-ÑÑ',
          80: '-ÑÑ',
          90: '-ÑÑ',
          100: '-ÑÑ',
      };

      hooks.defineLocale('kk', {
          months: 'ÒÐ°Ò£ÑÐ°Ñ_Ð°ÒÐ¿Ð°Ð½_Ð½Ð°ÑÑÑÐ·_ÑÓÑÑÑ_Ð¼Ð°Ð¼ÑÑ_Ð¼Ð°ÑÑÑÐ¼_ÑÑÐ»Ð´Ðµ_ÑÐ°Ð¼ÑÐ·_ÒÑÑÐºÒ¯Ð¹ÐµÐº_ÒÐ°Ð·Ð°Ð½_ÒÐ°ÑÐ°ÑÐ°_Ð¶ÐµÐ»ÑÐ¾ÒÑÐ°Ð½'.split(
              '_'
          ),
          monthsShort: 'ÒÐ°Ò£_Ð°ÒÐ¿_Ð½Ð°Ñ_ÑÓÑ_Ð¼Ð°Ð¼_Ð¼Ð°Ñ_ÑÑÐ»_ÑÐ°Ð¼_ÒÑÑ_ÒÐ°Ð·_ÒÐ°Ñ_Ð¶ÐµÐ»'.split('_'),
          weekdays: 'Ð¶ÐµÐºÑÐµÐ½Ð±Ñ_Ð´Ò¯Ð¹ÑÐµÐ½Ð±Ñ_ÑÐµÐ¹ÑÐµÐ½Ð±Ñ_ÑÓÑÑÐµÐ½Ð±Ñ_Ð±ÐµÐ¹ÑÐµÐ½Ð±Ñ_Ð¶Ò±Ð¼Ð°_ÑÐµÐ½Ð±Ñ'.split(
              '_'
          ),
          weekdaysShort: 'Ð¶ÐµÐº_Ð´Ò¯Ð¹_ÑÐµÐ¹_ÑÓÑ_Ð±ÐµÐ¹_Ð¶Ò±Ð¼_ÑÐµÐ½'.split('_'),
          weekdaysMin: 'Ð¶Ðº_Ð´Ð¹_ÑÐ¹_ÑÑ_Ð±Ð¹_Ð¶Ð¼_ÑÐ½'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[ÐÒ¯Ð³ÑÐ½ ÑÐ°ÒÐ°Ñ] LT',
              nextDay: '[ÐÑÑÐµÒ£ ÑÐ°ÒÐ°Ñ] LT',
              nextWeek: 'dddd [ÑÐ°ÒÐ°Ñ] LT',
              lastDay: '[ÐÐµÑÐµ ÑÐ°ÒÐ°Ñ] LT',
              lastWeek: '[Ó¨ÑÐºÐµÐ½ Ð°Ð¿ÑÐ°Ð½ÑÒ£] dddd [ÑÐ°ÒÐ°Ñ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s ÑÑÑÐ½Ð´Ðµ',
              past: '%s Ð±Ò±ÑÑÐ½',
              s: 'Ð±ÑÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´',
              ss: '%d ÑÐµÐºÑÐ½Ð´',
              m: 'Ð±ÑÑ Ð¼Ð¸Ð½ÑÑ',
              mm: '%d Ð¼Ð¸Ð½ÑÑ',
              h: 'Ð±ÑÑ ÑÐ°ÒÐ°Ñ',
              hh: '%d ÑÐ°ÒÐ°Ñ',
              d: 'Ð±ÑÑ ÐºÒ¯Ð½',
              dd: '%d ÐºÒ¯Ð½',
              M: 'Ð±ÑÑ Ð°Ð¹',
              MM: '%d Ð°Ð¹',
              y: 'Ð±ÑÑ Ð¶ÑÐ»',
              yy: '%d Ð¶ÑÐ»',
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(ÑÑ|ÑÑ)/,
          ordinal: function (number) {
              var a = number % 10,
                  b = number >= 100 ? 100 : null;
              return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$9 = {
              1: 'á¡',
              2: 'á¢',
              3: 'á£',
              4: 'á¤',
              5: 'á¥',
              6: 'á¦',
              7: 'á§',
              8: 'á¨',
              9: 'á©',
              0: 'á ',
          },
          numberMap$8 = {
              'á¡': '1',
              'á¢': '2',
              'á£': '3',
              'á¤': '4',
              'á¥': '5',
              'á¦': '6',
              'á§': '7',
              'á¨': '8',
              'á©': '9',
              'á ': '0',
          };

      hooks.defineLocale('km', {
          months: 'áááá¶_áá»áááá_áá¸áá¶_áááá¶_á§ááá¶_áá·áá»áá¶_áááááá¶_áá¸á á¶_ááááá¶_áá»áá¶_áá·áááá·áá¶_áááá¼'.split(
              '_'
          ),
          monthsShort: 'áááá¶_áá»áááá_áá¸áá¶_áááá¶_á§ááá¶_áá·áá»áá¶_áááááá¶_áá¸á á¶_ááááá¶_áá»áá¶_áá·áááá·áá¶_áááá¼'.split(
              '_'
          ),
          weekdays: 'á¢á¶áá·ááá_ááááá_á¢áááá¶á_áá»á_áááá ááááá·á_áá»ááá_áááá'.split('_'),
          weekdaysShort: 'á¢á¶_á_á¢_á_ááá_áá»_á'.split('_'),
          weekdaysMin: 'á¢á¶_á_á¢_á_ááá_áá»_á'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          meridiemParse: /áááá¹á|áááá¶á/,
          isPM: function (input) {
              return input === 'áááá¶á';
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'áááá¹á';
              } else {
                  return 'áááá¶á';
              }
          },
          calendar: {
              sameDay: '[ááááááá áááá] LT',
              nextDay: '[ááá¢áá áááá] LT',
              nextWeek: 'dddd [áááá] LT',
              lastDay: '[áááá·ááá·á áááá] LT',
              lastWeek: 'dddd [ááááá¶á ááá»á] [áááá] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%sááá',
              past: '%sáá»á',
              s: 'ááá»áááá¶ááá·áá¶áá¸',
              ss: '%d áá·áá¶áá¸',
              m: 'áá½ááá¶áá¸',
              mm: '%d áá¶áá¸',
              h: 'áá½ááááá',
              hh: '%d áááá',
              d: 'áá½ááááá',
              dd: '%d áááá',
              M: 'áá½ááá',
              MM: '%d áá',
              y: 'áá½ááááá¶á',
              yy: '%d áááá¶á',
          },
          dayOfMonthOrdinalParse: /áá¸\d{1,2}/,
          ordinal: 'áá¸%d',
          preparse: function (string) {
              return string.replace(/[á¡á¢á£á¤á¥á¦á§á¨á©á ]/g, function (match) {
                  return numberMap$8[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$9[match];
              });
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$a = {
              1: 'à³§',
              2: 'à³¨',
              3: 'à³©',
              4: 'à³ª',
              5: 'à³«',
              6: 'à³¬',
              7: 'à³­',
              8: 'à³®',
              9: 'à³¯',
              0: 'à³¦',
          },
          numberMap$9 = {
              'à³§': '1',
              'à³¨': '2',
              'à³©': '3',
              'à³ª': '4',
              'à³«': '5',
              'à³¬': '6',
              'à³­': '7',
              'à³®': '8',
              'à³¯': '9',
              'à³¦': '0',
          };

      hooks.defineLocale('kn', {
          months: 'à²à²¨à²µà²°à²¿_à²«à³à²¬à³à²°à²µà²°à²¿_à²®à²¾à²°à³à²à³_à²à²ªà³à²°à²¿à²²à³_à²®à³à³_à²à³à²¨à³_à²à³à²²à³à³_à²à²à²¸à³à²à³_à²¸à³à²ªà³à²à³à²à²¬à²°à³_à²à²à³à²à³à³à³à²¬à²°à³_à²¨à²µà³à²à²¬à²°à³_à²¡à²¿à²¸à³à²à²¬à²°à³'.split(
              '_'
          ),
          monthsShort: 'à²à²¨_à²«à³à²¬à³à²°_à²®à²¾à²°à³à²à³_à²à²ªà³à²°à²¿à²²à³_à²®à³à³_à²à³à²¨à³_à²à³à²²à³à³_à²à²à²¸à³à²à³_à²¸à³à²ªà³à²à³à²_à²à²à³à²à³à³à³_à²¨à²µà³à²_à²¡à²¿à²¸à³à²'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'à²­à²¾à²¨à³à²µà²¾à²°_à²¸à³à³à³à²®à²µà²¾à²°_à²®à²à²à²³à²µà²¾à²°_à²¬à³à²§à²µà²¾à²°_à²à³à²°à³à²µà²¾à²°_à²¶à³à²à³à²°à²µà²¾à²°_à²¶à²¨à²¿à²µà²¾à²°'.split(
              '_'
          ),
          weekdaysShort: 'à²­à²¾à²¨à³_à²¸à³à³à³à²®_à²®à²à²à²³_à²¬à³à²§_à²à³à²°à³_à²¶à³à²à³à²°_à²¶à²¨à²¿'.split('_'),
          weekdaysMin: 'à²­à²¾_à²¸à³à³à³_à²®à²_à²¬à³_à²à³_à²¶à³_à²¶'.split('_'),
          longDateFormat: {
              LT: 'A h:mm',
              LTS: 'A h:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm',
              LLLL: 'dddd, D MMMM YYYY, A h:mm',
          },
          calendar: {
              sameDay: '[à²à²à²¦à³] LT',
              nextDay: '[à²¨à²¾à²³à³] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à²¨à²¿à²¨à³à²¨à³] LT',
              lastWeek: '[à²à³à³à²¨à³à²¯] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à²¨à²à²¤à²°',
              past: '%s à²¹à²¿à²à²¦à³',
              s: 'à²à³à²²à²µà³ à²à³à²·à²£à²à²³à³',
              ss: '%d à²¸à³à²à³à²à²¡à³à²à²³à³',
              m: 'à²à²à²¦à³ à²¨à²¿à²®à²¿à²·',
              mm: '%d à²¨à²¿à²®à²¿à²·',
              h: 'à²à²à²¦à³ à²à²à²à³',
              hh: '%d à²à²à²à³',
              d: 'à²à²à²¦à³ à²¦à²¿à²¨',
              dd: '%d à²¦à²¿à²¨',
              M: 'à²à²à²¦à³ à²¤à²¿à²à²à²³à³',
              MM: '%d à²¤à²¿à²à²à²³à³',
              y: 'à²à²à²¦à³ à²µà²°à³à²·',
              yy: '%d à²µà²°à³à²·',
          },
          preparse: function (string) {
              return string.replace(/[à³§à³¨à³©à³ªà³«à³¬à³­à³®à³¯à³¦]/g, function (match) {
                  return numberMap$9[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$a[match];
              });
          },
          meridiemParse: /à²°à²¾à²¤à³à²°à²¿|à²¬à³à²³à²¿à²à³à²à³|à²®à²§à³à²¯à²¾à²¹à³à²¨|à²¸à²à²à³/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à²°à²¾à²¤à³à²°à²¿') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'à²¬à³à²³à²¿à²à³à²à³') {
                  return hour;
              } else if (meridiem === 'à²®à²§à³à²¯à²¾à²¹à³à²¨') {
                  return hour >= 10 ? hour : hour + 12;
              } else if (meridiem === 'à²¸à²à²à³') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à²°à²¾à²¤à³à²°à²¿';
              } else if (hour < 10) {
                  return 'à²¬à³à²³à²¿à²à³à²à³';
              } else if (hour < 17) {
                  return 'à²®à²§à³à²¯à²¾à²¹à³à²¨';
              } else if (hour < 20) {
                  return 'à²¸à²à²à³';
              } else {
                  return 'à²°à²¾à²¤à³à²°à²¿';
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}(à²¨à³à³)/,
          ordinal: function (number) {
              return number + 'à²¨à³à³';
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ko', {
          months: '1ì_2ì_3ì_4ì_5ì_6ì_7ì_8ì_9ì_10ì_11ì_12ì'.split('_'),
          monthsShort: '1ì_2ì_3ì_4ì_5ì_6ì_7ì_8ì_9ì_10ì_11ì_12ì'.split(
              '_'
          ),
          weekdays: 'ì¼ìì¼_ììì¼_íìì¼_ììì¼_ëª©ìì¼_ê¸ìì¼_í ìì¼'.split('_'),
          weekdaysShort: 'ì¼_ì_í_ì_ëª©_ê¸_í '.split('_'),
          weekdaysMin: 'ì¼_ì_í_ì_ëª©_ê¸_í '.split('_'),
          longDateFormat: {
              LT: 'A h:mm',
              LTS: 'A h:mm:ss',
              L: 'YYYY.MM.DD.',
              LL: 'YYYYë MMMM Dì¼',
              LLL: 'YYYYë MMMM Dì¼ A h:mm',
              LLLL: 'YYYYë MMMM Dì¼ dddd A h:mm',
              l: 'YYYY.MM.DD.',
              ll: 'YYYYë MMMM Dì¼',
              lll: 'YYYYë MMMM Dì¼ A h:mm',
              llll: 'YYYYë MMMM Dì¼ dddd A h:mm',
          },
          calendar: {
              sameDay: 'ì¤ë LT',
              nextDay: 'ë´ì¼ LT',
              nextWeek: 'dddd LT',
              lastDay: 'ì´ì  LT',
              lastWeek: 'ì§ëì£¼ dddd LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s í',
              past: '%s ì ',
              s: 'ëª ì´',
              ss: '%dì´',
              m: '1ë¶',
              mm: '%dë¶',
              h: 'í ìê°',
              hh: '%dìê°',
              d: 'íë£¨',
              dd: '%dì¼',
              M: 'í ë¬',
              MM: '%dë¬',
              y: 'ì¼ ë',
              yy: '%dë',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(ì¼|ì|ì£¼)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + 'ì¼';
                  case 'M':
                      return number + 'ì';
                  case 'w':
                  case 'W':
                      return number + 'ì£¼';
                  default:
                      return number;
              }
          },
          meridiemParse: /ì¤ì |ì¤í/,
          isPM: function (token) {
              return token === 'ì¤í';
          },
          meridiem: function (hour, minute, isUpper) {
              return hour < 12 ? 'ì¤ì ' : 'ì¤í';
          },
      });

      //! moment.js locale configuration

      var symbolMap$b = {
              1: 'Ù¡',
              2: 'Ù¢',
              3: 'Ù£',
              4: 'Ù¤',
              5: 'Ù¥',
              6: 'Ù¦',
              7: 'Ù§',
              8: 'Ù¨',
              9: 'Ù©',
              0: 'Ù ',
          },
          numberMap$a = {
              'Ù¡': '1',
              'Ù¢': '2',
              'Ù£': '3',
              'Ù¤': '4',
              'Ù¥': '5',
              'Ù¦': '6',
              'Ù§': '7',
              'Ù¨': '8',
              'Ù©': '9',
              'Ù ': '0',
          },
          months$8 = [
              'Ú©Ø§ÙÙÙÛ Ø¯ÙÙÛÙ',
              'Ø´ÙØ¨Ø§Øª',
              'Ø¦Ø§Ø²Ø§Ø±',
              'ÙÛØ³Ø§Ù',
              'Ø¦Ø§ÛØ§Ø±',
              'Ø­ÙØ²ÛÛØ±Ø§Ù',
              'ØªÛÙÙÙØ²',
              'Ø¦Ø§Ø¨',
              'Ø¦ÛÛÙÙÙÙ',
              'ØªØ´Ø±ÛÙÛ ÛÛÙÛÙ',
              'ØªØ´Ø±ÛÙÛ Ø¯ÙÙÛÙ',
              'ÙØ§ÙÙÙÛ ÛÛÚ©ÛÙ',
          ];

      hooks.defineLocale('ku', {
          months: months$8,
          monthsShort: months$8,
          weekdays: 'ÛÙâÙØ´ÙâÙÙÙâ_Ø¯ÙÙØ´ÙâÙÙÙâ_Ø³ÛØ´ÙâÙÙÙâ_ÚÙØ§Ø±Ø´ÙâÙÙÙâ_Ù¾ÛÙØ¬Ø´ÙâÙÙÙâ_ÙÙâÛÙÛ_Ø´ÙâÙÙÙâ'.split(
              '_'
          ),
          weekdaysShort: 'ÛÙâÙØ´ÙâÙ_Ø¯ÙÙØ´ÙâÙ_Ø³ÛØ´ÙâÙ_ÚÙØ§Ø±Ø´ÙâÙ_Ù¾ÛÙØ¬Ø´ÙâÙ_ÙÙâÛÙÛ_Ø´ÙâÙÙÙâ'.split(
              '_'
          ),
          weekdaysMin: 'Û_Ø¯_Ø³_Ú_Ù¾_Ù_Ø´'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          meridiemParse: /Ø¦ÛÙØ§Ø±Ùâ|Ø¨ÙâÛØ§ÙÛ/,
          isPM: function (input) {
              return /Ø¦ÛÙØ§Ø±Ùâ/.test(input);
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'Ø¨ÙâÛØ§ÙÛ';
              } else {
                  return 'Ø¦ÛÙØ§Ø±Ùâ';
              }
          },
          calendar: {
              sameDay: '[Ø¦ÙâÙØ±Û ÙØ§ØªÚÙÛØ±] LT',
              nextDay: '[Ø¨ÙâÛØ§ÙÛ ÙØ§ØªÚÙÛØ±] LT',
              nextWeek: 'dddd [ÙØ§ØªÚÙÛØ±] LT',
              lastDay: '[Ø¯ÙÛÙÛ ÙØ§ØªÚÙÛØ±] LT',
              lastWeek: 'dddd [ÙØ§ØªÚÙÛØ±] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÙÙâ %s',
              past: '%s',
              s: 'ÚÙâÙØ¯ ÚØ±ÙÙâÛÙâÙ',
              ss: 'ÚØ±ÙÙâ %d',
              m: 'ÛÙâÙ Ø®ÙÙÙâÙ',
              mm: '%d Ø®ÙÙÙâÙ',
              h: 'ÛÙâÙ ÙØ§ØªÚÙÛØ±',
              hh: '%d ÙØ§ØªÚÙÛØ±',
              d: 'ÛÙâÙ ÚÛÚ',
              dd: '%d ÚÛÚ',
              M: 'ÛÙâÙ ÙØ§ÙÚ¯',
              MM: '%d ÙØ§ÙÚ¯',
              y: 'ÛÙâÙ Ø³Ø§Úµ',
              yy: '%d Ø³Ø§Úµ',
          },
          preparse: function (string) {
              return string
                  .replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function (match) {
                      return numberMap$a[match];
                  })
                  .replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string
                  .replace(/\d/g, function (match) {
                      return symbolMap$b[match];
                  })
                  .replace(/,/g, 'Ø');
          },
          week: {
              dow: 6, // Saturday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var suffixes$2 = {
          0: '-ÑÒ¯',
          1: '-ÑÐ¸',
          2: '-ÑÐ¸',
          3: '-ÑÒ¯',
          4: '-ÑÒ¯',
          5: '-ÑÐ¸',
          6: '-ÑÑ',
          7: '-ÑÐ¸',
          8: '-ÑÐ¸',
          9: '-ÑÑ',
          10: '-ÑÑ',
          20: '-ÑÑ',
          30: '-ÑÑ',
          40: '-ÑÑ',
          50: '-ÑÒ¯',
          60: '-ÑÑ',
          70: '-ÑÐ¸',
          80: '-ÑÐ¸',
          90: '-ÑÑ',
          100: '-ÑÒ¯',
      };

      hooks.defineLocale('ky', {
          months: 'ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ'.split(
              '_'
          ),
          monthsShort: 'ÑÐ½Ð²_ÑÐµÐ²_Ð¼Ð°ÑÑ_Ð°Ð¿Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ_Ð½Ð¾Ñ_Ð´ÐµÐº'.split(
              '_'
          ),
          weekdays: 'ÐÐµÐºÑÐµÐ¼Ð±Ð¸_ÐÒ¯Ð¹ÑÓ©Ð¼Ð±Ò¯_Ð¨ÐµÐ¹ÑÐµÐ¼Ð±Ð¸_Ð¨Ð°ÑÑÐµÐ¼Ð±Ð¸_ÐÐµÐ¹ÑÐµÐ¼Ð±Ð¸_ÐÑÐ¼Ð°_ÐÑÐµÐ¼Ð±Ð¸'.split(
              '_'
          ),
          weekdaysShort: 'ÐÐµÐº_ÐÒ¯Ð¹_Ð¨ÐµÐ¹_Ð¨Ð°Ñ_ÐÐµÐ¹_ÐÑÐ¼_ÐÑÐµ'.split('_'),
          weekdaysMin: 'ÐÐº_ÐÐ¹_Ð¨Ð¹_Ð¨Ñ_ÐÐ¹_ÐÐ¼_ÐÑ'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[ÐÒ¯Ð³Ò¯Ð½ ÑÐ°Ð°Ñ] LT',
              nextDay: '[Ð­ÑÑÐµÒ£ ÑÐ°Ð°Ñ] LT',
              nextWeek: 'dddd [ÑÐ°Ð°Ñ] LT',
              lastDay: '[ÐÐµÑÑÑ ÑÐ°Ð°Ñ] LT',
              lastWeek: '[Ó¨ÑÐºÓ©Ð½ Ð°Ð¿ÑÐ°Ð½ÑÐ½] dddd [ÐºÒ¯Ð½Ò¯] [ÑÐ°Ð°Ñ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s Ð¸ÑÐ¸Ð½Ð´Ðµ',
              past: '%s Ð¼ÑÑÑÐ½',
              s: 'Ð±Ð¸ÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´',
              ss: '%d ÑÐµÐºÑÐ½Ð´',
              m: 'Ð±Ð¸Ñ Ð¼Ò¯Ð½Ó©Ñ',
              mm: '%d Ð¼Ò¯Ð½Ó©Ñ',
              h: 'Ð±Ð¸Ñ ÑÐ°Ð°Ñ',
              hh: '%d ÑÐ°Ð°Ñ',
              d: 'Ð±Ð¸Ñ ÐºÒ¯Ð½',
              dd: '%d ÐºÒ¯Ð½',
              M: 'Ð±Ð¸Ñ Ð°Ð¹',
              MM: '%d Ð°Ð¹',
              y: 'Ð±Ð¸Ñ Ð¶ÑÐ»',
              yy: '%d Ð¶ÑÐ»',
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(ÑÐ¸|ÑÑ|ÑÒ¯|ÑÑ)/,
          ordinal: function (number) {
              var a = number % 10,
                  b = number >= 100 ? 100 : null;
              return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
          var format = {
              m: ['eng Minutt', 'enger Minutt'],
              h: ['eng Stonn', 'enger Stonn'],
              d: ['een Dag', 'engem Dag'],
              M: ['ee Mount', 'engem Mount'],
              y: ['ee Joer', 'engem Joer'],
          };
          return withoutSuffix ? format[key][0] : format[key][1];
      }
      function processFutureTime(string) {
          var number = string.substr(0, string.indexOf(' '));
          if (eifelerRegelAppliesToNumber(number)) {
              return 'a ' + string;
          }
          return 'an ' + string;
      }
      function processPastTime(string) {
          var number = string.substr(0, string.indexOf(' '));
          if (eifelerRegelAppliesToNumber(number)) {
              return 'viru ' + string;
          }
          return 'virun ' + string;
      }
      /**
       * Returns true if the word before the given number loses the '-n' ending.
       * e.g. 'an 10 Deeg' but 'a 5 Deeg'
       *
       * @param number {integer}
       * @returns {boolean}
       */
      function eifelerRegelAppliesToNumber(number) {
          number = parseInt(number, 10);
          if (isNaN(number)) {
              return false;
          }
          if (number < 0) {
              // Negative Number --> always true
              return true;
          } else if (number < 10) {
              // Only 1 digit
              if (4 <= number && number <= 7) {
                  return true;
              }
              return false;
          } else if (number < 100) {
              // 2 digits
              var lastDigit = number % 10,
                  firstDigit = number / 10;
              if (lastDigit === 0) {
                  return eifelerRegelAppliesToNumber(firstDigit);
              }
              return eifelerRegelAppliesToNumber(lastDigit);
          } else if (number < 10000) {
              // 3 or 4 digits --> recursively check first digit
              while (number >= 10) {
                  number = number / 10;
              }
              return eifelerRegelAppliesToNumber(number);
          } else {
              // Anything larger than 4 digits: recursively check first n-3 digits
              number = number / 1000;
              return eifelerRegelAppliesToNumber(number);
          }
      }

      hooks.defineLocale('lb', {
          months: 'Januar_Februar_MÃ¤erz_AbrÃ«ll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split(
              '_'
          ),
          monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'Sonndeg_MÃ©indeg_DÃ«nschdeg_MÃ«ttwoch_Donneschdeg_Freideg_Samschdeg'.split(
              '_'
          ),
          weekdaysShort: 'So._MÃ©._DÃ«._MÃ«._Do._Fr._Sa.'.split('_'),
          weekdaysMin: 'So_MÃ©_DÃ«_MÃ«_Do_Fr_Sa'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm [Auer]',
              LTS: 'H:mm:ss [Auer]',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY H:mm [Auer]',
              LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]',
          },
          calendar: {
              sameDay: '[Haut um] LT',
              sameElse: 'L',
              nextDay: '[Muer um] LT',
              nextWeek: 'dddd [um] LT',
              lastDay: '[GÃ«schter um] LT',
              lastWeek: function () {
                  // Different date string for 'DÃ«nschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                  switch (this.day()) {
                      case 2:
                      case 4:
                          return '[Leschten] dddd [um] LT';
                      default:
                          return '[Leschte] dddd [um] LT';
                  }
              },
          },
          relativeTime: {
              future: processFutureTime,
              past: processPastTime,
              s: 'e puer Sekonnen',
              ss: '%d Sekonnen',
              m: processRelativeTime$6,
              mm: '%d Minutten',
              h: processRelativeTime$6,
              hh: '%d Stonnen',
              d: processRelativeTime$6,
              dd: '%d Deeg',
              M: processRelativeTime$6,
              MM: '%d MÃ©int',
              y: processRelativeTime$6,
              yy: '%d Joer',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('lo', {
          months: 'àº¡àº±àºàºàº­àº_àºàº¸àº¡àºàº²_àº¡àºµàºàº²_à»àº¡àºªàº²_àºàº¶àºàºªàº°àºàº²_àº¡àº´àºàº¸àºàº²_àºà»àº¥àº°àºàº»àº_àºªàº´àºàº«àº²_àºàº±àºàºàº²_àºàº¸àº¥àº²_àºàº°àºàº´àº_àºàº±àºàº§àº²'.split(
              '_'
          ),
          monthsShort: 'àº¡àº±àºàºàº­àº_àºàº¸àº¡àºàº²_àº¡àºµàºàº²_à»àº¡àºªàº²_àºàº¶àºàºªàº°àºàº²_àº¡àº´àºàº¸àºàº²_àºà»àº¥àº°àºàº»àº_àºªàº´àºàº«àº²_àºàº±àºàºàº²_àºàº¸àº¥àº²_àºàº°àºàº´àº_àºàº±àºàº§àº²'.split(
              '_'
          ),
          weekdays: 'àº­àº²àºàº´àº_àºàº±àº_àº­àº±àºàºàº²àº_àºàº¸àº_àºàº°àº«àº±àº_àºªàº¸àº_à»àºªàº»àº²'.split('_'),
          weekdaysShort: 'àºàº´àº_àºàº±àº_àº­àº±àºàºàº²àº_àºàº¸àº_àºàº°àº«àº±àº_àºªàº¸àº_à»àºªàº»àº²'.split('_'),
          weekdaysMin: 'àº_àº_àº­àº_àº_àºàº«_àºªàº_àºª'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'àº§àº±àºdddd D MMMM YYYY HH:mm',
          },
          meridiemParse: /àºàº­àºà»àºàº»à»àº²|àºàº­àºà»àº¥àº/,
          isPM: function (input) {
              return input === 'àºàº­àºà»àº¥àº';
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'àºàº­àºà»àºàº»à»àº²';
              } else {
                  return 'àºàº­àºà»àº¥àº';
              }
          },
          calendar: {
              sameDay: '[àº¡àº·à»àºàºµà»à»àº§àº¥àº²] LT',
              nextDay: '[àº¡àº·à»àº­àº·à»àºà»àº§àº¥àº²] LT',
              nextWeek: '[àº§àº±àº]dddd[à»à»àº²à»àº§àº¥àº²] LT',
              lastDay: '[àº¡àº·à»àº§àº²àºàºàºµà»à»àº§àº¥àº²] LT',
              lastWeek: '[àº§àº±àº]dddd[à»àº¥à»àº§àºàºµà»à»àº§àº¥àº²] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'àº­àºµàº %s',
              past: '%sàºà»àº²àºàº¡àº²',
              s: 'àºà»à»à»àºàº»à»àº²à»àºàº§àº´àºàº²àºàºµ',
              ss: '%d àº§àº´àºàº²àºàºµ',
              m: '1 àºàº²àºàºµ',
              mm: '%d àºàº²àºàºµ',
              h: '1 àºàº»à»àº§à»àº¡àº',
              hh: '%d àºàº»à»àº§à»àº¡àº',
              d: '1 àº¡àº·à»',
              dd: '%d àº¡àº·à»',
              M: '1 à»àºàº·àº­àº',
              MM: '%d à»àºàº·àº­àº',
              y: '1 àºàºµ',
              yy: '%d àºàºµ',
          },
          dayOfMonthOrdinalParse: /(àºàºµà»)\d{1,2}/,
          ordinal: function (number) {
              return 'àºàºµà»' + number;
          },
      });

      //! moment.js locale configuration

      var units = {
          ss: 'sekundÄ_sekundÅ¾iÅ³_sekundes',
          m: 'minutÄ_minutÄs_minutÄ',
          mm: 'minutÄs_minuÄiÅ³_minutes',
          h: 'valanda_valandos_valandÄ',
          hh: 'valandos_valandÅ³_valandas',
          d: 'diena_dienos_dienÄ',
          dd: 'dienos_dienÅ³_dienas',
          M: 'mÄnuo_mÄnesio_mÄnesÄ¯',
          MM: 'mÄnesiai_mÄnesiÅ³_mÄnesius',
          y: 'metai_metÅ³_metus',
          yy: 'metai_metÅ³_metus',
      };
      function translateSeconds(number, withoutSuffix, key, isFuture) {
          if (withoutSuffix) {
              return 'kelios sekundÄs';
          } else {
              return isFuture ? 'keliÅ³ sekundÅ¾iÅ³' : 'kelias sekundes';
          }
      }
      function translateSingular(number, withoutSuffix, key, isFuture) {
          return withoutSuffix
              ? forms(key)[0]
              : isFuture
              ? forms(key)[1]
              : forms(key)[2];
      }
      function special(number) {
          return number % 10 === 0 || (number > 10 && number < 20);
      }
      function forms(key) {
          return units[key].split('_');
      }
      function translate$6(number, withoutSuffix, key, isFuture) {
          var result = number + ' ';
          if (number === 1) {
              return (
                  result + translateSingular(number, withoutSuffix, key[0], isFuture)
              );
          } else if (withoutSuffix) {
              return result + (special(number) ? forms(key)[1] : forms(key)[0]);
          } else {
              if (isFuture) {
                  return result + forms(key)[1];
              } else {
                  return result + (special(number) ? forms(key)[1] : forms(key)[2]);
              }
          }
      }
      hooks.defineLocale('lt', {
          months: {
              format: 'sausio_vasario_kovo_balandÅ¾io_geguÅ¾Äs_birÅ¾elio_liepos_rugpjÅ«Äio_rugsÄjo_spalio_lapkriÄio_gruodÅ¾io'.split(
                  '_'
              ),
              standalone: 'sausis_vasaris_kovas_balandis_geguÅ¾Ä_birÅ¾elis_liepa_rugpjÅ«tis_rugsÄjis_spalis_lapkritis_gruodis'.split(
                  '_'
              ),
              isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/,
          },
          monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
          weekdays: {
              format: 'sekmadienÄ¯_pirmadienÄ¯_antradienÄ¯_treÄiadienÄ¯_ketvirtadienÄ¯_penktadienÄ¯_Å¡eÅ¡tadienÄ¯'.split(
                  '_'
              ),
              standalone: 'sekmadienis_pirmadienis_antradienis_treÄiadienis_ketvirtadienis_penktadienis_Å¡eÅ¡tadienis'.split(
                  '_'
              ),
              isFormat: /dddd HH:mm/,
          },
          weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_Å eÅ¡'.split('_'),
          weekdaysMin: 'S_P_A_T_K_Pn_Å '.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY-MM-DD',
              LL: 'YYYY [m.] MMMM D [d.]',
              LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
              LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
              l: 'YYYY-MM-DD',
              ll: 'YYYY [m.] MMMM D [d.]',
              lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
              llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]',
          },
          calendar: {
              sameDay: '[Å iandien] LT',
              nextDay: '[Rytoj] LT',
              nextWeek: 'dddd LT',
              lastDay: '[Vakar] LT',
              lastWeek: '[PraÄjusÄ¯] dddd LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'po %s',
              past: 'prieÅ¡ %s',
              s: translateSeconds,
              ss: translate$6,
              m: translateSingular,
              mm: translate$6,
              h: translateSingular,
              hh: translate$6,
              d: translateSingular,
              dd: translate$6,
              M: translateSingular,
              MM: translate$6,
              y: translateSingular,
              yy: translate$6,
          },
          dayOfMonthOrdinalParse: /\d{1,2}-oji/,
          ordinal: function (number) {
              return number + '-oji';
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var units$1 = {
          ss: 'sekundes_sekundÄm_sekunde_sekundes'.split('_'),
          m: 'minÅ«tes_minÅ«tÄm_minÅ«te_minÅ«tes'.split('_'),
          mm: 'minÅ«tes_minÅ«tÄm_minÅ«te_minÅ«tes'.split('_'),
          h: 'stundas_stundÄm_stunda_stundas'.split('_'),
          hh: 'stundas_stundÄm_stunda_stundas'.split('_'),
          d: 'dienas_dienÄm_diena_dienas'.split('_'),
          dd: 'dienas_dienÄm_diena_dienas'.split('_'),
          M: 'mÄneÅ¡a_mÄneÅ¡iem_mÄnesis_mÄneÅ¡i'.split('_'),
          MM: 'mÄneÅ¡a_mÄneÅ¡iem_mÄnesis_mÄneÅ¡i'.split('_'),
          y: 'gada_gadiem_gads_gadi'.split('_'),
          yy: 'gada_gadiem_gads_gadi'.split('_'),
      };
      /**
       * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
       */
      function format$1(forms, number, withoutSuffix) {
          if (withoutSuffix) {
              // E.g. "21 minÅ«te", "3 minÅ«tes".
              return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
          } else {
              // E.g. "21 minÅ«tes" as in "pÄc 21 minÅ«tes".
              // E.g. "3 minÅ«tÄm" as in "pÄc 3 minÅ«tÄm".
              return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
          }
      }
      function relativeTimeWithPlural$1(number, withoutSuffix, key) {
          return number + ' ' + format$1(units$1[key], number, withoutSuffix);
      }
      function relativeTimeWithSingular(number, withoutSuffix, key) {
          return format$1(units$1[key], number, withoutSuffix);
      }
      function relativeSeconds(number, withoutSuffix) {
          return withoutSuffix ? 'daÅ¾as sekundes' : 'daÅ¾Äm sekundÄm';
      }

      hooks.defineLocale('lv', {
          months: 'janvÄris_februÄris_marts_aprÄ«lis_maijs_jÅ«nijs_jÅ«lijs_augusts_septembris_oktobris_novembris_decembris'.split(
              '_'
          ),
          monthsShort: 'jan_feb_mar_apr_mai_jÅ«n_jÅ«l_aug_sep_okt_nov_dec'.split('_'),
          weekdays: 'svÄtdiena_pirmdiena_otrdiena_treÅ¡diena_ceturtdiena_piektdiena_sestdiena'.split(
              '_'
          ),
          weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
          weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY.',
              LL: 'YYYY. [gada] D. MMMM',
              LLL: 'YYYY. [gada] D. MMMM, HH:mm',
              LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm',
          },
          calendar: {
              sameDay: '[Å odien pulksten] LT',
              nextDay: '[RÄ«t pulksten] LT',
              nextWeek: 'dddd [pulksten] LT',
              lastDay: '[Vakar pulksten] LT',
              lastWeek: '[PagÄjuÅ¡Ä] dddd [pulksten] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'pÄc %s',
              past: 'pirms %s',
              s: relativeSeconds,
              ss: relativeTimeWithPlural$1,
              m: relativeTimeWithSingular,
              mm: relativeTimeWithPlural$1,
              h: relativeTimeWithSingular,
              hh: relativeTimeWithPlural$1,
              d: relativeTimeWithSingular,
              dd: relativeTimeWithPlural$1,
              M: relativeTimeWithSingular,
              MM: relativeTimeWithPlural$1,
              y: relativeTimeWithSingular,
              yy: relativeTimeWithPlural$1,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var translator = {
          words: {
              //Different grammatical cases
              ss: ['sekund', 'sekunda', 'sekundi'],
              m: ['jedan minut', 'jednog minuta'],
              mm: ['minut', 'minuta', 'minuta'],
              h: ['jedan sat', 'jednog sata'],
              hh: ['sat', 'sata', 'sati'],
              dd: ['dan', 'dana', 'dana'],
              MM: ['mjesec', 'mjeseca', 'mjeseci'],
              yy: ['godina', 'godine', 'godina'],
          },
          correctGrammaticalCase: function (number, wordKey) {
              return number === 1
                  ? wordKey[0]
                  : number >= 2 && number <= 4
                  ? wordKey[1]
                  : wordKey[2];
          },
          translate: function (number, withoutSuffix, key) {
              var wordKey = translator.words[key];
              if (key.length === 1) {
                  return withoutSuffix ? wordKey[0] : wordKey[1];
              } else {
                  return (
                      number +
                      ' ' +
                      translator.correctGrammaticalCase(number, wordKey)
                  );
              }
          },
      };

      hooks.defineLocale('me', {
          months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
              '_'
          ),
          monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota'.split(
              '_'
          ),
          weekdaysShort: 'ned._pon._uto._sri._Äet._pet._sub.'.split('_'),
          weekdaysMin: 'ne_po_ut_sr_Äe_pe_su'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY H:mm',
              LLLL: 'dddd, D. MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[danas u] LT',
              nextDay: '[sjutra u] LT',

              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[u] [nedjelju] [u] LT';
                      case 3:
                          return '[u] [srijedu] [u] LT';
                      case 6:
                          return '[u] [subotu] [u] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[u] dddd [u] LT';
                  }
              },
              lastDay: '[juÄe u] LT',
              lastWeek: function () {
                  var lastWeekDays = [
                      '[proÅ¡le] [nedjelje] [u] LT',
                      '[proÅ¡log] [ponedjeljka] [u] LT',
                      '[proÅ¡log] [utorka] [u] LT',
                      '[proÅ¡le] [srijede] [u] LT',
                      '[proÅ¡log] [Äetvrtka] [u] LT',
                      '[proÅ¡log] [petka] [u] LT',
                      '[proÅ¡le] [subote] [u] LT',
                  ];
                  return lastWeekDays[this.day()];
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'za %s',
              past: 'prije %s',
              s: 'nekoliko sekundi',
              ss: translator.translate,
              m: translator.translate,
              mm: translator.translate,
              h: translator.translate,
              hh: translator.translate,
              d: 'dan',
              dd: translator.translate,
              M: 'mjesec',
              MM: translator.translate,
              y: 'godinu',
              yy: translator.translate,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('mi', {
          months: 'Kohi-tÄte_Hui-tanguru_PoutÅ«-te-rangi_Paenga-whÄwhÄ_Haratua_Pipiri_HÅngoingoi_Here-turi-kÅkÄ_Mahuru_Whiringa-Ä-nuku_Whiringa-Ä-rangi_Hakihea'.split(
              '_'
          ),
          monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_HÅngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split(
              '_'
          ),
          monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
          monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
          monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
          monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
          weekdays: 'RÄtapu_Mane_TÅ«rei_Wenerei_TÄite_Paraire_HÄtarei'.split('_'),
          weekdaysShort: 'Ta_Ma_TÅ«_We_TÄi_Pa_HÄ'.split('_'),
          weekdaysMin: 'Ta_Ma_TÅ«_We_TÄi_Pa_HÄ'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY [i] HH:mm',
              LLLL: 'dddd, D MMMM YYYY [i] HH:mm',
          },
          calendar: {
              sameDay: '[i teie mahana, i] LT',
              nextDay: '[apopo i] LT',
              nextWeek: 'dddd [i] LT',
              lastDay: '[inanahi i] LT',
              lastWeek: 'dddd [whakamutunga i] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'i roto i %s',
              past: '%s i mua',
              s: 'te hÄkona ruarua',
              ss: '%d hÄkona',
              m: 'he meneti',
              mm: '%d meneti',
              h: 'te haora',
              hh: '%d haora',
              d: 'he ra',
              dd: '%d ra',
              M: 'he marama',
              MM: '%d marama',
              y: 'he tau',
              yy: '%d tau',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('mk', {
          months: 'ÑÐ°Ð½ÑÐ°ÑÐ¸_ÑÐµÐ²ÑÑÐ°ÑÐ¸_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐ¸Ð»_Ð¼Ð°Ñ_ÑÑÐ½Ð¸_ÑÑÐ»Ð¸_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸'.split(
              '_'
          ),
          monthsShort: 'ÑÐ°Ð½_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ñ_ÑÑÐ½_ÑÑÐ»_Ð°Ð²Ð³_ÑÐµÐ¿_Ð¾ÐºÑ_Ð½Ð¾Ðµ_Ð´ÐµÐº'.split('_'),
          weekdays: 'Ð½ÐµÐ´ÐµÐ»Ð°_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÐµÐ´Ð°_ÑÐµÑÐ²ÑÑÐ¾Ðº_Ð¿ÐµÑÐ¾Ðº_ÑÐ°Ð±Ð¾ÑÐ°'.split(
              '_'
          ),
          weekdaysShort: 'Ð½ÐµÐ´_Ð¿Ð¾Ð½_Ð²ÑÐ¾_ÑÑÐµ_ÑÐµÑ_Ð¿ÐµÑ_ÑÐ°Ð±'.split('_'),
          weekdaysMin: 'Ð½e_Ð¿o_Ð²Ñ_ÑÑ_ÑÐµ_Ð¿Ðµ_Ña'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'D.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY H:mm',
              LLLL: 'dddd, D MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[ÐÐµÐ½ÐµÑ Ð²Ð¾] LT',
              nextDay: '[Ð£ÑÑÐµ Ð²Ð¾] LT',
              nextWeek: '[ÐÐ¾] dddd [Ð²Ð¾] LT',
              lastDay: '[ÐÑÐµÑÐ° Ð²Ð¾] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                      case 3:
                      case 6:
                          return '[ÐÐ·Ð¼Ð¸Ð½Ð°ÑÐ°ÑÐ°] dddd [Ð²Ð¾] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[ÐÐ·Ð¼Ð¸Ð½Ð°ÑÐ¸Ð¾Ñ] dddd [Ð²Ð¾] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ð·Ð° %s',
              past: 'Ð¿ÑÐµÐ´ %s',
              s: 'Ð½ÐµÐºÐ¾Ð»ÐºÑ ÑÐµÐºÑÐ½Ð´Ð¸',
              ss: '%d ÑÐµÐºÑÐ½Ð´Ð¸',
              m: 'ÐµÐ´Ð½Ð° Ð¼Ð¸Ð½ÑÑÐ°',
              mm: '%d Ð¼Ð¸Ð½ÑÑÐ¸',
              h: 'ÐµÐ´ÐµÐ½ ÑÐ°Ñ',
              hh: '%d ÑÐ°ÑÐ°',
              d: 'ÐµÐ´ÐµÐ½ Ð´ÐµÐ½',
              dd: '%d Ð´ÐµÐ½Ð°',
              M: 'ÐµÐ´ÐµÐ½ Ð¼ÐµÑÐµÑ',
              MM: '%d Ð¼ÐµÑÐµÑÐ¸',
              y: 'ÐµÐ´Ð½Ð° Ð³Ð¾Ð´Ð¸Ð½Ð°',
              yy: '%d Ð³Ð¾Ð´Ð¸Ð½Ð¸',
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(ÐµÐ²|ÐµÐ½|ÑÐ¸|Ð²Ð¸|ÑÐ¸|Ð¼Ð¸)/,
          ordinal: function (number) {
              var lastDigit = number % 10,
                  last2Digits = number % 100;
              if (number === 0) {
                  return number + '-ÐµÐ²';
              } else if (last2Digits === 0) {
                  return number + '-ÐµÐ½';
              } else if (last2Digits > 10 && last2Digits < 20) {
                  return number + '-ÑÐ¸';
              } else if (lastDigit === 1) {
                  return number + '-Ð²Ð¸';
              } else if (lastDigit === 2) {
                  return number + '-ÑÐ¸';
              } else if (lastDigit === 7 || lastDigit === 8) {
                  return number + '-Ð¼Ð¸';
              } else {
                  return number + '-ÑÐ¸';
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ml', {
          months: 'à´à´¨àµà´µà´°à´¿_à´«àµà´¬àµà´°àµà´µà´°à´¿_à´®à´¾àµ¼à´àµà´àµ_à´à´ªàµà´°à´¿àµ½_à´®àµà´¯àµ_à´àµàµº_à´àµà´²àµ_à´à´à´¸àµà´±àµà´±àµ_à´¸àµà´ªàµà´±àµà´±à´à´¬àµ¼_à´à´àµà´àµà´¬àµ¼_à´¨à´µà´à´¬àµ¼_à´¡à´¿à´¸à´à´¬àµ¼'.split(
              '_'
          ),
          monthsShort: 'à´à´¨àµ._à´«àµà´¬àµà´°àµ._à´®à´¾àµ¼._à´à´ªàµà´°à´¿._à´®àµà´¯àµ_à´àµàµº_à´àµà´²àµ._à´à´._à´¸àµà´ªàµà´±àµà´±._à´à´àµà´àµ._à´¨à´µà´._à´¡à´¿à´¸à´.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'à´à´¾à´¯à´±à´¾à´´àµà´_à´¤à´¿à´àµà´à´³à´¾à´´àµà´_à´àµà´µàµà´µà´¾à´´àµà´_à´¬àµà´§à´¨à´¾à´´àµà´_à´µàµà´¯à´¾à´´à´¾à´´àµà´_à´µàµà´³àµà´³à´¿à´¯à´¾à´´àµà´_à´¶à´¨à´¿à´¯à´¾à´´àµà´'.split(
              '_'
          ),
          weekdaysShort: 'à´à´¾à´¯àµ¼_à´¤à´¿à´àµà´àµ¾_à´àµà´µàµà´µ_à´¬àµà´§àµ»_à´µàµà´¯à´¾à´´à´_à´µàµà´³àµà´³à´¿_à´¶à´¨à´¿'.split('_'),
          weekdaysMin: 'à´à´¾_à´¤à´¿_à´àµ_à´¬àµ_à´µàµà´¯à´¾_à´µàµ_à´¶'.split('_'),
          longDateFormat: {
              LT: 'A h:mm -à´¨àµ',
              LTS: 'A h:mm:ss -à´¨àµ',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm -à´¨àµ',
              LLLL: 'dddd, D MMMM YYYY, A h:mm -à´¨àµ',
          },
          calendar: {
              sameDay: '[à´à´¨àµà´¨àµ] LT',
              nextDay: '[à´¨à´¾à´³àµ] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à´à´¨àµà´¨à´²àµ] LT',
              lastWeek: '[à´à´´à´¿à´àµà´] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à´à´´à´¿à´àµà´àµ',
              past: '%s à´®àµàµ»à´ªàµ',
              s: 'à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾',
              ss: '%d à´¸àµà´àµà´àµ»à´¡àµ',
              m: 'à´à´°àµ à´®à´¿à´¨à´¿à´±àµà´±àµ',
              mm: '%d à´®à´¿à´¨à´¿à´±àµà´±àµ',
              h: 'à´à´°àµ à´®à´£à´¿à´àµà´àµàµ¼',
              hh: '%d à´®à´£à´¿à´àµà´àµàµ¼',
              d: 'à´à´°àµ à´¦à´¿à´µà´¸à´',
              dd: '%d à´¦à´¿à´µà´¸à´',
              M: 'à´à´°àµ à´®à´¾à´¸à´',
              MM: '%d à´®à´¾à´¸à´',
              y: 'à´à´°àµ à´µàµ¼à´·à´',
              yy: '%d à´µàµ¼à´·à´',
          },
          meridiemParse: /à´°à´¾à´¤àµà´°à´¿|à´°à´¾à´µà´¿à´²àµ|à´à´àµà´ à´à´´à´¿à´àµà´àµ|à´µàµà´àµà´¨àµà´¨àµà´°à´|à´°à´¾à´¤àµà´°à´¿/i,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (
                  (meridiem === 'à´°à´¾à´¤àµà´°à´¿' && hour >= 4) ||
                  meridiem === 'à´à´àµà´ à´à´´à´¿à´àµà´àµ' ||
                  meridiem === 'à´µàµà´àµà´¨àµà´¨àµà´°à´'
              ) {
                  return hour + 12;
              } else {
                  return hour;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à´°à´¾à´¤àµà´°à´¿';
              } else if (hour < 12) {
                  return 'à´°à´¾à´µà´¿à´²àµ';
              } else if (hour < 17) {
                  return 'à´à´àµà´ à´à´´à´¿à´àµà´àµ';
              } else if (hour < 20) {
                  return 'à´µàµà´àµà´¨àµà´¨àµà´°à´';
              } else {
                  return 'à´°à´¾à´¤àµà´°à´¿';
              }
          },
      });

      //! moment.js locale configuration

      function translate$7(number, withoutSuffix, key, isFuture) {
          switch (key) {
              case 's':
                  return withoutSuffix ? 'ÑÑÐ´ÑÑÐ½ ÑÐµÐºÑÐ½Ð´' : 'ÑÑÐ´ÑÑÐ½ ÑÐµÐºÑÐ½Ð´ÑÐ½';
              case 'ss':
                  return number + (withoutSuffix ? ' ÑÐµÐºÑÐ½Ð´' : ' ÑÐµÐºÑÐ½Ð´ÑÐ½');
              case 'm':
              case 'mm':
                  return number + (withoutSuffix ? ' Ð¼Ð¸Ð½ÑÑ' : ' Ð¼Ð¸Ð½ÑÑÑÐ½');
              case 'h':
              case 'hh':
                  return number + (withoutSuffix ? ' ÑÐ°Ð³' : ' ÑÐ°Ð³Ð¸Ð¹Ð½');
              case 'd':
              case 'dd':
                  return number + (withoutSuffix ? ' Ó©Ð´Ó©Ñ' : ' Ó©Ð´ÑÐ¸Ð¹Ð½');
              case 'M':
              case 'MM':
                  return number + (withoutSuffix ? ' ÑÐ°Ñ' : ' ÑÐ°ÑÑÐ½');
              case 'y':
              case 'yy':
                  return number + (withoutSuffix ? ' Ð¶Ð¸Ð»' : ' Ð¶Ð¸Ð»Ð¸Ð¹Ð½');
              default:
                  return number;
          }
      }

      hooks.defineLocale('mn', {
          months: 'ÐÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ_Ð¥Ð¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ_ÐÑÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ_ÐÓ©ÑÓ©Ð²Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ_Ð¢Ð°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ_ÐÑÑÐ³Ð°Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ_ÐÐ¾Ð»Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ_ÐÐ°Ð¹Ð¼Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ_ÐÑÐ´Ò¯Ð³ÑÑÑ ÑÐ°Ñ_ÐÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ_ÐÑÐ²Ð°Ð½ Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ_ÐÑÐ²Ð°Ð½ ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ'.split(
              '_'
          ),
          monthsShort: '1 ÑÐ°Ñ_2 ÑÐ°Ñ_3 ÑÐ°Ñ_4 ÑÐ°Ñ_5 ÑÐ°Ñ_6 ÑÐ°Ñ_7 ÑÐ°Ñ_8 ÑÐ°Ñ_9 ÑÐ°Ñ_10 ÑÐ°Ñ_11 ÑÐ°Ñ_12 ÑÐ°Ñ'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'ÐÑÐ¼_ÐÐ°Ð²Ð°Ð°_ÐÑÐ³Ð¼Ð°Ñ_ÐÑÐ°Ð³Ð²Ð°_ÐÒ¯ÑÑÐ²_ÐÐ°Ð°ÑÐ°Ð½_ÐÑÐ¼Ð±Ð°'.split('_'),
          weekdaysShort: 'ÐÑÐ¼_ÐÐ°Ð²_ÐÑÐ³_ÐÑÐ°_ÐÒ¯Ñ_ÐÐ°Ð°_ÐÑÐ¼'.split('_'),
          weekdaysMin: 'ÐÑ_ÐÐ°_ÐÑ_ÐÑ_ÐÒ¯_ÐÐ°_ÐÑ'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY-MM-DD',
              LL: 'YYYY Ð¾Ð½Ñ MMMMÑÐ½ D',
              LLL: 'YYYY Ð¾Ð½Ñ MMMMÑÐ½ D HH:mm',
              LLLL: 'dddd, YYYY Ð¾Ð½Ñ MMMMÑÐ½ D HH:mm',
          },
          meridiemParse: /Ò®Ó¨|Ò®Ð¥/i,
          isPM: function (input) {
              return input === 'Ò®Ð¥';
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'Ò®Ó¨';
              } else {
                  return 'Ò®Ð¥';
              }
          },
          calendar: {
              sameDay: '[Ó¨Ð½Ó©Ó©Ð´Ó©Ñ] LT',
              nextDay: '[ÐÐ°ÑÐ³Ð°Ð°Ñ] LT',
              nextWeek: '[ÐÑÑÑ] dddd LT',
              lastDay: '[Ó¨ÑÐ¸Ð³Ð´Ó©Ñ] LT',
              lastWeek: '[Ó¨Ð½Ð³Ó©ÑÑÓ©Ð½] dddd LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s Ð´Ð°ÑÐ°Ð°',
              past: '%s Ó©Ð¼Ð½Ó©',
              s: translate$7,
              ss: translate$7,
              m: translate$7,
              mm: translate$7,
              h: translate$7,
              hh: translate$7,
              d: translate$7,
              dd: translate$7,
              M: translate$7,
              MM: translate$7,
              y: translate$7,
              yy: translate$7,
          },
          dayOfMonthOrdinalParse: /\d{1,2} Ó©Ð´Ó©Ñ/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + ' Ó©Ð´Ó©Ñ';
                  default:
                      return number;
              }
          },
      });

      //! moment.js locale configuration

      var symbolMap$c = {
              1: 'à¥§',
              2: 'à¥¨',
              3: 'à¥©',
              4: 'à¥ª',
              5: 'à¥«',
              6: 'à¥¬',
              7: 'à¥­',
              8: 'à¥®',
              9: 'à¥¯',
              0: 'à¥¦',
          },
          numberMap$b = {
              'à¥§': '1',
              'à¥¨': '2',
              'à¥©': '3',
              'à¥ª': '4',
              'à¥«': '5',
              'à¥¬': '6',
              'à¥­': '7',
              'à¥®': '8',
              'à¥¯': '9',
              'à¥¦': '0',
          };

      function relativeTimeMr(number, withoutSuffix, string, isFuture) {
          var output = '';
          if (withoutSuffix) {
              switch (string) {
                  case 's':
                      output = 'à¤à¤¾à¤¹à¥ à¤¸à¥à¤à¤à¤¦';
                      break;
                  case 'ss':
                      output = '%d à¤¸à¥à¤à¤à¤¦';
                      break;
                  case 'm':
                      output = 'à¤à¤ à¤®à¤¿à¤¨à¤¿à¤';
                      break;
                  case 'mm':
                      output = '%d à¤®à¤¿à¤¨à¤¿à¤à¥';
                      break;
                  case 'h':
                      output = 'à¤à¤ à¤¤à¤¾à¤¸';
                      break;
                  case 'hh':
                      output = '%d à¤¤à¤¾à¤¸';
                      break;
                  case 'd':
                      output = 'à¤à¤ à¤¦à¤¿à¤µà¤¸';
                      break;
                  case 'dd':
                      output = '%d à¤¦à¤¿à¤µà¤¸';
                      break;
                  case 'M':
                      output = 'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾';
                      break;
                  case 'MM':
                      output = '%d à¤®à¤¹à¤¿à¤¨à¥';
                      break;
                  case 'y':
                      output = 'à¤à¤ à¤µà¤°à¥à¤·';
                      break;
                  case 'yy':
                      output = '%d à¤µà¤°à¥à¤·à¥';
                      break;
              }
          } else {
              switch (string) {
                  case 's':
                      output = 'à¤à¤¾à¤¹à¥ à¤¸à¥à¤à¤à¤¦à¤¾à¤';
                      break;
                  case 'ss':
                      output = '%d à¤¸à¥à¤à¤à¤¦à¤¾à¤';
                      break;
                  case 'm':
                      output = 'à¤à¤à¤¾ à¤®à¤¿à¤¨à¤¿à¤à¤¾';
                      break;
                  case 'mm':
                      output = '%d à¤®à¤¿à¤¨à¤¿à¤à¤¾à¤';
                      break;
                  case 'h':
                      output = 'à¤à¤à¤¾ à¤¤à¤¾à¤¸à¤¾';
                      break;
                  case 'hh':
                      output = '%d à¤¤à¤¾à¤¸à¤¾à¤';
                      break;
                  case 'd':
                      output = 'à¤à¤à¤¾ à¤¦à¤¿à¤µà¤¸à¤¾';
                      break;
                  case 'dd':
                      output = '%d à¤¦à¤¿à¤µà¤¸à¤¾à¤';
                      break;
                  case 'M':
                      output = 'à¤à¤à¤¾ à¤®à¤¹à¤¿à¤¨à¥à¤¯à¤¾';
                      break;
                  case 'MM':
                      output = '%d à¤®à¤¹à¤¿à¤¨à¥à¤¯à¤¾à¤';
                      break;
                  case 'y':
                      output = 'à¤à¤à¤¾ à¤µà¤°à¥à¤·à¤¾';
                      break;
                  case 'yy':
                      output = '%d à¤µà¤°à¥à¤·à¤¾à¤';
                      break;
              }
          }
          return output.replace(/%d/i, number);
      }

      hooks.defineLocale('mr', {
          months: 'à¤à¤¾à¤¨à¥à¤µà¤¾à¤°à¥_à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿à¤²_à¤®à¥_à¤à¥à¤¨_à¤à¥à¤²à¥_à¤à¤à¤¸à¥à¤_à¤¸à¤ªà¥à¤à¥à¤à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¥à¤µà¥à¤¹à¥à¤à¤¬à¤°_à¤¡à¤¿à¤¸à¥à¤à¤¬à¤°'.split(
              '_'
          ),
          monthsShort: 'à¤à¤¾à¤¨à¥._à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤._à¤à¤ªà¥à¤°à¤¿._à¤®à¥._à¤à¥à¤¨._à¤à¥à¤²à¥._à¤à¤._à¤¸à¤ªà¥à¤à¥à¤._à¤à¤à¥à¤à¥._à¤¨à¥à¤µà¥à¤¹à¥à¤._à¤¡à¤¿à¤¸à¥à¤.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'à¤°à¤µà¤¿à¤µà¤¾à¤°_à¤¸à¥à¤®à¤µà¤¾à¤°_à¤®à¤à¤à¤³à¤µà¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤à¥à¤°à¥à¤µà¤¾à¤°_à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤°_à¤¶à¤¨à¤¿à¤µà¤¾à¤°'.split('_'),
          weekdaysShort: 'à¤°à¤µà¤¿_à¤¸à¥à¤®_à¤®à¤à¤à¤³_à¤¬à¥à¤§_à¤à¥à¤°à¥_à¤¶à¥à¤à¥à¤°_à¤¶à¤¨à¤¿'.split('_'),
          weekdaysMin: 'à¤°_à¤¸à¥_à¤®à¤_à¤¬à¥_à¤à¥_à¤¶à¥_à¤¶'.split('_'),
          longDateFormat: {
              LT: 'A h:mm à¤µà¤¾à¤à¤¤à¤¾',
              LTS: 'A h:mm:ss à¤µà¤¾à¤à¤¤à¤¾',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm à¤µà¤¾à¤à¤¤à¤¾',
              LLLL: 'dddd, D MMMM YYYY, A h:mm à¤µà¤¾à¤à¤¤à¤¾',
          },
          calendar: {
              sameDay: '[à¤à¤] LT',
              nextDay: '[à¤à¤¦à¥à¤¯à¤¾] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à¤à¤¾à¤²] LT',
              lastWeek: '[à¤®à¤¾à¤à¥à¤²] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%sà¤®à¤§à¥à¤¯à¥',
              past: '%sà¤ªà¥à¤°à¥à¤µà¥',
              s: relativeTimeMr,
              ss: relativeTimeMr,
              m: relativeTimeMr,
              mm: relativeTimeMr,
              h: relativeTimeMr,
              hh: relativeTimeMr,
              d: relativeTimeMr,
              dd: relativeTimeMr,
              M: relativeTimeMr,
              MM: relativeTimeMr,
              y: relativeTimeMr,
              yy: relativeTimeMr,
          },
          preparse: function (string) {
              return string.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function (match) {
                  return numberMap$b[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$c[match];
              });
          },
          meridiemParse: /à¤ªà¤¹à¤¾à¤à¥|à¤¸à¤à¤¾à¤³à¥|à¤¦à¥à¤ªà¤¾à¤°à¥|à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥|à¤°à¤¾à¤¤à¥à¤°à¥/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à¤ªà¤¹à¤¾à¤à¥' || meridiem === 'à¤¸à¤à¤¾à¤³à¥') {
                  return hour;
              } else if (
                  meridiem === 'à¤¦à¥à¤ªà¤¾à¤°à¥' ||
                  meridiem === 'à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥' ||
                  meridiem === 'à¤°à¤¾à¤¤à¥à¤°à¥'
              ) {
                  return hour >= 12 ? hour : hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour >= 0 && hour < 6) {
                  return 'à¤ªà¤¹à¤¾à¤à¥';
              } else if (hour < 12) {
                  return 'à¤¸à¤à¤¾à¤³à¥';
              } else if (hour < 17) {
                  return 'à¤¦à¥à¤ªà¤¾à¤°à¥';
              } else if (hour < 20) {
                  return 'à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥';
              } else {
                  return 'à¤°à¤¾à¤¤à¥à¤°à¥';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ms-my', {
          months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
          weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
          weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
          weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
          longDateFormat: {
              LT: 'HH.mm',
              LTS: 'HH.mm.ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY [pukul] HH.mm',
              LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
          },
          meridiemParse: /pagi|tengahari|petang|malam/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'pagi') {
                  return hour;
              } else if (meridiem === 'tengahari') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'petang' || meridiem === 'malam') {
                  return hour + 12;
              }
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours < 11) {
                  return 'pagi';
              } else if (hours < 15) {
                  return 'tengahari';
              } else if (hours < 19) {
                  return 'petang';
              } else {
                  return 'malam';
              }
          },
          calendar: {
              sameDay: '[Hari ini pukul] LT',
              nextDay: '[Esok pukul] LT',
              nextWeek: 'dddd [pukul] LT',
              lastDay: '[Kelmarin pukul] LT',
              lastWeek: 'dddd [lepas pukul] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'dalam %s',
              past: '%s yang lepas',
              s: 'beberapa saat',
              ss: '%d saat',
              m: 'seminit',
              mm: '%d minit',
              h: 'sejam',
              hh: '%d jam',
              d: 'sehari',
              dd: '%d hari',
              M: 'sebulan',
              MM: '%d bulan',
              y: 'setahun',
              yy: '%d tahun',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ms', {
          months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
          weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
          weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
          weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
          longDateFormat: {
              LT: 'HH.mm',
              LTS: 'HH.mm.ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY [pukul] HH.mm',
              LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
          },
          meridiemParse: /pagi|tengahari|petang|malam/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'pagi') {
                  return hour;
              } else if (meridiem === 'tengahari') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'petang' || meridiem === 'malam') {
                  return hour + 12;
              }
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours < 11) {
                  return 'pagi';
              } else if (hours < 15) {
                  return 'tengahari';
              } else if (hours < 19) {
                  return 'petang';
              } else {
                  return 'malam';
              }
          },
          calendar: {
              sameDay: '[Hari ini pukul] LT',
              nextDay: '[Esok pukul] LT',
              nextWeek: 'dddd [pukul] LT',
              lastDay: '[Kelmarin pukul] LT',
              lastWeek: 'dddd [lepas pukul] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'dalam %s',
              past: '%s yang lepas',
              s: 'beberapa saat',
              ss: '%d saat',
              m: 'seminit',
              mm: '%d minit',
              h: 'sejam',
              hh: '%d jam',
              d: 'sehari',
              dd: '%d hari',
              M: 'sebulan',
              MM: '%d bulan',
              y: 'setahun',
              yy: '%d tahun',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('mt', {
          months: 'Jannar_Frar_Marzu_April_Mejju_Ä unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_DiÄembru'.split(
              '_'
          ),
          monthsShort: 'Jan_Fra_Mar_Apr_Mej_Ä un_Lul_Aww_Set_Ott_Nov_DiÄ'.split('_'),
          weekdays: 'Il-Ä¦add_It-Tnejn_It-Tlieta_L-ErbgÄ§a_Il-Ä¦amis_Il-Ä imgÄ§a_Is-Sibt'.split(
              '_'
          ),
          weekdaysShort: 'Ä¦ad_Tne_Tli_Erb_Ä¦am_Ä im_Sib'.split('_'),
          weekdaysMin: 'Ä¦a_Tn_Tl_Er_Ä¦a_Ä i_Si'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Illum fil-]LT',
              nextDay: '[GÄ§ada fil-]LT',
              nextWeek: 'dddd [fil-]LT',
              lastDay: '[Il-bieraÄ§ fil-]LT',
              lastWeek: 'dddd [li gÄ§adda] [fil-]LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'fâ %s',
              past: '%s ilu',
              s: 'ftit sekondi',
              ss: '%d sekondi',
              m: 'minuta',
              mm: '%d minuti',
              h: 'siegÄ§a',
              hh: '%d siegÄ§at',
              d: 'Ä¡urnata',
              dd: '%d Ä¡ranet',
              M: 'xahar',
              MM: '%d xhur',
              y: 'sena',
              yy: '%d sni',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$d = {
              1: 'á',
              2: 'á',
              3: 'á',
              4: 'á',
              5: 'á',
              6: 'á',
              7: 'á',
              8: 'á',
              9: 'á',
              0: 'á',
          },
          numberMap$c = {
              'á': '1',
              'á': '2',
              'á': '3',
              'á': '4',
              'á': '5',
              'á': '6',
              'á': '7',
              'á': '8',
              'á': '9',
              'á': '0',
          };

      hooks.defineLocale('my', {
          months: 'áááºááá«áá®_áá±áá±á¬áºáá«áá®_áááº_á§áá¼á®_áá±_áá½ááº_áá°áá­á¯ááº_áá¼áá¯ááº_áááºáááºáá¬_á¡á±á¬ááºáá­á¯áá¬_áá­á¯áááºáá¬_áá®áááºáá¬'.split(
              '_'
          ),
          monthsShort: 'áááº_áá±_áááº_áá¼á®_áá±_áá½ááº_áá­á¯ááº_áá¼_áááº_á¡á±á¬ááº_áá­á¯_áá®'.split('_'),
          weekdays: 'ááááºá¹ááá½á±_ááááºá¹áá¬_á¡ááºá¹áá«_áá¯áá¹ááá°á¸_áá¼á¬áááá±á¸_áá±á¬áá¼á¬_ááá±'.split(
              '_'
          ),
          weekdaysShort: 'áá½á±_áá¬_áá«_áá°á¸_áá¼á¬_áá±á¬_áá±'.split('_'),
          weekdaysMin: 'áá½á±_áá¬_áá«_áá°á¸_áá¼á¬_áá±á¬_áá±'.split('_'),

          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[ááá±.] LT [áá¾á¬]',
              nextDay: '[ááááºáá¼ááº] LT [áá¾á¬]',
              nextWeek: 'dddd LT [áá¾á¬]',
              lastDay: '[ááá±.á] LT [áá¾á¬]',
              lastWeek: '[áá¼á®á¸áá²á·áá±á¬] dddd LT [áá¾á¬]',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'áá¬áááºá· %s áá¾á¬',
              past: 'áá½ááºáá²á·áá±á¬ %s á',
              s: 'ááá¹áááº.á¡áááºá¸áááº',
              ss: '%d ááá¹ááá·áº',
              m: 'áááºáá­áááº',
              mm: '%d áá­áááº',
              h: 'áááºáá¬áá®',
              hh: '%d áá¬áá®',
              d: 'áááºáááº',
              dd: '%d áááº',
              M: 'áááºá',
              MM: '%d á',
              y: 'áááºáá¾ááº',
              yy: '%d áá¾ááº',
          },
          preparse: function (string) {
              return string.replace(/[áááááááááá]/g, function (match) {
                  return numberMap$c[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$d[match];
              });
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('nb', {
          months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
              '_'
          ),
          monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'sÃ¸ndag_mandag_tirsdag_onsdag_torsdag_fredag_lÃ¸rdag'.split('_'),
          weekdaysShort: 'sÃ¸._ma._ti._on._to._fr._lÃ¸.'.split('_'),
          weekdaysMin: 'sÃ¸_ma_ti_on_to_fr_lÃ¸'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY [kl.] HH:mm',
              LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
          },
          calendar: {
              sameDay: '[i dag kl.] LT',
              nextDay: '[i morgen kl.] LT',
              nextWeek: 'dddd [kl.] LT',
              lastDay: '[i gÃ¥r kl.] LT',
              lastWeek: '[forrige] dddd [kl.] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'om %s',
              past: '%s siden',
              s: 'noen sekunder',
              ss: '%d sekunder',
              m: 'ett minutt',
              mm: '%d minutter',
              h: 'en time',
              hh: '%d timer',
              d: 'en dag',
              dd: '%d dager',
              w: 'en uke',
              ww: '%d uker',
              M: 'en mÃ¥ned',
              MM: '%d mÃ¥neder',
              y: 'ett Ã¥r',
              yy: '%d Ã¥r',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$e = {
              1: 'à¥§',
              2: 'à¥¨',
              3: 'à¥©',
              4: 'à¥ª',
              5: 'à¥«',
              6: 'à¥¬',
              7: 'à¥­',
              8: 'à¥®',
              9: 'à¥¯',
              0: 'à¥¦',
          },
          numberMap$d = {
              'à¥§': '1',
              'à¥¨': '2',
              'à¥©': '3',
              'à¥ª': '4',
              'à¥«': '5',
              'à¥¬': '6',
              'à¥­': '7',
              'à¥®': '8',
              'à¥¯': '9',
              'à¥¦': '0',
          };

      hooks.defineLocale('ne', {
          months: 'à¤à¤¨à¤µà¤°à¥_à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿à¤²_à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤_à¤à¤à¤·à¥à¤_à¤¸à¥à¤ªà¥à¤à¥à¤®à¥à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¥à¤­à¥à¤®à¥à¤¬à¤°_à¤¡à¤¿à¤¸à¥à¤®à¥à¤¬à¤°'.split(
              '_'
          ),
          monthsShort: 'à¤à¤¨._à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿._à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤._à¤à¤._à¤¸à¥à¤ªà¥à¤._à¤à¤à¥à¤à¥._à¤¨à¥à¤­à¥._à¤¡à¤¿à¤¸à¥.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'à¤à¤à¤¤à¤¬à¤¾à¤°_à¤¸à¥à¤®à¤¬à¤¾à¤°_à¤®à¤à¥à¤à¤²à¤¬à¤¾à¤°_à¤¬à¥à¤§à¤¬à¤¾à¤°_à¤¬à¤¿à¤¹à¤¿à¤¬à¤¾à¤°_à¤¶à¥à¤à¥à¤°à¤¬à¤¾à¤°_à¤¶à¤¨à¤¿à¤¬à¤¾à¤°'.split(
              '_'
          ),
          weekdaysShort: 'à¤à¤à¤¤._à¤¸à¥à¤®._à¤®à¤à¥à¤à¤²._à¤¬à¥à¤§._à¤¬à¤¿à¤¹à¤¿._à¤¶à¥à¤à¥à¤°._à¤¶à¤¨à¤¿.'.split('_'),
          weekdaysMin: 'à¤._à¤¸à¥._à¤®à¤._à¤¬à¥._à¤¬à¤¿._à¤¶à¥._à¤¶.'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'Aà¤à¥ h:mm à¤¬à¤à¥',
              LTS: 'Aà¤à¥ h:mm:ss à¤¬à¤à¥',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, Aà¤à¥ h:mm à¤¬à¤à¥',
              LLLL: 'dddd, D MMMM YYYY, Aà¤à¥ h:mm à¤¬à¤à¥',
          },
          preparse: function (string) {
              return string.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function (match) {
                  return numberMap$d[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$e[match];
              });
          },
          meridiemParse: /à¤°à¤¾à¤¤à¤¿|à¤¬à¤¿à¤¹à¤¾à¤¨|à¤¦à¤¿à¤à¤à¤¸à¥|à¤¸à¤¾à¤à¤/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à¤°à¤¾à¤¤à¤¿') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'à¤¬à¤¿à¤¹à¤¾à¤¨') {
                  return hour;
              } else if (meridiem === 'à¤¦à¤¿à¤à¤à¤¸à¥') {
                  return hour >= 10 ? hour : hour + 12;
              } else if (meridiem === 'à¤¸à¤¾à¤à¤') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 3) {
                  return 'à¤°à¤¾à¤¤à¤¿';
              } else if (hour < 12) {
                  return 'à¤¬à¤¿à¤¹à¤¾à¤¨';
              } else if (hour < 16) {
                  return 'à¤¦à¤¿à¤à¤à¤¸à¥';
              } else if (hour < 20) {
                  return 'à¤¸à¤¾à¤à¤';
              } else {
                  return 'à¤°à¤¾à¤¤à¤¿';
              }
          },
          calendar: {
              sameDay: '[à¤à¤] LT',
              nextDay: '[à¤­à¥à¤²à¤¿] LT',
              nextWeek: '[à¤à¤à¤à¤¦à¥] dddd[,] LT',
              lastDay: '[à¤¹à¤¿à¤à¥] LT',
              lastWeek: '[à¤à¤à¤à¥] dddd[,] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%sà¤®à¤¾',
              past: '%s à¤à¤à¤¾à¤¡à¤¿',
              s: 'à¤à¥à¤¹à¥ à¤à¥à¤·à¤£',
              ss: '%d à¤¸à¥à¤à¥à¤£à¥à¤¡',
              m: 'à¤à¤ à¤®à¤¿à¤¨à¥à¤',
              mm: '%d à¤®à¤¿à¤¨à¥à¤',
              h: 'à¤à¤ à¤à¤£à¥à¤à¤¾',
              hh: '%d à¤à¤£à¥à¤à¤¾',
              d: 'à¤à¤ à¤¦à¤¿à¤¨',
              dd: '%d à¤¦à¤¿à¤¨',
              M: 'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾',
              MM: '%d à¤®à¤¹à¤¿à¤¨à¤¾',
              y: 'à¤à¤ à¤¬à¤°à¥à¤·',
              yy: '%d à¤¬à¤°à¥à¤·',
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsShortWithDots$1 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
              '_'
          ),
          monthsShortWithoutDots$1 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
              '_'
          ),
          monthsParse$8 = [
              /^jan/i,
              /^feb/i,
              /^maart|mrt.?$/i,
              /^apr/i,
              /^mei$/i,
              /^jun[i.]?$/i,
              /^jul[i.]?$/i,
              /^aug/i,
              /^sep/i,
              /^okt/i,
              /^nov/i,
              /^dec/i,
          ],
          monthsRegex$8 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

      hooks.defineLocale('nl-be', {
          months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortWithDots$1;
              } else if (/-MMM-/.test(format)) {
                  return monthsShortWithoutDots$1[m.month()];
              } else {
                  return monthsShortWithDots$1[m.month()];
              }
          },

          monthsRegex: monthsRegex$8,
          monthsShortRegex: monthsRegex$8,
          monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
          monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

          monthsParse: monthsParse$8,
          longMonthsParse: monthsParse$8,
          shortMonthsParse: monthsParse$8,

          weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
              '_'
          ),
          weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
          weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[vandaag om] LT',
              nextDay: '[morgen om] LT',
              nextWeek: 'dddd [om] LT',
              lastDay: '[gisteren om] LT',
              lastWeek: '[afgelopen] dddd [om] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'over %s',
              past: '%s geleden',
              s: 'een paar seconden',
              ss: '%d seconden',
              m: 'Ã©Ã©n minuut',
              mm: '%d minuten',
              h: 'Ã©Ã©n uur',
              hh: '%d uur',
              d: 'Ã©Ã©n dag',
              dd: '%d dagen',
              M: 'Ã©Ã©n maand',
              MM: '%d maanden',
              y: 'Ã©Ã©n jaar',
              yy: '%d jaar',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
          ordinal: function (number) {
              return (
                  number +
                  (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
              );
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsShortWithDots$2 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
              '_'
          ),
          monthsShortWithoutDots$2 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
              '_'
          ),
          monthsParse$9 = [
              /^jan/i,
              /^feb/i,
              /^maart|mrt.?$/i,
              /^apr/i,
              /^mei$/i,
              /^jun[i.]?$/i,
              /^jul[i.]?$/i,
              /^aug/i,
              /^sep/i,
              /^okt/i,
              /^nov/i,
              /^dec/i,
          ],
          monthsRegex$9 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

      hooks.defineLocale('nl', {
          months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortWithDots$2;
              } else if (/-MMM-/.test(format)) {
                  return monthsShortWithoutDots$2[m.month()];
              } else {
                  return monthsShortWithDots$2[m.month()];
              }
          },

          monthsRegex: monthsRegex$9,
          monthsShortRegex: monthsRegex$9,
          monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
          monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

          monthsParse: monthsParse$9,
          longMonthsParse: monthsParse$9,
          shortMonthsParse: monthsParse$9,

          weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
              '_'
          ),
          weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
          weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD-MM-YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[vandaag om] LT',
              nextDay: '[morgen om] LT',
              nextWeek: 'dddd [om] LT',
              lastDay: '[gisteren om] LT',
              lastWeek: '[afgelopen] dddd [om] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'over %s',
              past: '%s geleden',
              s: 'een paar seconden',
              ss: '%d seconden',
              m: 'Ã©Ã©n minuut',
              mm: '%d minuten',
              h: 'Ã©Ã©n uur',
              hh: '%d uur',
              d: 'Ã©Ã©n dag',
              dd: '%d dagen',
              w: 'Ã©Ã©n week',
              ww: '%d weken',
              M: 'Ã©Ã©n maand',
              MM: '%d maanden',
              y: 'Ã©Ã©n jaar',
              yy: '%d jaar',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
          ordinal: function (number) {
              return (
                  number +
                  (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
              );
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('nn', {
          months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
              '_'
          ),
          monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'sundag_mÃ¥ndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
          weekdaysShort: 'su._mÃ¥._ty._on._to._fr._lau.'.split('_'),
          weekdaysMin: 'su_mÃ¥_ty_on_to_fr_la'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY [kl.] H:mm',
              LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
          },
          calendar: {
              sameDay: '[I dag klokka] LT',
              nextDay: '[I morgon klokka] LT',
              nextWeek: 'dddd [klokka] LT',
              lastDay: '[I gÃ¥r klokka] LT',
              lastWeek: '[FÃ¸regÃ¥ande] dddd [klokka] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'om %s',
              past: '%s sidan',
              s: 'nokre sekund',
              ss: '%d sekund',
              m: 'eit minutt',
              mm: '%d minutt',
              h: 'ein time',
              hh: '%d timar',
              d: 'ein dag',
              dd: '%d dagar',
              w: 'ei veke',
              ww: '%d veker',
              M: 'ein mÃ¥nad',
              MM: '%d mÃ¥nader',
              y: 'eit Ã¥r',
              yy: '%d Ã¥r',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('oc-lnc', {
          months: {
              standalone: 'geniÃ¨r_febriÃ¨r_marÃ§_abril_mai_junh_julhet_agost_setembre_octÃ²bre_novembre_decembre'.split(
                  '_'
              ),
              format: "de geniÃ¨r_de febriÃ¨r_de marÃ§_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octÃ²bre_de novembre_de decembre".split(
                  '_'
              ),
              isFormat: /D[oD]?(\s)+MMMM/,
          },
          monthsShort: 'gen._febr._marÃ§_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'dimenge_diluns_dimars_dimÃ¨cres_dijÃ²us_divendres_dissabte'.split(
              '_'
          ),
          weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
          weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM [de] YYYY',
              ll: 'D MMM YYYY',
              LLL: 'D MMMM [de] YYYY [a] H:mm',
              lll: 'D MMM YYYY, H:mm',
              LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
              llll: 'ddd D MMM YYYY, H:mm',
          },
          calendar: {
              sameDay: '[uÃ¨i a] LT',
              nextDay: '[deman a] LT',
              nextWeek: 'dddd [a] LT',
              lastDay: '[iÃ¨r a] LT',
              lastWeek: 'dddd [passat a] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: "d'aquÃ­ %s",
              past: 'fa %s',
              s: 'unas segondas',
              ss: '%d segondas',
              m: 'una minuta',
              mm: '%d minutas',
              h: 'una ora',
              hh: '%d oras',
              d: 'un jorn',
              dd: '%d jorns',
              M: 'un mes',
              MM: '%d meses',
              y: 'un an',
              yy: '%d ans',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|Ã¨|a)/,
          ordinal: function (number, period) {
              var output =
                  number === 1
                      ? 'r'
                      : number === 2
                      ? 'n'
                      : number === 3
                      ? 'r'
                      : number === 4
                      ? 't'
                      : 'Ã¨';
              if (period === 'w' || period === 'W') {
                  output = 'a';
              }
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4,
          },
      });

      //! moment.js locale configuration

      var symbolMap$f = {
              1: 'à©§',
              2: 'à©¨',
              3: 'à©©',
              4: 'à©ª',
              5: 'à©«',
              6: 'à©¬',
              7: 'à©­',
              8: 'à©®',
              9: 'à©¯',
              0: 'à©¦',
          },
          numberMap$e = {
              'à©§': '1',
              'à©¨': '2',
              'à©©': '3',
              'à©ª': '4',
              'à©«': '5',
              'à©¬': '6',
              'à©­': '7',
              'à©®': '8',
              'à©¯': '9',
              'à©¦': '0',
          };

      hooks.defineLocale('pa-in', {
          // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
          months: 'à¨à¨¨à¨µà¨°à©_à¨«à¨¼à¨°à¨µà¨°à©_à¨®à¨¾à¨°à¨_à¨à¨ªà©à¨°à©à¨²_à¨®à¨_à¨à©à¨¨_à¨à©à¨²à¨¾à¨_à¨à¨à¨¸à¨¤_à¨¸à¨¤à©°à¨¬à¨°_à¨à¨à¨¤à©à¨¬à¨°_à¨¨à¨µà©°à¨¬à¨°_à¨¦à¨¸à©°à¨¬à¨°'.split(
              '_'
          ),
          monthsShort: 'à¨à¨¨à¨µà¨°à©_à¨«à¨¼à¨°à¨µà¨°à©_à¨®à¨¾à¨°à¨_à¨à¨ªà©à¨°à©à¨²_à¨®à¨_à¨à©à¨¨_à¨à©à¨²à¨¾à¨_à¨à¨à¨¸à¨¤_à¨¸à¨¤à©°à¨¬à¨°_à¨à¨à¨¤à©à¨¬à¨°_à¨¨à¨µà©°à¨¬à¨°_à¨¦à¨¸à©°à¨¬à¨°'.split(
              '_'
          ),
          weekdays: 'à¨à¨¤à¨µà¨¾à¨°_à¨¸à©à¨®à¨µà¨¾à¨°_à¨®à©°à¨à¨²à¨µà¨¾à¨°_à¨¬à©à¨§à¨µà¨¾à¨°_à¨µà©à¨°à¨µà¨¾à¨°_à¨¸à¨¼à©à©±à¨à¨°à¨µà¨¾à¨°_à¨¸à¨¼à¨¨à©à¨à¨°à¨µà¨¾à¨°'.split(
              '_'
          ),
          weekdaysShort: 'à¨à¨¤_à¨¸à©à¨®_à¨®à©°à¨à¨²_à¨¬à©à¨§_à¨µà©à¨°_à¨¸à¨¼à©à¨à¨°_à¨¸à¨¼à¨¨à©'.split('_'),
          weekdaysMin: 'à¨à¨¤_à¨¸à©à¨®_à¨®à©°à¨à¨²_à¨¬à©à¨§_à¨µà©à¨°_à¨¸à¨¼à©à¨à¨°_à¨¸à¨¼à¨¨à©'.split('_'),
          longDateFormat: {
              LT: 'A h:mm à¨µà¨à©',
              LTS: 'A h:mm:ss à¨µà¨à©',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm à¨µà¨à©',
              LLLL: 'dddd, D MMMM YYYY, A h:mm à¨µà¨à©',
          },
          calendar: {
              sameDay: '[à¨à¨] LT',
              nextDay: '[à¨à¨²] LT',
              nextWeek: '[à¨à¨à¨²à¨¾] dddd, LT',
              lastDay: '[à¨à¨²] LT',
              lastWeek: '[à¨ªà¨¿à¨à¨²à©] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à¨µà¨¿à©±à¨',
              past: '%s à¨ªà¨¿à¨à¨²à©',
              s: 'à¨à©à¨ à¨¸à¨à¨¿à©°à¨',
              ss: '%d à¨¸à¨à¨¿à©°à¨',
              m: 'à¨à¨ à¨®à¨¿à©°à¨',
              mm: '%d à¨®à¨¿à©°à¨',
              h: 'à¨à©±à¨ à¨à©°à¨à¨¾',
              hh: '%d à¨à©°à¨à©',
              d: 'à¨à©±à¨ à¨¦à¨¿à¨¨',
              dd: '%d à¨¦à¨¿à¨¨',
              M: 'à¨à©±à¨ à¨®à¨¹à©à¨¨à¨¾',
              MM: '%d à¨®à¨¹à©à¨¨à©',
              y: 'à¨à©±à¨ à¨¸à¨¾à¨²',
              yy: '%d à¨¸à¨¾à¨²',
          },
          preparse: function (string) {
              return string.replace(/[à©§à©¨à©©à©ªà©«à©¬à©­à©®à©¯à©¦]/g, function (match) {
                  return numberMap$e[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$f[match];
              });
          },
          // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
          // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
          meridiemParse: /à¨°à¨¾à¨¤|à¨¸à¨µà©à¨°|à¨¦à©à¨ªà¨¹à¨¿à¨°|à¨¸à¨¼à¨¾à¨®/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à¨°à¨¾à¨¤') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'à¨¸à¨µà©à¨°') {
                  return hour;
              } else if (meridiem === 'à¨¦à©à¨ªà¨¹à¨¿à¨°') {
                  return hour >= 10 ? hour : hour + 12;
              } else if (meridiem === 'à¨¸à¨¼à¨¾à¨®') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à¨°à¨¾à¨¤';
              } else if (hour < 10) {
                  return 'à¨¸à¨µà©à¨°';
              } else if (hour < 17) {
                  return 'à¨¦à©à¨ªà¨¹à¨¿à¨°';
              } else if (hour < 20) {
                  return 'à¨¸à¨¼à¨¾à¨®';
              } else {
                  return 'à¨°à¨¾à¨¤';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var monthsNominative = 'styczeÅ_luty_marzec_kwiecieÅ_maj_czerwiec_lipiec_sierpieÅ_wrzesieÅ_paÅºdziernik_listopad_grudzieÅ'.split(
              '_'
          ),
          monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzeÅnia_paÅºdziernika_listopada_grudnia'.split(
              '_'
          ),
          monthsParse$a = [
              /^sty/i,
              /^lut/i,
              /^mar/i,
              /^kwi/i,
              /^maj/i,
              /^cze/i,
              /^lip/i,
              /^sie/i,
              /^wrz/i,
              /^paÅº/i,
              /^lis/i,
              /^gru/i,
          ];
      function plural$3(n) {
          return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
      }
      function translate$8(number, withoutSuffix, key) {
          var result = number + ' ';
          switch (key) {
              case 'ss':
                  return result + (plural$3(number) ? 'sekundy' : 'sekund');
              case 'm':
                  return withoutSuffix ? 'minuta' : 'minutÄ';
              case 'mm':
                  return result + (plural$3(number) ? 'minuty' : 'minut');
              case 'h':
                  return withoutSuffix ? 'godzina' : 'godzinÄ';
              case 'hh':
                  return result + (plural$3(number) ? 'godziny' : 'godzin');
              case 'ww':
                  return result + (plural$3(number) ? 'tygodnie' : 'tygodni');
              case 'MM':
                  return result + (plural$3(number) ? 'miesiÄce' : 'miesiÄcy');
              case 'yy':
                  return result + (plural$3(number) ? 'lata' : 'lat');
          }
      }

      hooks.defineLocale('pl', {
          months: function (momentToFormat, format) {
              if (!momentToFormat) {
                  return monthsNominative;
              } else if (/D MMMM/.test(format)) {
                  return monthsSubjective[momentToFormat.month()];
              } else {
                  return monthsNominative[momentToFormat.month()];
              }
          },
          monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paÅº_lis_gru'.split('_'),
          monthsParse: monthsParse$a,
          longMonthsParse: monthsParse$a,
          shortMonthsParse: monthsParse$a,
          weekdays: 'niedziela_poniedziaÅek_wtorek_Åroda_czwartek_piÄtek_sobota'.split(
              '_'
          ),
          weekdaysShort: 'ndz_pon_wt_År_czw_pt_sob'.split('_'),
          weekdaysMin: 'Nd_Pn_Wt_År_Cz_Pt_So'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[DziÅ o] LT',
              nextDay: '[Jutro o] LT',
              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[W niedzielÄ o] LT';

                      case 2:
                          return '[We wtorek o] LT';

                      case 3:
                          return '[W ÅrodÄ o] LT';

                      case 6:
                          return '[W sobotÄ o] LT';

                      default:
                          return '[W] dddd [o] LT';
                  }
              },
              lastDay: '[Wczoraj o] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[W zeszÅÄ niedzielÄ o] LT';
                      case 3:
                          return '[W zeszÅÄ ÅrodÄ o] LT';
                      case 6:
                          return '[W zeszÅÄ sobotÄ o] LT';
                      default:
                          return '[W zeszÅy] dddd [o] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'za %s',
              past: '%s temu',
              s: 'kilka sekund',
              ss: translate$8,
              m: translate$8,
              mm: translate$8,
              h: translate$8,
              hh: translate$8,
              d: '1 dzieÅ',
              dd: '%d dni',
              w: 'tydzieÅ',
              ww: translate$8,
              M: 'miesiÄc',
              MM: translate$8,
              y: 'rok',
              yy: translate$8,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('pt-br', {
          months: 'janeiro_fevereiro_marÃ§o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
              '_'
          ),
          monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
          weekdays: 'domingo_segunda-feira_terÃ§a-feira_quarta-feira_quinta-feira_sexta-feira_sÃ¡bado'.split(
              '_'
          ),
          weekdaysShort: 'dom_seg_ter_qua_qui_sex_sÃ¡b'.split('_'),
          weekdaysMin: 'do_2Âª_3Âª_4Âª_5Âª_6Âª_sÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY [Ã s] HH:mm',
              LLLL: 'dddd, D [de] MMMM [de] YYYY [Ã s] HH:mm',
          },
          calendar: {
              sameDay: '[Hoje Ã s] LT',
              nextDay: '[AmanhÃ£ Ã s] LT',
              nextWeek: 'dddd [Ã s] LT',
              lastDay: '[Ontem Ã s] LT',
              lastWeek: function () {
                  return this.day() === 0 || this.day() === 6
                      ? '[Ãltimo] dddd [Ã s] LT' // Saturday + Sunday
                      : '[Ãltima] dddd [Ã s] LT'; // Monday - Friday
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'em %s',
              past: 'hÃ¡ %s',
              s: 'poucos segundos',
              ss: '%d segundos',
              m: 'um minuto',
              mm: '%d minutos',
              h: 'uma hora',
              hh: '%d horas',
              d: 'um dia',
              dd: '%d dias',
              M: 'um mÃªs',
              MM: '%d meses',
              y: 'um ano',
              yy: '%d anos',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          invalidDate: 'Data invÃ¡lida',
      });

      //! moment.js locale configuration

      hooks.defineLocale('pt', {
          months: 'janeiro_fevereiro_marÃ§o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
              '_'
          ),
          monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
          weekdays: 'Domingo_Segunda-feira_TerÃ§a-feira_Quarta-feira_Quinta-feira_Sexta-feira_SÃ¡bado'.split(
              '_'
          ),
          weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_SÃ¡b'.split('_'),
          weekdaysMin: 'Do_2Âª_3Âª_4Âª_5Âª_6Âª_SÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY HH:mm',
              LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Hoje Ã s] LT',
              nextDay: '[AmanhÃ£ Ã s] LT',
              nextWeek: 'dddd [Ã s] LT',
              lastDay: '[Ontem Ã s] LT',
              lastWeek: function () {
                  return this.day() === 0 || this.day() === 6
                      ? '[Ãltimo] dddd [Ã s] LT' // Saturday + Sunday
                      : '[Ãltima] dddd [Ã s] LT'; // Monday - Friday
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'em %s',
              past: 'hÃ¡ %s',
              s: 'segundos',
              ss: '%d segundos',
              m: 'um minuto',
              mm: '%d minutos',
              h: 'uma hora',
              hh: '%d horas',
              d: 'um dia',
              dd: '%d dias',
              w: 'uma semana',
              ww: '%d semanas',
              M: 'um mÃªs',
              MM: '%d meses',
              y: 'um ano',
              yy: '%d anos',
          },
          dayOfMonthOrdinalParse: /\d{1,2}Âº/,
          ordinal: '%dÂº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function relativeTimeWithPlural$2(number, withoutSuffix, key) {
          var format = {
                  ss: 'secunde',
                  mm: 'minute',
                  hh: 'ore',
                  dd: 'zile',
                  ww: 'sÄptÄmÃ¢ni',
                  MM: 'luni',
                  yy: 'ani',
              },
              separator = ' ';
          if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
              separator = ' de ';
          }
          return number + separator + format[key];
      }

      hooks.defineLocale('ro', {
          months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split(
              '_'
          ),
          monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'duminicÄ_luni_marÈi_miercuri_joi_vineri_sÃ¢mbÄtÄ'.split('_'),
          weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_SÃ¢m'.split('_'),
          weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_SÃ¢'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY H:mm',
              LLLL: 'dddd, D MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[azi la] LT',
              nextDay: '[mÃ¢ine la] LT',
              nextWeek: 'dddd [la] LT',
              lastDay: '[ieri la] LT',
              lastWeek: '[fosta] dddd [la] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'peste %s',
              past: '%s Ã®n urmÄ',
              s: 'cÃ¢teva secunde',
              ss: relativeTimeWithPlural$2,
              m: 'un minut',
              mm: relativeTimeWithPlural$2,
              h: 'o orÄ',
              hh: relativeTimeWithPlural$2,
              d: 'o zi',
              dd: relativeTimeWithPlural$2,
              w: 'o sÄptÄmÃ¢nÄ',
              ww: relativeTimeWithPlural$2,
              M: 'o lunÄ',
              MM: relativeTimeWithPlural$2,
              y: 'un an',
              yy: relativeTimeWithPlural$2,
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function plural$4(word, num) {
          var forms = word.split('_');
          return num % 10 === 1 && num % 100 !== 11
              ? forms[0]
              : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
              ? forms[1]
              : forms[2];
      }
      function relativeTimeWithPlural$3(number, withoutSuffix, key) {
          var format = {
              ss: withoutSuffix ? 'ÑÐµÐºÑÐ½Ð´Ð°_ÑÐµÐºÑÐ½Ð´Ñ_ÑÐµÐºÑÐ½Ð´' : 'ÑÐµÐºÑÐ½Ð´Ñ_ÑÐµÐºÑÐ½Ð´Ñ_ÑÐµÐºÑÐ½Ð´',
              mm: withoutSuffix ? 'Ð¼Ð¸Ð½ÑÑÐ°_Ð¼Ð¸Ð½ÑÑÑ_Ð¼Ð¸Ð½ÑÑ' : 'Ð¼Ð¸Ð½ÑÑÑ_Ð¼Ð¸Ð½ÑÑÑ_Ð¼Ð¸Ð½ÑÑ',
              hh: 'ÑÐ°Ñ_ÑÐ°ÑÐ°_ÑÐ°ÑÐ¾Ð²',
              dd: 'Ð´ÐµÐ½Ñ_Ð´Ð½Ñ_Ð´Ð½ÐµÐ¹',
              ww: 'Ð½ÐµÐ´ÐµÐ»Ñ_Ð½ÐµÐ´ÐµÐ»Ð¸_Ð½ÐµÐ´ÐµÐ»Ñ',
              MM: 'Ð¼ÐµÑÑÑ_Ð¼ÐµÑÑÑÐ°_Ð¼ÐµÑÑÑÐµÐ²',
              yy: 'Ð³Ð¾Ð´_Ð³Ð¾Ð´Ð°_Ð»ÐµÑ',
          };
          if (key === 'm') {
              return withoutSuffix ? 'Ð¼Ð¸Ð½ÑÑÐ°' : 'Ð¼Ð¸Ð½ÑÑÑ';
          } else {
              return number + ' ' + plural$4(format[key], +number);
          }
      }
      var monthsParse$b = [
          /^ÑÐ½Ð²/i,
          /^ÑÐµÐ²/i,
          /^Ð¼Ð°Ñ/i,
          /^Ð°Ð¿Ñ/i,
          /^Ð¼Ð°[Ð¹Ñ]/i,
          /^Ð¸ÑÐ½/i,
          /^Ð¸ÑÐ»/i,
          /^Ð°Ð²Ð³/i,
          /^ÑÐµÐ½/i,
          /^Ð¾ÐºÑ/i,
          /^Ð½Ð¾Ñ/i,
          /^Ð´ÐµÐº/i,
      ];

      // http://new.gramota.ru/spravka/rules/139-prop : Â§ 103
      // Ð¡Ð¾ÐºÑÐ°ÑÐµÐ½Ð¸Ñ Ð¼ÐµÑÑÑÐµÐ²: http://new.gramota.ru/spravka/buro/search-answer?s=242637
      // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
      hooks.defineLocale('ru', {
          months: {
              format: 'ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑÐ°_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑÐ°_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ'.split(
                  '_'
              ),
              standalone: 'ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ'.split(
                  '_'
              ),
          },
          monthsShort: {
              // Ð¿Ð¾ CLDR Ð¸Ð¼ÐµÐ½Ð½Ð¾ "Ð¸ÑÐ»." Ð¸ "Ð¸ÑÐ½.", Ð½Ð¾ ÐºÐ°ÐºÐ¾Ð¹ ÑÐ¼ÑÑÐ» Ð¼ÐµÐ½ÑÑÑ Ð±ÑÐºÐ²Ñ Ð½Ð° ÑÐ¾ÑÐºÑ?
              format: 'ÑÐ½Ð²._ÑÐµÐ²Ñ._Ð¼Ð°Ñ._Ð°Ð¿Ñ._Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³._ÑÐµÐ½Ñ._Ð¾ÐºÑ._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.'.split(
                  '_'
              ),
              standalone: 'ÑÐ½Ð²._ÑÐµÐ²Ñ._Ð¼Ð°ÑÑ_Ð°Ð¿Ñ._Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³._ÑÐµÐ½Ñ._Ð¾ÐºÑ._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.'.split(
                  '_'
              ),
          },
          weekdays: {
              standalone: 'Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÐµÐ´Ð°_ÑÐµÑÐ²ÐµÑÐ³_Ð¿ÑÑÐ½Ð¸ÑÐ°_ÑÑÐ±Ð±Ð¾ÑÐ°'.split(
                  '_'
              ),
              format: 'Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÐµÐ´Ñ_ÑÐµÑÐ²ÐµÑÐ³_Ð¿ÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð±Ð¾ÑÑ'.split(
                  '_'
              ),
              isFormat: /\[ ?[ÐÐ²] ?(?:Ð¿ÑÐ¾ÑÐ»ÑÑ|ÑÐ»ÐµÐ´ÑÑÑÑÑ|ÑÑÑ)? ?] ?dddd/,
          },
          weekdaysShort: 'Ð²Ñ_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±'.split('_'),
          weekdaysMin: 'Ð²Ñ_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±'.split('_'),
          monthsParse: monthsParse$b,
          longMonthsParse: monthsParse$b,
          shortMonthsParse: monthsParse$b,

          // Ð¿Ð¾Ð»Ð½ÑÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ñ Ð¿Ð°Ð´ÐµÐ¶Ð°Ð¼Ð¸, Ð¿Ð¾ ÑÑÐ¸ Ð±ÑÐºÐ²Ñ, Ð´Ð»Ñ Ð½ÐµÐºÐ¾ÑÐ¾ÑÑÑ, Ð¿Ð¾ 4 Ð±ÑÐºÐ²Ñ, ÑÐ¾ÐºÑÐ°ÑÐµÐ½Ð¸Ñ Ñ ÑÐ¾ÑÐºÐ¾Ð¹ Ð¸ Ð±ÐµÐ· ÑÐ¾ÑÐºÐ¸
          monthsRegex: /^(ÑÐ½Ð²Ð°Ñ[ÑÑ]|ÑÐ½Ð²\.?|ÑÐµÐ²ÑÐ°Ð»[ÑÑ]|ÑÐµÐ²Ñ?\.?|Ð¼Ð°ÑÑÐ°?|Ð¼Ð°Ñ\.?|Ð°Ð¿ÑÐµÐ»[ÑÑ]|Ð°Ð¿Ñ\.?|Ð¼Ð°[Ð¹Ñ]|Ð¸ÑÐ½[ÑÑ]|Ð¸ÑÐ½\.?|Ð¸ÑÐ»[ÑÑ]|Ð¸ÑÐ»\.?|Ð°Ð²Ð³ÑÑÑÐ°?|Ð°Ð²Ð³\.?|ÑÐµÐ½ÑÑÐ±Ñ[ÑÑ]|ÑÐµÐ½Ñ?\.?|Ð¾ÐºÑÑÐ±Ñ[ÑÑ]|Ð¾ÐºÑ\.?|Ð½Ð¾ÑÐ±Ñ[ÑÑ]|Ð½Ð¾ÑÐ±?\.?|Ð´ÐµÐºÐ°Ð±Ñ[ÑÑ]|Ð´ÐµÐº\.?)/i,

          // ÐºÐ¾Ð¿Ð¸Ñ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐµÐ³Ð¾
          monthsShortRegex: /^(ÑÐ½Ð²Ð°Ñ[ÑÑ]|ÑÐ½Ð²\.?|ÑÐµÐ²ÑÐ°Ð»[ÑÑ]|ÑÐµÐ²Ñ?\.?|Ð¼Ð°ÑÑÐ°?|Ð¼Ð°Ñ\.?|Ð°Ð¿ÑÐµÐ»[ÑÑ]|Ð°Ð¿Ñ\.?|Ð¼Ð°[Ð¹Ñ]|Ð¸ÑÐ½[ÑÑ]|Ð¸ÑÐ½\.?|Ð¸ÑÐ»[ÑÑ]|Ð¸ÑÐ»\.?|Ð°Ð²Ð³ÑÑÑÐ°?|Ð°Ð²Ð³\.?|ÑÐµÐ½ÑÑÐ±Ñ[ÑÑ]|ÑÐµÐ½Ñ?\.?|Ð¾ÐºÑÑÐ±Ñ[ÑÑ]|Ð¾ÐºÑ\.?|Ð½Ð¾ÑÐ±Ñ[ÑÑ]|Ð½Ð¾ÑÐ±?\.?|Ð´ÐµÐºÐ°Ð±Ñ[ÑÑ]|Ð´ÐµÐº\.?)/i,

          // Ð¿Ð¾Ð»Ð½ÑÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ñ Ð¿Ð°Ð´ÐµÐ¶Ð°Ð¼Ð¸
          monthsStrictRegex: /^(ÑÐ½Ð²Ð°Ñ[ÑÑ]|ÑÐµÐ²ÑÐ°Ð»[ÑÑ]|Ð¼Ð°ÑÑÐ°?|Ð°Ð¿ÑÐµÐ»[ÑÑ]|Ð¼Ð°[ÑÐ¹]|Ð¸ÑÐ½[ÑÑ]|Ð¸ÑÐ»[ÑÑ]|Ð°Ð²Ð³ÑÑÑÐ°?|ÑÐµÐ½ÑÑÐ±Ñ[ÑÑ]|Ð¾ÐºÑÑÐ±Ñ[ÑÑ]|Ð½Ð¾ÑÐ±Ñ[ÑÑ]|Ð´ÐµÐºÐ°Ð±Ñ[ÑÑ])/i,

          // ÐÑÑÐ°Ð¶ÐµÐ½Ð¸Ðµ, ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÐµÑ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¾ÐºÑÐ°ÑÑÐ½Ð½ÑÐ¼ ÑÐ¾ÑÐ¼Ð°Ð¼
          monthsShortStrictRegex: /^(ÑÐ½Ð²\.|ÑÐµÐ²Ñ?\.|Ð¼Ð°Ñ[Ñ.]|Ð°Ð¿Ñ\.|Ð¼Ð°[ÑÐ¹]|Ð¸ÑÐ½[ÑÑ.]|Ð¸ÑÐ»[ÑÑ.]|Ð°Ð²Ð³\.|ÑÐµÐ½Ñ?\.|Ð¾ÐºÑ\.|Ð½Ð¾ÑÐ±?\.|Ð´ÐµÐº\.)/i,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY Ð³.',
              LLL: 'D MMMM YYYY Ð³., H:mm',
              LLLL: 'dddd, D MMMM YYYY Ð³., H:mm',
          },
          calendar: {
              sameDay: '[Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ, Ð²] LT',
              nextDay: '[ÐÐ°Ð²ÑÑÐ°, Ð²] LT',
              lastDay: '[ÐÑÐµÑÐ°, Ð²] LT',
              nextWeek: function (now) {
                  if (now.week() !== this.week()) {
                      switch (this.day()) {
                          case 0:
                              return '[Ð ÑÐ»ÐµÐ´ÑÑÑÐµÐµ] dddd, [Ð²] LT';
                          case 1:
                          case 2:
                          case 4:
                              return '[Ð ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¹] dddd, [Ð²] LT';
                          case 3:
                          case 5:
                          case 6:
                              return '[Ð ÑÐ»ÐµÐ´ÑÑÑÑÑ] dddd, [Ð²] LT';
                      }
                  } else {
                      if (this.day() === 2) {
                          return '[ÐÐ¾] dddd, [Ð²] LT';
                      } else {
                          return '[Ð] dddd, [Ð²] LT';
                      }
                  }
              },
              lastWeek: function (now) {
                  if (now.week() !== this.week()) {
                      switch (this.day()) {
                          case 0:
                              return '[Ð Ð¿ÑÐ¾ÑÐ»Ð¾Ðµ] dddd, [Ð²] LT';
                          case 1:
                          case 2:
                          case 4:
                              return '[Ð Ð¿ÑÐ¾ÑÐ»ÑÐ¹] dddd, [Ð²] LT';
                          case 3:
                          case 5:
                          case 6:
                              return '[Ð Ð¿ÑÐ¾ÑÐ»ÑÑ] dddd, [Ð²] LT';
                      }
                  } else {
                      if (this.day() === 2) {
                          return '[ÐÐ¾] dddd, [Ð²] LT';
                      } else {
                          return '[Ð] dddd, [Ð²] LT';
                      }
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'ÑÐµÑÐµÐ· %s',
              past: '%s Ð½Ð°Ð·Ð°Ð´',
              s: 'Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÐ½Ð´',
              ss: relativeTimeWithPlural$3,
              m: relativeTimeWithPlural$3,
              mm: relativeTimeWithPlural$3,
              h: 'ÑÐ°Ñ',
              hh: relativeTimeWithPlural$3,
              d: 'Ð´ÐµÐ½Ñ',
              dd: relativeTimeWithPlural$3,
              w: 'Ð½ÐµÐ´ÐµÐ»Ñ',
              ww: relativeTimeWithPlural$3,
              M: 'Ð¼ÐµÑÑÑ',
              MM: relativeTimeWithPlural$3,
              y: 'Ð³Ð¾Ð´',
              yy: relativeTimeWithPlural$3,
          },
          meridiemParse: /Ð½Ð¾ÑÐ¸|ÑÑÑÐ°|Ð´Ð½Ñ|Ð²ÐµÑÐµÑÐ°/i,
          isPM: function (input) {
              return /^(Ð´Ð½Ñ|Ð²ÐµÑÐµÑÐ°)$/.test(input);
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'Ð½Ð¾ÑÐ¸';
              } else if (hour < 12) {
                  return 'ÑÑÑÐ°';
              } else if (hour < 17) {
                  return 'Ð´Ð½Ñ';
              } else {
                  return 'Ð²ÐµÑÐµÑÐ°';
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(Ð¹|Ð³Ð¾|Ñ)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'M':
                  case 'd':
                  case 'DDD':
                      return number + '-Ð¹';
                  case 'D':
                      return number + '-Ð³Ð¾';
                  case 'w':
                  case 'W':
                      return number + '-Ñ';
                  default:
                      return number;
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var months$9 = [
              'Ø¬ÙÙØ±Ù',
              'ÙÙØ¨Ø±ÙØ±Ù',
              'ÙØ§Ø±Ú',
              'Ø§Ù¾Ø±ÙÙ',
              'ÙØ¦Ù',
              'Ø¬ÙÙ',
              'Ø¬ÙÙØ§Ø¡Ù',
              'Ø¢Ú¯Ø³Ù½',
              'Ø³ÙÙ¾Ù½ÙØ¨Ø±',
              'Ø¢ÚªÙ½ÙØ¨Ø±',
              'ÙÙÙØ¨Ø±',
              'ÚØ³ÙØ¨Ø±',
          ],
          days$1 = ['Ø¢ÚØ±', 'Ø³ÙÙØ±', 'Ø§Ú±Ø§Ø±Ù', 'Ø§Ø±Ø¨Ø¹', 'Ø®ÙÙØ³', 'Ø¬ÙØ¹', 'ÚÙÚØ±'];

      hooks.defineLocale('sd', {
          months: months$9,
          monthsShort: months$9,
          weekdays: days$1,
          weekdaysShort: days$1,
          weekdaysMin: days$1,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'ddddØ D MMMM YYYY HH:mm',
          },
          meridiemParse: /ØµØ¨Ø­|Ø´Ø§Ù/,
          isPM: function (input) {
              return 'Ø´Ø§Ù' === input;
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'ØµØ¨Ø­';
              }
              return 'Ø´Ø§Ù';
          },
          calendar: {
              sameDay: '[Ø§Ú] LT',
              nextDay: '[Ø³ÚØ§Ú»Ù] LT',
              nextWeek: 'dddd [Ø§Ú³ÙÙ ÙÙØªÙ ØªÙ] LT',
              lastDay: '[ÚªØ§ÙÙÙ] LT',
              lastWeek: '[Ú¯Ø²Ø±ÙÙ ÙÙØªÙ] dddd [ØªÙ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s Ù¾ÙØ¡',
              past: '%s Ø§Ú³',
              s: 'ÚÙØ¯ Ø³ÙÚªÙÚ',
              ss: '%d Ø³ÙÚªÙÚ',
              m: 'ÙÚª ÙÙÙ½',
              mm: '%d ÙÙÙ½',
              h: 'ÙÚª ÚªÙØ§Úª',
              hh: '%d ÚªÙØ§Úª',
              d: 'ÙÚª ÚÙÙÙÙ',
              dd: '%d ÚÙÙÙÙ',
              M: 'ÙÚª ÙÙÙÙÙ',
              MM: '%d ÙÙÙÙØ§',
              y: 'ÙÚª Ø³Ø§Ù',
              yy: '%d Ø³Ø§Ù',
          },
          preparse: function (string) {
              return string.replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string.replace(/,/g, 'Ø');
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('se', {
          months: 'oÄÄajagemÃ¡nnu_guovvamÃ¡nnu_njukÄamÃ¡nnu_cuoÅomÃ¡nnu_miessemÃ¡nnu_geassemÃ¡nnu_suoidnemÃ¡nnu_borgemÃ¡nnu_ÄakÄamÃ¡nnu_golggotmÃ¡nnu_skÃ¡bmamÃ¡nnu_juovlamÃ¡nnu'.split(
              '_'
          ),
          monthsShort: 'oÄÄj_guov_njuk_cuo_mies_geas_suoi_borg_ÄakÄ_golg_skÃ¡b_juov'.split(
              '_'
          ),
          weekdays: 'sotnabeaivi_vuossÃ¡rga_maÅÅebÃ¡rga_gaskavahkku_duorastat_bearjadat_lÃ¡vvardat'.split(
              '_'
          ),
          weekdaysShort: 'sotn_vuos_maÅ_gask_duor_bear_lÃ¡v'.split('_'),
          weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'MMMM D. [b.] YYYY',
              LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
              LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm',
          },
          calendar: {
              sameDay: '[otne ti] LT',
              nextDay: '[ihttin ti] LT',
              nextWeek: 'dddd [ti] LT',
              lastDay: '[ikte ti] LT',
              lastWeek: '[ovddit] dddd [ti] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s geaÅ¾es',
              past: 'maÅit %s',
              s: 'moadde sekunddat',
              ss: '%d sekunddat',
              m: 'okta minuhta',
              mm: '%d minuhtat',
              h: 'okta diimmu',
              hh: '%d diimmut',
              d: 'okta beaivi',
              dd: '%d beaivvit',
              M: 'okta mÃ¡nnu',
              MM: '%d mÃ¡nut',
              y: 'okta jahki',
              yy: '%d jagit',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      /*jshint -W100*/
      hooks.defineLocale('si', {
          months: 'à¶¢à¶±à·à·à¶»à·_à¶´à·à¶¶à¶»à·à·à¶»à·_à¶¸à·à¶»à·à¶­à·_à¶à¶´à·âà¶»à·à¶½à·_à¶¸à·à¶ºà·_à¶¢à·à¶±à·_à¶¢à·à¶½à·_à¶à¶à·à·à·à¶­à·_à·à·à¶´à·à¶­à·à¶¸à·à¶¶à¶»à·_à¶à¶à·à¶­à·à¶¶à¶»à·_à¶±à·à·à·à¶¸à·à¶¶à¶»à·_à¶¯à·à·à·à¶¸à·à¶¶à¶»à·'.split(
              '_'
          ),
          monthsShort: 'à¶¢à¶±_à¶´à·à¶¶_à¶¸à·à¶»à·_à¶à¶´à·_à¶¸à·à¶ºà·_à¶¢à·à¶±à·_à¶¢à·à¶½à·_à¶à¶à·_à·à·à¶´à·_à¶à¶à·_à¶±à·à·à·_à¶¯à·à·à·'.split(
              '_'
          ),
          weekdays: 'à¶à¶»à·à¶¯à·_à·à¶³à·à¶¯à·_à¶à¶à·à¶»à·à·à·à¶¯à·_à¶¶à¶¯à·à¶¯à·_à¶¶à·âà¶»à·à·à·à¶´à¶­à·à¶±à·à¶¯à·_à·à·à¶à·à¶»à·à¶¯à·_à·à·à¶±à·à·à¶»à·à¶¯à·'.split(
              '_'
          ),
          weekdaysShort: 'à¶à¶»à·_à·à¶³à·_à¶à¶_à¶¶à¶¯à·_à¶¶à·âà¶»à·_à·à·à¶à·_à·à·à¶±'.split('_'),
          weekdaysMin: 'à¶_à·_à¶_à¶¶_à¶¶à·âà¶»_à·à·_à·à·'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'a h:mm',
              LTS: 'a h:mm:ss',
              L: 'YYYY/MM/DD',
              LL: 'YYYY MMMM D',
              LLL: 'YYYY MMMM D, a h:mm',
              LLLL: 'YYYY MMMM D [à·à·à¶±à·] dddd, a h:mm:ss',
          },
          calendar: {
              sameDay: '[à¶à¶¯] LT[à¶§]',
              nextDay: '[à·à·à¶§] LT[à¶§]',
              nextWeek: 'dddd LT[à¶§]',
              lastDay: '[à¶à¶ºà·] LT[à¶§]',
              lastWeek: '[à¶´à·à·à¶à·à¶º] dddd LT[à¶§]',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%sà¶à·à¶±à·',
              past: '%sà¶à¶§ à¶´à·à¶»',
              s: 'à¶­à¶­à·à¶´à¶» à¶à·à·à·à¶´à¶º',
              ss: 'à¶­à¶­à·à¶´à¶» %d',
              m: 'à¶¸à·à¶±à·à¶­à·à¶­à·à·',
              mm: 'à¶¸à·à¶±à·à¶­à·à¶­à· %d',
              h: 'à¶´à·à¶º',
              hh: 'à¶´à·à¶º %d',
              d: 'à¶¯à·à¶±à¶º',
              dd: 'à¶¯à·à¶± %d',
              M: 'à¶¸à·à·à¶º',
              MM: 'à¶¸à·à· %d',
              y: 'à·à·à¶»',
              yy: 'à·à·à¶» %d',
          },
          dayOfMonthOrdinalParse: /\d{1,2} à·à·à¶±à·/,
          ordinal: function (number) {
              return number + ' à·à·à¶±à·';
          },
          meridiemParse: /à¶´à·à¶» à·à¶»à·|à¶´à·à· à·à¶»à·|à¶´à·.à·|à¶´.à·./,
          isPM: function (input) {
              return input === 'à¶´.à·.' || input === 'à¶´à·à· à·à¶»à·';
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours > 11) {
                  return isLower ? 'à¶´.à·.' : 'à¶´à·à· à·à¶»à·';
              } else {
                  return isLower ? 'à¶´à·.à·.' : 'à¶´à·à¶» à·à¶»à·';
              }
          },
      });

      //! moment.js locale configuration

      var months$a = 'januÃ¡r_februÃ¡r_marec_aprÃ­l_mÃ¡j_jÃºn_jÃºl_august_september_oktÃ³ber_november_december'.split(
              '_'
          ),
          monthsShort$7 = 'jan_feb_mar_apr_mÃ¡j_jÃºn_jÃºl_aug_sep_okt_nov_dec'.split('_');
      function plural$5(n) {
          return n > 1 && n < 5;
      }
      function translate$9(number, withoutSuffix, key, isFuture) {
          var result = number + ' ';
          switch (key) {
              case 's': // a few seconds / in a few seconds / a few seconds ago
                  return withoutSuffix || isFuture ? 'pÃ¡r sekÃºnd' : 'pÃ¡r sekundami';
              case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$5(number) ? 'sekundy' : 'sekÃºnd');
                  } else {
                      return result + 'sekundami';
                  }
              case 'm': // a minute / in a minute / a minute ago
                  return withoutSuffix ? 'minÃºta' : isFuture ? 'minÃºtu' : 'minÃºtou';
              case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$5(number) ? 'minÃºty' : 'minÃºt');
                  } else {
                      return result + 'minÃºtami';
                  }
              case 'h': // an hour / in an hour / an hour ago
                  return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
              case 'hh': // 9 hours / in 9 hours / 9 hours ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$5(number) ? 'hodiny' : 'hodÃ­n');
                  } else {
                      return result + 'hodinami';
                  }
              case 'd': // a day / in a day / a day ago
                  return withoutSuffix || isFuture ? 'deÅ' : 'dÅom';
              case 'dd': // 9 days / in 9 days / 9 days ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$5(number) ? 'dni' : 'dnÃ­');
                  } else {
                      return result + 'dÅami';
                  }
              case 'M': // a month / in a month / a month ago
                  return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
              case 'MM': // 9 months / in 9 months / 9 months ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$5(number) ? 'mesiace' : 'mesiacov');
                  } else {
                      return result + 'mesiacmi';
                  }
              case 'y': // a year / in a year / a year ago
                  return withoutSuffix || isFuture ? 'rok' : 'rokom';
              case 'yy': // 9 years / in 9 years / 9 years ago
                  if (withoutSuffix || isFuture) {
                      return result + (plural$5(number) ? 'roky' : 'rokov');
                  } else {
                      return result + 'rokmi';
                  }
          }
      }

      hooks.defineLocale('sk', {
          months: months$a,
          monthsShort: monthsShort$7,
          weekdays: 'nedeÄ¾a_pondelok_utorok_streda_Å¡tvrtok_piatok_sobota'.split('_'),
          weekdaysShort: 'ne_po_ut_st_Å¡t_pi_so'.split('_'),
          weekdaysMin: 'ne_po_ut_st_Å¡t_pi_so'.split('_'),
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY H:mm',
              LLLL: 'dddd D. MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[dnes o] LT',
              nextDay: '[zajtra o] LT',
              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[v nedeÄ¾u o] LT';
                      case 1:
                      case 2:
                          return '[v] dddd [o] LT';
                      case 3:
                          return '[v stredu o] LT';
                      case 4:
                          return '[vo Å¡tvrtok o] LT';
                      case 5:
                          return '[v piatok o] LT';
                      case 6:
                          return '[v sobotu o] LT';
                  }
              },
              lastDay: '[vÄera o] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[minulÃº nedeÄ¾u o] LT';
                      case 1:
                      case 2:
                          return '[minulÃ½] dddd [o] LT';
                      case 3:
                          return '[minulÃº stredu o] LT';
                      case 4:
                      case 5:
                          return '[minulÃ½] dddd [o] LT';
                      case 6:
                          return '[minulÃº sobotu o] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'za %s',
              past: 'pred %s',
              s: translate$9,
              ss: translate$9,
              m: translate$9,
              mm: translate$9,
              h: translate$9,
              hh: translate$9,
              d: translate$9,
              dd: translate$9,
              M: translate$9,
              MM: translate$9,
              y: translate$9,
              yy: translate$9,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
          var result = number + ' ';
          switch (key) {
              case 's':
                  return withoutSuffix || isFuture
                      ? 'nekaj sekund'
                      : 'nekaj sekundami';
              case 'ss':
                  if (number === 1) {
                      result += withoutSuffix ? 'sekundo' : 'sekundi';
                  } else if (number === 2) {
                      result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
                  } else if (number < 5) {
                      result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
                  } else {
                      result += 'sekund';
                  }
                  return result;
              case 'm':
                  return withoutSuffix ? 'ena minuta' : 'eno minuto';
              case 'mm':
                  if (number === 1) {
                      result += withoutSuffix ? 'minuta' : 'minuto';
                  } else if (number === 2) {
                      result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                  } else if (number < 5) {
                      result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                  } else {
                      result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                  }
                  return result;
              case 'h':
                  return withoutSuffix ? 'ena ura' : 'eno uro';
              case 'hh':
                  if (number === 1) {
                      result += withoutSuffix ? 'ura' : 'uro';
                  } else if (number === 2) {
                      result += withoutSuffix || isFuture ? 'uri' : 'urama';
                  } else if (number < 5) {
                      result += withoutSuffix || isFuture ? 'ure' : 'urami';
                  } else {
                      result += withoutSuffix || isFuture ? 'ur' : 'urami';
                  }
                  return result;
              case 'd':
                  return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
              case 'dd':
                  if (number === 1) {
                      result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                  } else if (number === 2) {
                      result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                  } else {
                      result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                  }
                  return result;
              case 'M':
                  return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
              case 'MM':
                  if (number === 1) {
                      result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                  } else if (number === 2) {
                      result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                  } else if (number < 5) {
                      result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                  } else {
                      result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                  }
                  return result;
              case 'y':
                  return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
              case 'yy':
                  if (number === 1) {
                      result += withoutSuffix || isFuture ? 'leto' : 'letom';
                  } else if (number === 2) {
                      result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                  } else if (number < 5) {
                      result += withoutSuffix || isFuture ? 'leta' : 'leti';
                  } else {
                      result += withoutSuffix || isFuture ? 'let' : 'leti';
                  }
                  return result;
          }
      }

      hooks.defineLocale('sl', {
          months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split(
              '_'
          ),
          monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'nedelja_ponedeljek_torek_sreda_Äetrtek_petek_sobota'.split('_'),
          weekdaysShort: 'ned._pon._tor._sre._Äet._pet._sob.'.split('_'),
          weekdaysMin: 'ne_po_to_sr_Äe_pe_so'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD. MM. YYYY',
              LL: 'D. MMMM YYYY',
              LLL: 'D. MMMM YYYY H:mm',
              LLLL: 'dddd, D. MMMM YYYY H:mm',
          },
          calendar: {
              sameDay: '[danes ob] LT',
              nextDay: '[jutri ob] LT',

              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[v] [nedeljo] [ob] LT';
                      case 3:
                          return '[v] [sredo] [ob] LT';
                      case 6:
                          return '[v] [soboto] [ob] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[v] dddd [ob] LT';
                  }
              },
              lastDay: '[vÄeraj ob] LT',
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[prejÅ¡njo] [nedeljo] [ob] LT';
                      case 3:
                          return '[prejÅ¡njo] [sredo] [ob] LT';
                      case 6:
                          return '[prejÅ¡njo] [soboto] [ob] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[prejÅ¡nji] dddd [ob] LT';
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Äez %s',
              past: 'pred %s',
              s: processRelativeTime$7,
              ss: processRelativeTime$7,
              m: processRelativeTime$7,
              mm: processRelativeTime$7,
              h: processRelativeTime$7,
              hh: processRelativeTime$7,
              d: processRelativeTime$7,
              dd: processRelativeTime$7,
              M: processRelativeTime$7,
              MM: processRelativeTime$7,
              y: processRelativeTime$7,
              yy: processRelativeTime$7,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('sq', {
          months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_NÃ«ntor_Dhjetor'.split(
              '_'
          ),
          monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_NÃ«n_Dhj'.split('_'),
          weekdays: 'E Diel_E HÃ«nÃ«_E MartÃ«_E MÃ«rkurÃ«_E Enjte_E Premte_E ShtunÃ«'.split(
              '_'
          ),
          weekdaysShort: 'Die_HÃ«n_Mar_MÃ«r_Enj_Pre_Sht'.split('_'),
          weekdaysMin: 'D_H_Ma_MÃ«_E_P_Sh'.split('_'),
          weekdaysParseExact: true,
          meridiemParse: /PD|MD/,
          isPM: function (input) {
              return input.charAt(0) === 'M';
          },
          meridiem: function (hours, minutes, isLower) {
              return hours < 12 ? 'PD' : 'MD';
          },
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Sot nÃ«] LT',
              nextDay: '[NesÃ«r nÃ«] LT',
              nextWeek: 'dddd [nÃ«] LT',
              lastDay: '[Dje nÃ«] LT',
              lastWeek: 'dddd [e kaluar nÃ«] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'nÃ« %s',
              past: '%s mÃ« parÃ«',
              s: 'disa sekonda',
              ss: '%d sekonda',
              m: 'njÃ« minutÃ«',
              mm: '%d minuta',
              h: 'njÃ« orÃ«',
              hh: '%d orÃ«',
              d: 'njÃ« ditÃ«',
              dd: '%d ditÃ«',
              M: 'njÃ« muaj',
              MM: '%d muaj',
              y: 'njÃ« vit',
              yy: '%d vite',
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var translator$1 = {
          words: {
              //Different grammatical cases
              ss: ['ÑÐµÐºÑÐ½Ð´Ð°', 'ÑÐµÐºÑÐ½Ð´Ðµ', 'ÑÐµÐºÑÐ½Ð´Ð¸'],
              m: ['ÑÐµÐ´Ð°Ð½ Ð¼Ð¸Ð½ÑÑ', 'ÑÐµÐ´Ð½Ðµ Ð¼Ð¸Ð½ÑÑÐµ'],
              mm: ['Ð¼Ð¸Ð½ÑÑ', 'Ð¼Ð¸Ð½ÑÑÐµ', 'Ð¼Ð¸Ð½ÑÑÐ°'],
              h: ['ÑÐµÐ´Ð°Ð½ ÑÐ°Ñ', 'ÑÐµÐ´Ð½Ð¾Ð³ ÑÐ°ÑÐ°'],
              hh: ['ÑÐ°Ñ', 'ÑÐ°ÑÐ°', 'ÑÐ°ÑÐ¸'],
              dd: ['Ð´Ð°Ð½', 'Ð´Ð°Ð½Ð°', 'Ð´Ð°Ð½Ð°'],
              MM: ['Ð¼ÐµÑÐµÑ', 'Ð¼ÐµÑÐµÑÐ°', 'Ð¼ÐµÑÐµÑÐ¸'],
              yy: ['Ð³Ð¾Ð´Ð¸Ð½Ð°', 'Ð³Ð¾Ð´Ð¸Ð½Ðµ', 'Ð³Ð¾Ð´Ð¸Ð½Ð°'],
          },
          correctGrammaticalCase: function (number, wordKey) {
              return number === 1
                  ? wordKey[0]
                  : number >= 2 && number <= 4
                  ? wordKey[1]
                  : wordKey[2];
          },
          translate: function (number, withoutSuffix, key) {
              var wordKey = translator$1.words[key];
              if (key.length === 1) {
                  return withoutSuffix ? wordKey[0] : wordKey[1];
              } else {
                  return (
                      number +
                      ' ' +
                      translator$1.correctGrammaticalCase(number, wordKey)
                  );
              }
          },
      };

      hooks.defineLocale('sr-cyrl', {
          months: 'ÑÐ°Ð½ÑÐ°Ñ_ÑÐµÐ±ÑÑÐ°Ñ_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐ¸Ð»_Ð¼Ð°Ñ_ÑÑÐ½_ÑÑÐ»_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ¿ÑÐµÐ¼Ð±Ð°Ñ_Ð¾ÐºÑÐ¾Ð±Ð°Ñ_Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ_Ð´ÐµÑÐµÐ¼Ð±Ð°Ñ'.split(
              '_'
          ),
          monthsShort: 'ÑÐ°Ð½._ÑÐµÐ±._Ð¼Ð°Ñ._Ð°Ð¿Ñ._Ð¼Ð°Ñ_ÑÑÐ½_ÑÑÐ»_Ð°Ð²Ð³._ÑÐµÐ¿._Ð¾ÐºÑ._Ð½Ð¾Ð²._Ð´ÐµÑ.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'Ð½ÐµÐ´ÐµÑÐ°_Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐ°Ðº_ÑÑÐ¾ÑÐ°Ðº_ÑÑÐµÐ´Ð°_ÑÐµÑÐ²ÑÑÐ°Ðº_Ð¿ÐµÑÐ°Ðº_ÑÑÐ±Ð¾ÑÐ°'.split('_'),
          weekdaysShort: 'Ð½ÐµÐ´._Ð¿Ð¾Ð½._ÑÑÐ¾._ÑÑÐµ._ÑÐµÑ._Ð¿ÐµÑ._ÑÑÐ±.'.split('_'),
          weekdaysMin: 'Ð½Ðµ_Ð¿Ð¾_ÑÑ_ÑÑ_ÑÐµ_Ð¿Ðµ_ÑÑ'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'D. M. YYYY.',
              LL: 'D. MMMM YYYY.',
              LLL: 'D. MMMM YYYY. H:mm',
              LLLL: 'dddd, D. MMMM YYYY. H:mm',
          },
          calendar: {
              sameDay: '[Ð´Ð°Ð½Ð°Ñ Ñ] LT',
              nextDay: '[ÑÑÑÑÐ° Ñ] LT',
              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[Ñ] [Ð½ÐµÐ´ÐµÑÑ] [Ñ] LT';
                      case 3:
                          return '[Ñ] [ÑÑÐµÐ´Ñ] [Ñ] LT';
                      case 6:
                          return '[Ñ] [ÑÑÐ±Ð¾ÑÑ] [Ñ] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[Ñ] dddd [Ñ] LT';
                  }
              },
              lastDay: '[ÑÑÑÐµ Ñ] LT',
              lastWeek: function () {
                  var lastWeekDays = [
                      '[Ð¿ÑÐ¾ÑÐ»Ðµ] [Ð½ÐµÐ´ÐµÑÐµ] [Ñ] LT',
                      '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐºÐ°] [Ñ] LT',
                      '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [ÑÑÐ¾ÑÐºÐ°] [Ñ] LT',
                      '[Ð¿ÑÐ¾ÑÐ»Ðµ] [ÑÑÐµÐ´Ðµ] [Ñ] LT',
                      '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [ÑÐµÑÐ²ÑÑÐºÐ°] [Ñ] LT',
                      '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [Ð¿ÐµÑÐºÐ°] [Ñ] LT',
                      '[Ð¿ÑÐ¾ÑÐ»Ðµ] [ÑÑÐ±Ð¾ÑÐµ] [Ñ] LT',
                  ];
                  return lastWeekDays[this.day()];
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ð·Ð° %s',
              past: 'Ð¿ÑÐµ %s',
              s: 'Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸',
              ss: translator$1.translate,
              m: translator$1.translate,
              mm: translator$1.translate,
              h: translator$1.translate,
              hh: translator$1.translate,
              d: 'Ð´Ð°Ð½',
              dd: translator$1.translate,
              M: 'Ð¼ÐµÑÐµÑ',
              MM: translator$1.translate,
              y: 'Ð³Ð¾Ð´Ð¸Ð½Ñ',
              yy: translator$1.translate,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 1st is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var translator$2 = {
          words: {
              //Different grammatical cases
              ss: ['sekunda', 'sekunde', 'sekundi'],
              m: ['jedan minut', 'jedne minute'],
              mm: ['minut', 'minute', 'minuta'],
              h: ['jedan sat', 'jednog sata'],
              hh: ['sat', 'sata', 'sati'],
              dd: ['dan', 'dana', 'dana'],
              MM: ['mesec', 'meseca', 'meseci'],
              yy: ['godina', 'godine', 'godina'],
          },
          correctGrammaticalCase: function (number, wordKey) {
              return number === 1
                  ? wordKey[0]
                  : number >= 2 && number <= 4
                  ? wordKey[1]
                  : wordKey[2];
          },
          translate: function (number, withoutSuffix, key) {
              var wordKey = translator$2.words[key];
              if (key.length === 1) {
                  return withoutSuffix ? wordKey[0] : wordKey[1];
              } else {
                  return (
                      number +
                      ' ' +
                      translator$2.correctGrammaticalCase(number, wordKey)
                  );
              }
          },
      };

      hooks.defineLocale('sr', {
          months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
              '_'
          ),
          monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'nedelja_ponedeljak_utorak_sreda_Äetvrtak_petak_subota'.split(
              '_'
          ),
          weekdaysShort: 'ned._pon._uto._sre._Äet._pet._sub.'.split('_'),
          weekdaysMin: 'ne_po_ut_sr_Äe_pe_su'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'D. M. YYYY.',
              LL: 'D. MMMM YYYY.',
              LLL: 'D. MMMM YYYY. H:mm',
              LLLL: 'dddd, D. MMMM YYYY. H:mm',
          },
          calendar: {
              sameDay: '[danas u] LT',
              nextDay: '[sutra u] LT',
              nextWeek: function () {
                  switch (this.day()) {
                      case 0:
                          return '[u] [nedelju] [u] LT';
                      case 3:
                          return '[u] [sredu] [u] LT';
                      case 6:
                          return '[u] [subotu] [u] LT';
                      case 1:
                      case 2:
                      case 4:
                      case 5:
                          return '[u] dddd [u] LT';
                  }
              },
              lastDay: '[juÄe u] LT',
              lastWeek: function () {
                  var lastWeekDays = [
                      '[proÅ¡le] [nedelje] [u] LT',
                      '[proÅ¡log] [ponedeljka] [u] LT',
                      '[proÅ¡log] [utorka] [u] LT',
                      '[proÅ¡le] [srede] [u] LT',
                      '[proÅ¡log] [Äetvrtka] [u] LT',
                      '[proÅ¡log] [petka] [u] LT',
                      '[proÅ¡le] [subote] [u] LT',
                  ];
                  return lastWeekDays[this.day()];
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'za %s',
              past: 'pre %s',
              s: 'nekoliko sekundi',
              ss: translator$2.translate,
              m: translator$2.translate,
              mm: translator$2.translate,
              h: translator$2.translate,
              hh: translator$2.translate,
              d: 'dan',
              dd: translator$2.translate,
              M: 'mesec',
              MM: translator$2.translate,
              y: 'godinu',
              yy: translator$2.translate,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ss', {
          months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
              '_'
          ),
          monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
          weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split(
              '_'
          ),
          weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
          weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY h:mm A',
              LLLL: 'dddd, D MMMM YYYY h:mm A',
          },
          calendar: {
              sameDay: '[Namuhla nga] LT',
              nextDay: '[Kusasa nga] LT',
              nextWeek: 'dddd [nga] LT',
              lastDay: '[Itolo nga] LT',
              lastWeek: 'dddd [leliphelile] [nga] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'nga %s',
              past: 'wenteka nga %s',
              s: 'emizuzwana lomcane',
              ss: '%d mzuzwana',
              m: 'umzuzu',
              mm: '%d emizuzu',
              h: 'lihora',
              hh: '%d emahora',
              d: 'lilanga',
              dd: '%d emalanga',
              M: 'inyanga',
              MM: '%d tinyanga',
              y: 'umnyaka',
              yy: '%d iminyaka',
          },
          meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
          meridiem: function (hours, minutes, isLower) {
              if (hours < 11) {
                  return 'ekuseni';
              } else if (hours < 15) {
                  return 'emini';
              } else if (hours < 19) {
                  return 'entsambama';
              } else {
                  return 'ebusuku';
              }
          },
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'ekuseni') {
                  return hour;
              } else if (meridiem === 'emini') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                  if (hour === 0) {
                      return 0;
                  }
                  return hour + 12;
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}/,
          ordinal: '%d',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('sv', {
          months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split(
              '_'
          ),
          monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
          weekdays: 'sÃ¶ndag_mÃ¥ndag_tisdag_onsdag_torsdag_fredag_lÃ¶rdag'.split('_'),
          weekdaysShort: 'sÃ¶n_mÃ¥n_tis_ons_tor_fre_lÃ¶r'.split('_'),
          weekdaysMin: 'sÃ¶_mÃ¥_ti_on_to_fr_lÃ¶'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY-MM-DD',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY [kl.] HH:mm',
              LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
              lll: 'D MMM YYYY HH:mm',
              llll: 'ddd D MMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Idag] LT',
              nextDay: '[Imorgon] LT',
              lastDay: '[IgÃ¥r] LT',
              nextWeek: '[PÃ¥] dddd LT',
              lastWeek: '[I] dddd[s] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'om %s',
              past: 'fÃ¶r %s sedan',
              s: 'nÃ¥gra sekunder',
              ss: '%d sekunder',
              m: 'en minut',
              mm: '%d minuter',
              h: 'en timme',
              hh: '%d timmar',
              d: 'en dag',
              dd: '%d dagar',
              M: 'en mÃ¥nad',
              MM: '%d mÃ¥nader',
              y: 'ett Ã¥r',
              yy: '%d Ã¥r',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? ':e'
                          : b === 1
                          ? ':a'
                          : b === 2
                          ? ':a'
                          : b === 3
                          ? ':e'
                          : ':e';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('sw', {
          months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split(
              '_'
          ),
          monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
          weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split(
              '_'
          ),
          weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
          weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'hh:mm A',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[leo saa] LT',
              nextDay: '[kesho saa] LT',
              nextWeek: '[wiki ijayo] dddd [saat] LT',
              lastDay: '[jana] LT',
              lastWeek: '[wiki iliyopita] dddd [saat] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s baadaye',
              past: 'tokea %s',
              s: 'hivi punde',
              ss: 'sekunde %d',
              m: 'dakika moja',
              mm: 'dakika %d',
              h: 'saa limoja',
              hh: 'masaa %d',
              d: 'siku moja',
              dd: 'siku %d',
              M: 'mwezi mmoja',
              MM: 'miezi %d',
              y: 'mwaka mmoja',
              yy: 'miaka %d',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var symbolMap$g = {
              1: 'à¯§',
              2: 'à¯¨',
              3: 'à¯©',
              4: 'à¯ª',
              5: 'à¯«',
              6: 'à¯¬',
              7: 'à¯­',
              8: 'à¯®',
              9: 'à¯¯',
              0: 'à¯¦',
          },
          numberMap$f = {
              'à¯§': '1',
              'à¯¨': '2',
              'à¯©': '3',
              'à¯ª': '4',
              'à¯«': '5',
              'à¯¬': '6',
              'à¯­': '7',
              'à¯®': '8',
              'à¯¯': '9',
              'à¯¦': '0',
          };

      hooks.defineLocale('ta', {
          months: 'à®à®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®à¯_à®à®ªà¯à®°à®²à¯_à®®à¯_à®à¯à®©à¯_à®à¯à®²à¯_à®à®à®¸à¯à®à¯_à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯_à®à®à¯à®à¯à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯_à®à®¿à®à®®à¯à®ªà®°à¯'.split(
              '_'
          ),
          monthsShort: 'à®à®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®à¯_à®à®ªà¯à®°à®²à¯_à®®à¯_à®à¯à®©à¯_à®à¯à®²à¯_à®à®à®¸à¯à®à¯_à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯_à®à®à¯à®à¯à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯_à®à®¿à®à®®à¯à®ªà®°à¯'.split(
              '_'
          ),
          weekdays: 'à®à®¾à®¯à®¿à®±à¯à®±à¯à®à¯à®à®¿à®´à®®à¯_à®¤à®¿à®à¯à®à®à¯à®à®¿à®´à®®à¯_à®à¯à®µà¯à®µà®¾à®¯à¯à®à®¿à®´à®®à¯_à®ªà¯à®¤à®©à¯à®à®¿à®´à®®à¯_à®µà®¿à®¯à®¾à®´à®à¯à®à®¿à®´à®®à¯_à®µà¯à®³à¯à®³à®¿à®à¯à®à®¿à®´à®®à¯_à®à®©à®¿à®à¯à®à®¿à®´à®®à¯'.split(
              '_'
          ),
          weekdaysShort: 'à®à®¾à®¯à®¿à®±à¯_à®¤à®¿à®à¯à®à®³à¯_à®à¯à®µà¯à®µà®¾à®¯à¯_à®ªà¯à®¤à®©à¯_à®µà®¿à®¯à®¾à®´à®©à¯_à®µà¯à®³à¯à®³à®¿_à®à®©à®¿'.split(
              '_'
          ),
          weekdaysMin: 'à®à®¾_à®¤à®¿_à®à¯_à®ªà¯_à®µà®¿_à®µà¯_à®'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, HH:mm',
              LLLL: 'dddd, D MMMM YYYY, HH:mm',
          },
          calendar: {
              sameDay: '[à®à®©à¯à®±à¯] LT',
              nextDay: '[à®¨à®¾à®³à¯] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à®¨à¯à®±à¯à®±à¯] LT',
              lastWeek: '[à®à®à®¨à¯à®¤ à®µà®¾à®°à®®à¯] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à®à®²à¯',
              past: '%s à®®à¯à®©à¯',
              s: 'à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯',
              ss: '%d à®µà®¿à®¨à®¾à®à®¿à®à®³à¯',
              m: 'à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯',
              mm: '%d à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯',
              h: 'à®à®°à¯ à®®à®£à®¿ à®¨à¯à®°à®®à¯',
              hh: '%d à®®à®£à®¿ à®¨à¯à®°à®®à¯',
              d: 'à®à®°à¯ à®¨à®¾à®³à¯',
              dd: '%d à®¨à®¾à®à¯à®à®³à¯',
              M: 'à®à®°à¯ à®®à®¾à®¤à®®à¯',
              MM: '%d à®®à®¾à®¤à®à¯à®à®³à¯',
              y: 'à®à®°à¯ à®µà®°à¯à®à®®à¯',
              yy: '%d à®à®£à¯à®à¯à®à®³à¯',
          },
          dayOfMonthOrdinalParse: /\d{1,2}à®µà®¤à¯/,
          ordinal: function (number) {
              return number + 'à®µà®¤à¯';
          },
          preparse: function (string) {
              return string.replace(/[à¯§à¯¨à¯©à¯ªà¯«à¯¬à¯­à¯®à¯¯à¯¦]/g, function (match) {
                  return numberMap$f[match];
              });
          },
          postformat: function (string) {
              return string.replace(/\d/g, function (match) {
                  return symbolMap$g[match];
              });
          },
          // refer http://ta.wikipedia.org/s/1er1
          meridiemParse: /à®¯à®¾à®®à®®à¯|à®µà¯à®à®±à¯|à®à®¾à®²à¯|à®¨à®£à¯à®ªà®à®²à¯|à®à®±à¯à®ªà®¾à®à¯|à®®à®¾à®²à¯/,
          meridiem: function (hour, minute, isLower) {
              if (hour < 2) {
                  return ' à®¯à®¾à®®à®®à¯';
              } else if (hour < 6) {
                  return ' à®µà¯à®à®±à¯'; // à®µà¯à®à®±à¯
              } else if (hour < 10) {
                  return ' à®à®¾à®²à¯'; // à®à®¾à®²à¯
              } else if (hour < 14) {
                  return ' à®¨à®£à¯à®ªà®à®²à¯'; // à®¨à®£à¯à®ªà®à®²à¯
              } else if (hour < 18) {
                  return ' à®à®±à¯à®ªà®¾à®à¯'; // à®à®±à¯à®ªà®¾à®à¯
              } else if (hour < 22) {
                  return ' à®®à®¾à®²à¯'; // à®®à®¾à®²à¯
              } else {
                  return ' à®¯à®¾à®®à®®à¯';
              }
          },
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à®¯à®¾à®®à®®à¯') {
                  return hour < 2 ? hour : hour + 12;
              } else if (meridiem === 'à®µà¯à®à®±à¯' || meridiem === 'à®à®¾à®²à¯') {
                  return hour;
              } else if (meridiem === 'à®¨à®£à¯à®ªà®à®²à¯') {
                  return hour >= 10 ? hour : hour + 12;
              } else {
                  return hour + 12;
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('te', {
          months: 'à°à°¨à°µà°°à°¿_à°«à°¿à°¬à±à°°à°µà°°à°¿_à°®à°¾à°°à±à°à°¿_à°à°ªà±à°°à°¿à°²à±_à°®à±_à°à±à°¨à±_à°à±à°²à±_à°à°à°¸à±à°à±_à°¸à±à°ªà±à°à±à°à°¬à°°à±_à°à°à±à°à±à°¬à°°à±_à°¨à°µà°à°¬à°°à±_à°¡à°¿à°¸à±à°à°¬à°°à±'.split(
              '_'
          ),
          monthsShort: 'à°à°¨._à°«à°¿à°¬à±à°°._à°®à°¾à°°à±à°à°¿_à°à°ªà±à°°à°¿._à°®à±_à°à±à°¨à±_à°à±à°²à±_à°à°._à°¸à±à°ªà±._à°à°à±à°à±._à°¨à°µ._à°¡à°¿à°¸à±.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'à°à°¦à°¿à°µà°¾à°°à°_à°¸à±à°®à°µà°¾à°°à°_à°®à°à°à°³à°µà°¾à°°à°_à°¬à±à°§à°µà°¾à°°à°_à°à±à°°à±à°µà°¾à°°à°_à°¶à±à°à±à°°à°µà°¾à°°à°_à°¶à°¨à°¿à°µà°¾à°°à°'.split(
              '_'
          ),
          weekdaysShort: 'à°à°¦à°¿_à°¸à±à°®_à°®à°à°à°³_à°¬à±à°§_à°à±à°°à±_à°¶à±à°à±à°°_à°¶à°¨à°¿'.split('_'),
          weekdaysMin: 'à°_à°¸à±_à°®à°_à°¬à±_à°à±_à°¶à±_à°¶'.split('_'),
          longDateFormat: {
              LT: 'A h:mm',
              LTS: 'A h:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY, A h:mm',
              LLLL: 'dddd, D MMMM YYYY, A h:mm',
          },
          calendar: {
              sameDay: '[à°¨à±à°¡à±] LT',
              nextDay: '[à°°à±à°ªà±] LT',
              nextWeek: 'dddd, LT',
              lastDay: '[à°¨à°¿à°¨à±à°¨] LT',
              lastWeek: '[à°à°¤] dddd, LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s à°²à±',
              past: '%s à°à±à°°à°¿à°¤à°',
              s: 'à°à±à°¨à±à°¨à°¿ à°à±à°·à°£à°¾à°²à±',
              ss: '%d à°¸à±à°à°¨à±à°²à±',
              m: 'à°à° à°¨à°¿à°®à°¿à°·à°',
              mm: '%d à°¨à°¿à°®à°¿à°·à°¾à°²à±',
              h: 'à°à° à°à°à°',
              hh: '%d à°à°à°à°²à±',
              d: 'à°à° à°°à±à°à±',
              dd: '%d à°°à±à°à±à°²à±',
              M: 'à°à° à°¨à±à°²',
              MM: '%d à°¨à±à°²à°²à±',
              y: 'à°à° à°¸à°à°µà°¤à±à°¸à°°à°',
              yy: '%d à°¸à°à°µà°¤à±à°¸à°°à°¾à°²à±',
          },
          dayOfMonthOrdinalParse: /\d{1,2}à°µ/,
          ordinal: '%dà°µ',
          meridiemParse: /à°°à°¾à°¤à±à°°à°¿|à°à°¦à°¯à°|à°®à°§à±à°¯à°¾à°¹à±à°¨à°|à°¸à°¾à°¯à°à°¤à±à°°à°/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'à°°à°¾à°¤à±à°°à°¿') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'à°à°¦à°¯à°') {
                  return hour;
              } else if (meridiem === 'à°®à°§à±à°¯à°¾à°¹à±à°¨à°') {
                  return hour >= 10 ? hour : hour + 12;
              } else if (meridiem === 'à°¸à°¾à°¯à°à°¤à±à°°à°') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'à°°à°¾à°¤à±à°°à°¿';
              } else if (hour < 10) {
                  return 'à°à°¦à°¯à°';
              } else if (hour < 17) {
                  return 'à°®à°§à±à°¯à°¾à°¹à±à°¨à°';
              } else if (hour < 20) {
                  return 'à°¸à°¾à°¯à°à°¤à±à°°à°';
              } else {
                  return 'à°°à°¾à°¤à±à°°à°¿';
              }
          },
          week: {
              dow: 0, // Sunday is the first day of the week.
              doy: 6, // The week that contains Jan 6th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('tet', {
          months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_JuÃ±u_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split(
              '_'
          ),
          monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
          weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
          weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
          weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[Ohin iha] LT',
              nextDay: '[Aban iha] LT',
              nextWeek: 'dddd [iha] LT',
              lastDay: '[Horiseik iha] LT',
              lastWeek: 'dddd [semana kotuk] [iha] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'iha %s',
              past: '%s liuba',
              s: 'segundu balun',
              ss: 'segundu %d',
              m: 'minutu ida',
              mm: 'minutu %d',
              h: 'oras ida',
              hh: 'oras %d',
              d: 'loron ida',
              dd: 'loron %d',
              M: 'fulan ida',
              MM: 'fulan %d',
              y: 'tinan ida',
              yy: 'tinan %d',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var suffixes$3 = {
          0: '-ÑÐ¼',
          1: '-ÑÐ¼',
          2: '-ÑÐ¼',
          3: '-ÑÐ¼',
          4: '-ÑÐ¼',
          5: '-ÑÐ¼',
          6: '-ÑÐ¼',
          7: '-ÑÐ¼',
          8: '-ÑÐ¼',
          9: '-ÑÐ¼',
          10: '-ÑÐ¼',
          12: '-ÑÐ¼',
          13: '-ÑÐ¼',
          20: '-ÑÐ¼',
          30: '-ÑÐ¼',
          40: '-ÑÐ¼',
          50: '-ÑÐ¼',
          60: '-ÑÐ¼',
          70: '-ÑÐ¼',
          80: '-ÑÐ¼',
          90: '-ÑÐ¼',
          100: '-ÑÐ¼',
      };

      hooks.defineLocale('tg', {
          months: {
              format: 'ÑÐ½Ð²Ð°ÑÐ¸_ÑÐµÐ²ÑÐ°Ð»Ð¸_Ð¼Ð°ÑÑÐ¸_Ð°Ð¿ÑÐµÐ»Ð¸_Ð¼Ð°Ð¹Ð¸_Ð¸ÑÐ½Ð¸_Ð¸ÑÐ»Ð¸_Ð°Ð²Ð³ÑÑÑÐ¸_ÑÐµÐ½ÑÑÐ±ÑÐ¸_Ð¾ÐºÑÑÐ±ÑÐ¸_Ð½Ð¾ÑÐ±ÑÐ¸_Ð´ÐµÐºÐ°Ð±ÑÐ¸'.split(
                  '_'
              ),
              standalone: 'ÑÐ½Ð²Ð°Ñ_ÑÐµÐ²ÑÐ°Ð»_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»_Ð¼Ð°Ð¹_Ð¸ÑÐ½_Ð¸ÑÐ»_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±Ñ_Ð¾ÐºÑÑÐ±Ñ_Ð½Ð¾ÑÐ±Ñ_Ð´ÐµÐºÐ°Ð±Ñ'.split(
                  '_'
              ),
          },
          monthsShort: 'ÑÐ½Ð²_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½_Ð¸ÑÐ»_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ_Ð½Ð¾Ñ_Ð´ÐµÐº'.split('_'),
          weekdays: 'ÑÐºÑÐ°Ð½Ð±Ðµ_Ð´ÑÑÐ°Ð½Ð±Ðµ_ÑÐµÑÐ°Ð½Ð±Ðµ_ÑÐ¾ÑÑÐ°Ð½Ð±Ðµ_Ð¿Ð°Ð½Ò·ÑÐ°Ð½Ð±Ðµ_Ò·ÑÐ¼ÑÐ°_ÑÐ°Ð½Ð±Ðµ'.split(
              '_'
          ),
          weekdaysShort: 'ÑÑÐ±_Ð´ÑÐ±_ÑÑÐ±_ÑÑÐ±_Ð¿ÑÐ±_Ò·ÑÐ¼_ÑÐ½Ð±'.split('_'),
          weekdaysMin: 'ÑÑ_Ð´Ñ_ÑÑ_ÑÑ_Ð¿Ñ_Ò·Ð¼_ÑÐ±'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[ÐÐ¼ÑÓ¯Ð· ÑÐ¾Ð°ÑÐ¸] LT',
              nextDay: '[Ð¤Ð°ÑÐ´Ð¾ ÑÐ¾Ð°ÑÐ¸] LT',
              lastDay: '[ÐÐ¸ÑÓ¯Ð· ÑÐ¾Ð°ÑÐ¸] LT',
              nextWeek: 'dddd[Ð¸] [Ò³Ð°ÑÑÐ°Ð¸ Ð¾ÑÐ½Ð´Ð° ÑÐ¾Ð°ÑÐ¸] LT',
              lastWeek: 'dddd[Ð¸] [Ò³Ð°ÑÑÐ°Ð¸ Ð³ÑÐ·Ð°ÑÑÐ° ÑÐ¾Ð°ÑÐ¸] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ð±Ð°ÑÐ´Ð¸ %s',
              past: '%s Ð¿ÐµÑ',
              s: 'ÑÐºÑÐ°Ð½Ð´ ÑÐ¾Ð½Ð¸Ñ',
              m: 'ÑÐº Ð´Ð°ÒÐ¸ÒÐ°',
              mm: '%d Ð´Ð°ÒÐ¸ÒÐ°',
              h: 'ÑÐº ÑÐ¾Ð°Ñ',
              hh: '%d ÑÐ¾Ð°Ñ',
              d: 'ÑÐº ÑÓ¯Ð·',
              dd: '%d ÑÓ¯Ð·',
              M: 'ÑÐº Ð¼Ð¾Ò³',
              MM: '%d Ð¼Ð¾Ò³',
              y: 'ÑÐº ÑÐ¾Ð»',
              yy: '%d ÑÐ¾Ð»',
          },
          meridiemParse: /ÑÐ°Ð±|ÑÑÐ±Ò³|ÑÓ¯Ð·|Ð±ÐµÐ³Ð¾Ò³/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'ÑÐ°Ð±') {
                  return hour < 4 ? hour : hour + 12;
              } else if (meridiem === 'ÑÑÐ±Ò³') {
                  return hour;
              } else if (meridiem === 'ÑÓ¯Ð·') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'Ð±ÐµÐ³Ð¾Ò³') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'ÑÐ°Ð±';
              } else if (hour < 11) {
                  return 'ÑÑÐ±Ò³';
              } else if (hour < 16) {
                  return 'ÑÓ¯Ð·';
              } else if (hour < 19) {
                  return 'Ð±ÐµÐ³Ð¾Ò³';
              } else {
                  return 'ÑÐ°Ð±';
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(ÑÐ¼|ÑÐ¼)/,
          ordinal: function (number) {
              var a = number % 10,
                  b = number >= 100 ? 100 : null;
              return number + (suffixes$3[number] || suffixes$3[a] || suffixes$3[b]);
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 1th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('th', {
          months: 'à¸¡à¸à¸£à¸²à¸à¸¡_à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹_à¸¡à¸µà¸à¸²à¸à¸¡_à¹à¸¡à¸©à¸²à¸¢à¸_à¸à¸¤à¸©à¸ à¸²à¸à¸¡_à¸¡à¸´à¸à¸¸à¸à¸²à¸¢à¸_à¸à¸£à¸à¸à¸²à¸à¸¡_à¸ªà¸´à¸à¸«à¸²à¸à¸¡_à¸à¸±à¸à¸¢à¸²à¸¢à¸_à¸à¸¸à¸¥à¸²à¸à¸¡_à¸à¸¤à¸¨à¸à¸´à¸à¸²à¸¢à¸_à¸à¸±à¸à¸§à¸²à¸à¸¡'.split(
              '_'
          ),
          monthsShort: 'à¸¡.à¸._à¸.à¸._à¸¡à¸µ.à¸._à¹à¸¡.à¸¢._à¸.à¸._à¸¡à¸´.à¸¢._à¸.à¸._à¸ª.à¸._à¸.à¸¢._à¸.à¸._à¸.à¸¢._à¸.à¸.'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'à¸­à¸²à¸à¸´à¸à¸¢à¹_à¸à¸±à¸à¸à¸£à¹_à¸­à¸±à¸à¸à¸²à¸£_à¸à¸¸à¸_à¸à¸¤à¸«à¸±à¸ªà¸à¸à¸µ_à¸¨à¸¸à¸à¸£à¹_à¹à¸ªà¸²à¸£à¹'.split('_'),
          weekdaysShort: 'à¸­à¸²à¸à¸´à¸à¸¢à¹_à¸à¸±à¸à¸à¸£à¹_à¸­à¸±à¸à¸à¸²à¸£_à¸à¸¸à¸_à¸à¸¤à¸«à¸±à¸ª_à¸¨à¸¸à¸à¸£à¹_à¹à¸ªà¸²à¸£à¹'.split('_'), // yes, three characters difference
          weekdaysMin: 'à¸­à¸²._à¸._à¸­._à¸._à¸à¸¤._à¸¨._à¸ª.'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY à¹à¸§à¸¥à¸² H:mm',
              LLLL: 'à¸§à¸±à¸ddddà¸à¸µà¹ D MMMM YYYY à¹à¸§à¸¥à¸² H:mm',
          },
          meridiemParse: /à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸|à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸/,
          isPM: function (input) {
              return input === 'à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸';
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸';
              } else {
                  return 'à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸';
              }
          },
          calendar: {
              sameDay: '[à¸§à¸±à¸à¸à¸µà¹ à¹à¸§à¸¥à¸²] LT',
              nextDay: '[à¸à¸£à¸¸à¹à¸à¸à¸µà¹ à¹à¸§à¸¥à¸²] LT',
              nextWeek: 'dddd[à¸«à¸à¹à¸² à¹à¸§à¸¥à¸²] LT',
              lastDay: '[à¹à¸¡à¸·à¹à¸­à¸§à¸²à¸à¸à¸µà¹ à¹à¸§à¸¥à¸²] LT',
              lastWeek: '[à¸§à¸±à¸]dddd[à¸à¸µà¹à¹à¸¥à¹à¸§ à¹à¸§à¸¥à¸²] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'à¸­à¸µà¸ %s',
              past: '%sà¸à¸µà¹à¹à¸¥à¹à¸§',
              s: 'à¹à¸¡à¹à¸à¸µà¹à¸§à¸´à¸à¸²à¸à¸µ',
              ss: '%d à¸§à¸´à¸à¸²à¸à¸µ',
              m: '1 à¸à¸²à¸à¸µ',
              mm: '%d à¸à¸²à¸à¸µ',
              h: '1 à¸à¸±à¹à¸§à¹à¸¡à¸',
              hh: '%d à¸à¸±à¹à¸§à¹à¸¡à¸',
              d: '1 à¸§à¸±à¸',
              dd: '%d à¸§à¸±à¸',
              w: '1 à¸ªà¸±à¸à¸à¸²à¸«à¹',
              ww: '%d à¸ªà¸±à¸à¸à¸²à¸«à¹',
              M: '1 à¹à¸à¸·à¸­à¸',
              MM: '%d à¹à¸à¸·à¸­à¸',
              y: '1 à¸à¸µ',
              yy: '%d à¸à¸µ',
          },
      });

      //! moment.js locale configuration

      var suffixes$4 = {
          1: "'inji",
          5: "'inji",
          8: "'inji",
          70: "'inji",
          80: "'inji",
          2: "'nji",
          7: "'nji",
          20: "'nji",
          50: "'nji",
          3: "'Ã¼nji",
          4: "'Ã¼nji",
          100: "'Ã¼nji",
          6: "'njy",
          9: "'unjy",
          10: "'unjy",
          30: "'unjy",
          60: "'ynjy",
          90: "'ynjy",
      };

      hooks.defineLocale('tk', {
          months: 'Ãanwar_Fewral_Mart_Aprel_MaÃ½_IÃ½un_IÃ½ul_Awgust_SentÃ½abr_OktÃ½abr_NoÃ½abr_Dekabr'.split(
              '_'
          ),
          monthsShort: 'Ãan_Few_Mar_Apr_MaÃ½_IÃ½n_IÃ½l_Awg_Sen_Okt_NoÃ½_Dek'.split('_'),
          weekdays: 'ÃekÅenbe_DuÅenbe_SiÅenbe_ÃarÅenbe_PenÅenbe_Anna_Åenbe'.split(
              '_'
          ),
          weekdaysShort: 'Ãek_DuÅ_SiÅ_Ãar_Pen_Ann_Åen'.split('_'),
          weekdaysMin: 'Ãk_DÅ_SÅ_Ãr_Pn_An_Ån'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[bugÃ¼n sagat] LT',
              nextDay: '[ertir sagat] LT',
              nextWeek: '[indiki] dddd [sagat] LT',
              lastDay: '[dÃ¼Ã½n] LT',
              lastWeek: '[geÃ§en] dddd [sagat] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s soÅ',
              past: '%s Ã¶Å',
              s: 'birnÃ¤Ã§e sekunt',
              m: 'bir minut',
              mm: '%d minut',
              h: 'bir sagat',
              hh: '%d sagat',
              d: 'bir gÃ¼n',
              dd: '%d gÃ¼n',
              M: 'bir aÃ½',
              MM: '%d aÃ½',
              y: 'bir Ã½yl',
              yy: '%d Ã½yl',
          },
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'Do':
                  case 'DD':
                      return number;
                  default:
                      if (number === 0) {
                          // special case for zero
                          return number + "'unjy";
                      }
                      var a = number % 10,
                          b = (number % 100) - a,
                          c = number >= 100 ? 100 : null;
                      return number + (suffixes$4[a] || suffixes$4[b] || suffixes$4[c]);
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('tl-ph', {
          months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
              '_'
          ),
          monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
          weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
              '_'
          ),
          weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
          weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'MM/D/YYYY',
              LL: 'MMMM D, YYYY',
              LLL: 'MMMM D, YYYY HH:mm',
              LLLL: 'dddd, MMMM DD, YYYY HH:mm',
          },
          calendar: {
              sameDay: 'LT [ngayong araw]',
              nextDay: '[Bukas ng] LT',
              nextWeek: 'LT [sa susunod na] dddd',
              lastDay: 'LT [kahapon]',
              lastWeek: 'LT [noong nakaraang] dddd',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'sa loob ng %s',
              past: '%s ang nakalipas',
              s: 'ilang segundo',
              ss: '%d segundo',
              m: 'isang minuto',
              mm: '%d minuto',
              h: 'isang oras',
              hh: '%d oras',
              d: 'isang araw',
              dd: '%d araw',
              M: 'isang buwan',
              MM: '%d buwan',
              y: 'isang taon',
              yy: '%d taon',
          },
          dayOfMonthOrdinalParse: /\d{1,2}/,
          ordinal: function (number) {
              return number;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var numbersNouns = 'pagh_waâ_chaâ_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

      function translateFuture(output) {
          var time = output;
          time =
              output.indexOf('jaj') !== -1
                  ? time.slice(0, -3) + 'leS'
                  : output.indexOf('jar') !== -1
                  ? time.slice(0, -3) + 'waQ'
                  : output.indexOf('DIS') !== -1
                  ? time.slice(0, -3) + 'nem'
                  : time + ' pIq';
          return time;
      }

      function translatePast(output) {
          var time = output;
          time =
              output.indexOf('jaj') !== -1
                  ? time.slice(0, -3) + 'Huâ'
                  : output.indexOf('jar') !== -1
                  ? time.slice(0, -3) + 'wen'
                  : output.indexOf('DIS') !== -1
                  ? time.slice(0, -3) + 'ben'
                  : time + ' ret';
          return time;
      }

      function translate$a(number, withoutSuffix, string, isFuture) {
          var numberNoun = numberAsNoun(number);
          switch (string) {
              case 'ss':
                  return numberNoun + ' lup';
              case 'mm':
                  return numberNoun + ' tup';
              case 'hh':
                  return numberNoun + ' rep';
              case 'dd':
                  return numberNoun + ' jaj';
              case 'MM':
                  return numberNoun + ' jar';
              case 'yy':
                  return numberNoun + ' DIS';
          }
      }

      function numberAsNoun(number) {
          var hundred = Math.floor((number % 1000) / 100),
              ten = Math.floor((number % 100) / 10),
              one = number % 10,
              word = '';
          if (hundred > 0) {
              word += numbersNouns[hundred] + 'vatlh';
          }
          if (ten > 0) {
              word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
          }
          if (one > 0) {
              word += (word !== '' ? ' ' : '') + numbersNouns[one];
          }
          return word === '' ? 'pagh' : word;
      }

      hooks.defineLocale('tlh', {
          months: 'teraâ jar waâ_teraâ jar chaâ_teraâ jar wej_teraâ jar loS_teraâ jar vagh_teraâ jar jav_teraâ jar Soch_teraâ jar chorgh_teraâ jar Hut_teraâ jar waâmaH_teraâ jar waâmaH waâ_teraâ jar waâmaH chaâ'.split(
              '_'
          ),
          monthsShort: 'jar waâ_jar chaâ_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar waâmaH_jar waâmaH waâ_jar waâmaH chaâ'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
              '_'
          ),
          weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
              '_'
          ),
          weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
              '_'
          ),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[DaHjaj] LT',
              nextDay: '[waâleS] LT',
              nextWeek: 'LLL',
              lastDay: '[waâHuâ] LT',
              lastWeek: 'LLL',
              sameElse: 'L',
          },
          relativeTime: {
              future: translateFuture,
              past: translatePast,
              s: 'puS lup',
              ss: translate$a,
              m: 'waâ tup',
              mm: translate$a,
              h: 'waâ rep',
              hh: translate$a,
              d: 'waâ jaj',
              dd: translate$a,
              M: 'waâ jar',
              MM: translate$a,
              y: 'waâ DIS',
              yy: translate$a,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var suffixes$5 = {
          1: "'inci",
          5: "'inci",
          8: "'inci",
          70: "'inci",
          80: "'inci",
          2: "'nci",
          7: "'nci",
          20: "'nci",
          50: "'nci",
          3: "'Ã¼ncÃ¼",
          4: "'Ã¼ncÃ¼",
          100: "'Ã¼ncÃ¼",
          6: "'ncÄ±",
          9: "'uncu",
          10: "'uncu",
          30: "'uncu",
          60: "'Ä±ncÄ±",
          90: "'Ä±ncÄ±",
      };

      hooks.defineLocale('tr', {
          months: 'Ocak_Åubat_Mart_Nisan_MayÄ±s_Haziran_Temmuz_AÄustos_EylÃ¼l_Ekim_KasÄ±m_AralÄ±k'.split(
              '_'
          ),
          monthsShort: 'Oca_Åub_Mar_Nis_May_Haz_Tem_AÄu_Eyl_Eki_Kas_Ara'.split('_'),
          weekdays: 'Pazar_Pazartesi_SalÄ±_ÃarÅamba_PerÅembe_Cuma_Cumartesi'.split(
              '_'
          ),
          weekdaysShort: 'Paz_Pts_Sal_Ãar_Per_Cum_Cts'.split('_'),
          weekdaysMin: 'Pz_Pt_Sa_Ãa_Pe_Cu_Ct'.split('_'),
          meridiem: function (hours, minutes, isLower) {
              if (hours < 12) {
                  return isLower ? 'Ã¶Ã¶' : 'ÃÃ';
              } else {
                  return isLower ? 'Ã¶s' : 'ÃS';
              }
          },
          meridiemParse: /Ã¶Ã¶|ÃÃ|Ã¶s|ÃS/,
          isPM: function (input) {
              return input === 'Ã¶s' || input === 'ÃS';
          },
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[bugÃ¼n saat] LT',
              nextDay: '[yarÄ±n saat] LT',
              nextWeek: '[gelecek] dddd [saat] LT',
              lastDay: '[dÃ¼n] LT',
              lastWeek: '[geÃ§en] dddd [saat] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s sonra',
              past: '%s Ã¶nce',
              s: 'birkaÃ§ saniye',
              ss: '%d saniye',
              m: 'bir dakika',
              mm: '%d dakika',
              h: 'bir saat',
              hh: '%d saat',
              d: 'bir gÃ¼n',
              dd: '%d gÃ¼n',
              w: 'bir hafta',
              ww: '%d hafta',
              M: 'bir ay',
              MM: '%d ay',
              y: 'bir yÄ±l',
              yy: '%d yÄ±l',
          },
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'Do':
                  case 'DD':
                      return number;
                  default:
                      if (number === 0) {
                          // special case for zero
                          return number + "'Ä±ncÄ±";
                      }
                      var a = number % 10,
                          b = (number % 100) - a,
                          c = number >= 100 ? 100 : null;
                      return number + (suffixes$5[a] || suffixes$5[b] || suffixes$5[c]);
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
      // This is currently too difficult (maybe even impossible) to add.
      hooks.defineLocale('tzl', {
          months: 'Januar_Fevraglh_MarÃ§_AvrÃ¯u_Mai_GÃ¼n_Julia_Guscht_Setemvar_ListopÃ¤ts_Noemvar_Zecemvar'.split(
              '_'
          ),
          monthsShort: 'Jan_Fev_Mar_Avr_Mai_GÃ¼n_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
          weekdays: 'SÃºladi_LÃºneÃ§i_Maitzi_MÃ¡rcuri_XhÃºadi_ViÃ©nerÃ§i_SÃ¡turi'.split('_'),
          weekdaysShort: 'SÃºl_LÃºn_Mai_MÃ¡r_XhÃº_ViÃ©_SÃ¡t'.split('_'),
          weekdaysMin: 'SÃº_LÃº_Ma_MÃ¡_Xh_Vi_SÃ¡'.split('_'),
          longDateFormat: {
              LT: 'HH.mm',
              LTS: 'HH.mm.ss',
              L: 'DD.MM.YYYY',
              LL: 'D. MMMM [dallas] YYYY',
              LLL: 'D. MMMM [dallas] YYYY HH.mm',
              LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm',
          },
          meridiemParse: /d\'o|d\'a/i,
          isPM: function (input) {
              return "d'o" === input.toLowerCase();
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours > 11) {
                  return isLower ? "d'o" : "D'O";
              } else {
                  return isLower ? "d'a" : "D'A";
              }
          },
          calendar: {
              sameDay: '[oxhi Ã ] LT',
              nextDay: '[demÃ  Ã ] LT',
              nextWeek: 'dddd [Ã ] LT',
              lastDay: '[ieiri Ã ] LT',
              lastWeek: '[sÃ¼r el] dddd [lasteu Ã ] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'osprei %s',
              past: 'ja%s',
              s: processRelativeTime$8,
              ss: processRelativeTime$8,
              m: processRelativeTime$8,
              mm: processRelativeTime$8,
              h: processRelativeTime$8,
              hh: processRelativeTime$8,
              d: processRelativeTime$8,
              dd: processRelativeTime$8,
              M: processRelativeTime$8,
              MM: processRelativeTime$8,
              y: processRelativeTime$8,
              yy: processRelativeTime$8,
          },
          dayOfMonthOrdinalParse: /\d{1,2}\./,
          ordinal: '%d.',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      function processRelativeTime$8(number, withoutSuffix, key, isFuture) {
          var format = {
              s: ['viensas secunds', "'iensas secunds"],
              ss: [number + ' secunds', '' + number + ' secunds'],
              m: ["'n mÃ­ut", "'iens mÃ­ut"],
              mm: [number + ' mÃ­uts', '' + number + ' mÃ­uts'],
              h: ["'n Ã¾ora", "'iensa Ã¾ora"],
              hh: [number + ' Ã¾oras', '' + number + ' Ã¾oras'],
              d: ["'n ziua", "'iensa ziua"],
              dd: [number + ' ziuas', '' + number + ' ziuas'],
              M: ["'n mes", "'iens mes"],
              MM: [number + ' mesen', '' + number + ' mesen'],
              y: ["'n ar", "'iens ar"],
              yy: [number + ' ars', '' + number + ' ars'],
          };
          return isFuture
              ? format[key][0]
              : withoutSuffix
              ? format[key][0]
              : format[key][1];
      }

      //! moment.js locale configuration

      hooks.defineLocale('tzm-latn', {
          months: 'innayr_brË¤ayrË¤_marË¤sË¤_ibrir_mayyw_ywnyw_ywlywz_É£wÅ¡t_Å¡wtanbir_ktË¤wbrË¤_nwwanbir_dwjnbir'.split(
              '_'
          ),
          monthsShort: 'innayr_brË¤ayrË¤_marË¤sË¤_ibrir_mayyw_ywnyw_ywlywz_É£wÅ¡t_Å¡wtanbir_ktË¤wbrË¤_nwwanbir_dwjnbir'.split(
              '_'
          ),
          weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas'.split('_'),
          weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas'.split('_'),
          weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[asdkh g] LT',
              nextDay: '[aska g] LT',
              nextWeek: 'dddd [g] LT',
              lastDay: '[assant g] LT',
              lastWeek: 'dddd [g] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'dadkh s yan %s',
              past: 'yan %s',
              s: 'imik',
              ss: '%d imik',
              m: 'minuá¸',
              mm: '%d minuá¸',
              h: 'saÉa',
              hh: '%d tassaÉin',
              d: 'ass',
              dd: '%d ossan',
              M: 'ayowr',
              MM: '%d iyyirn',
              y: 'asgas',
              yy: '%d isgasn',
          },
          week: {
              dow: 6, // Saturday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('tzm', {
          months: 'âµâµâµâ´°âµ¢âµ_â´±âµâ´°âµ¢âµ_âµâ´°âµâµ_âµâ´±âµâµâµ_âµâ´°âµ¢âµ¢âµ_âµ¢âµâµâµ¢âµ_âµ¢âµâµâµ¢âµâµ£_âµâµâµâµ_âµâµâµâ´°âµâ´±âµâµ_â´½âµâµâ´±âµ_âµâµâµ¡â´°âµâ´±âµâµ_â´·âµâµâµâ´±âµâµ'.split(
              '_'
          ),
          monthsShort: 'âµâµâµâ´°âµ¢âµ_â´±âµâ´°âµ¢âµ_âµâ´°âµâµ_âµâ´±âµâµâµ_âµâ´°âµ¢âµ¢âµ_âµ¢âµâµâµ¢âµ_âµ¢âµâµâµ¢âµâµ£_âµâµâµâµ_âµâµâµâ´°âµâ´±âµâµ_â´½âµâµâ´±âµ_âµâµâµ¡â´°âµâ´±âµâµ_â´·âµâµâµâ´±âµâµ'.split(
              '_'
          ),
          weekdays: 'â´°âµâ´°âµâ´°âµ_â´°âµ¢âµâ´°âµ_â´°âµâµâµâ´°âµ_â´°â´½âµâ´°âµ_â´°â´½âµ¡â´°âµ_â´°âµâµâµâµ¡â´°âµ_â´°âµâµâ´¹âµ¢â´°âµ'.split('_'),
          weekdaysShort: 'â´°âµâ´°âµâ´°âµ_â´°âµ¢âµâ´°âµ_â´°âµâµâµâ´°âµ_â´°â´½âµâ´°âµ_â´°â´½âµ¡â´°âµ_â´°âµâµâµâµ¡â´°âµ_â´°âµâµâ´¹âµ¢â´°âµ'.split('_'),
          weekdaysMin: 'â´°âµâ´°âµâ´°âµ_â´°âµ¢âµâ´°âµ_â´°âµâµâµâ´°âµ_â´°â´½âµâ´°âµ_â´°â´½âµ¡â´°âµ_â´°âµâµâµâµ¡â´°âµ_â´°âµâµâ´¹âµ¢â´°âµ'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[â´°âµâ´·âµ â´´] LT',
              nextDay: '[â´°âµâ´½â´° â´´] LT',
              nextWeek: 'dddd [â´´] LT',
              lastDay: '[â´°âµâ´°âµâµ â´´] LT',
              lastWeek: 'dddd [â´´] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'â´·â´°â´·âµ âµ âµ¢â´°âµ %s',
              past: 'âµ¢â´°âµ %s',
              s: 'âµâµâµâ´½',
              ss: '%d âµâµâµâ´½',
              m: 'âµâµâµâµâ´º',
              mm: '%d âµâµâµâµâ´º',
              h: 'âµâ´°âµâ´°',
              hh: '%d âµâ´°âµâµâ´°âµâµâµ',
              d: 'â´°âµâµ',
              dd: '%d oâµâµâ´°âµ',
              M: 'â´°âµ¢oâµâµ',
              MM: '%d âµâµ¢âµ¢âµâµâµ',
              y: 'â´°âµâ´³â´°âµ',
              yy: '%d âµâµâ´³â´°âµâµ',
          },
          week: {
              dow: 6, // Saturday is the first day of the week.
              doy: 12, // The week that contains Jan 12th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('ug-cn', {
          months: 'ÙØ§ÙÛØ§Ø±_ÙÛÛØ±Ø§Ù_ÙØ§Ø±Øª_Ø¦Ø§Ù¾Ø±ÛÙ_ÙØ§Ù_Ø¦ÙÙÛÙ_Ø¦ÙÙÛÙ_Ø¦Ø§ÛØºÛØ³Øª_Ø³ÛÙØªÛØ¨ÙØ±_Ø¦ÛÙØªÛØ¨ÙØ±_ÙÙÙØ§Ø¨ÙØ±_Ø¯ÛÙØ§Ø¨ÙØ±'.split(
              '_'
          ),
          monthsShort: 'ÙØ§ÙÛØ§Ø±_ÙÛÛØ±Ø§Ù_ÙØ§Ø±Øª_Ø¦Ø§Ù¾Ø±ÛÙ_ÙØ§Ù_Ø¦ÙÙÛÙ_Ø¦ÙÙÛÙ_Ø¦Ø§ÛØºÛØ³Øª_Ø³ÛÙØªÛØ¨ÙØ±_Ø¦ÛÙØªÛØ¨ÙØ±_ÙÙÙØ§Ø¨ÙØ±_Ø¯ÛÙØ§Ø¨ÙØ±'.split(
              '_'
          ),
          weekdays: 'ÙÛÙØ´ÛÙØ¨Û_Ø¯ÛØ´ÛÙØ¨Û_Ø³ÛÙØ´ÛÙØ¨Û_ÚØ§Ø±Ø´ÛÙØ¨Û_Ù¾ÛÙØ´ÛÙØ¨Û_Ø¬ÛÙÛ_Ø´ÛÙØ¨Û'.split(
              '_'
          ),
          weekdaysShort: 'ÙÛ_Ø¯Û_Ø³Û_ÚØ§_Ù¾Û_Ø¬Û_Ø´Û'.split('_'),
          weekdaysMin: 'ÙÛ_Ø¯Û_Ø³Û_ÚØ§_Ù¾Û_Ø¬Û_Ø´Û'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY-MM-DD',
              LL: 'YYYY-ÙÙÙÙM-Ø¦Ø§ÙÙÙÚ­D-ÙÛÙÙ',
              LLL: 'YYYY-ÙÙÙÙM-Ø¦Ø§ÙÙÙÚ­D-ÙÛÙÙØ HH:mm',
              LLLL: 'ddddØ YYYY-ÙÙÙÙM-Ø¦Ø§ÙÙÙÚ­D-ÙÛÙÙØ HH:mm',
          },
          meridiemParse: /ÙÛØ±ÙÙ ÙÛÚÛ|Ø³ÛÚ¾ÛØ±|ÚÛØ´ØªÙÙ Ø¨ÛØ±ÛÙ|ÚÛØ´|ÚÛØ´ØªÙÙ ÙÛÙÙÙ|ÙÛÚ/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (
                  meridiem === 'ÙÛØ±ÙÙ ÙÛÚÛ' ||
                  meridiem === 'Ø³ÛÚ¾ÛØ±' ||
                  meridiem === 'ÚÛØ´ØªÙÙ Ø¨ÛØ±ÛÙ'
              ) {
                  return hour;
              } else if (meridiem === 'ÚÛØ´ØªÙÙ ÙÛÙÙÙ' || meridiem === 'ÙÛÚ') {
                  return hour + 12;
              } else {
                  return hour >= 11 ? hour : hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              var hm = hour * 100 + minute;
              if (hm < 600) {
                  return 'ÙÛØ±ÙÙ ÙÛÚÛ';
              } else if (hm < 900) {
                  return 'Ø³ÛÚ¾ÛØ±';
              } else if (hm < 1130) {
                  return 'ÚÛØ´ØªÙÙ Ø¨ÛØ±ÛÙ';
              } else if (hm < 1230) {
                  return 'ÚÛØ´';
              } else if (hm < 1800) {
                  return 'ÚÛØ´ØªÙÙ ÙÛÙÙÙ';
              } else {
                  return 'ÙÛÚ';
              }
          },
          calendar: {
              sameDay: '[Ø¨ÛÚ¯ÛÙ Ø³Ø§Ø¦ÛØª] LT',
              nextDay: '[Ø¦ÛØªÛ Ø³Ø§Ø¦ÛØª] LT',
              nextWeek: '[ÙÛÙÛØ±ÙÙ] dddd [Ø³Ø§Ø¦ÛØª] LT',
              lastDay: '[ØªÛÙÛÚ¯ÛÙ] LT',
              lastWeek: '[Ø¦Ø§ÙØ¯ÙÙÙÙ] dddd [Ø³Ø§Ø¦ÛØª] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s ÙÛÙÙÙ',
              past: '%s Ø¨ÛØ±ÛÙ',
              s: 'ÙÛÚÚÛ Ø³ÛÙÙÙØª',
              ss: '%d Ø³ÛÙÙÙØª',
              m: 'Ø¨ÙØ± ÙÙÙÛØª',
              mm: '%d ÙÙÙÛØª',
              h: 'Ø¨ÙØ± Ø³Ø§Ø¦ÛØª',
              hh: '%d Ø³Ø§Ø¦ÛØª',
              d: 'Ø¨ÙØ± ÙÛÙ',
              dd: '%d ÙÛÙ',
              M: 'Ø¨ÙØ± Ø¦Ø§Ù',
              MM: '%d Ø¦Ø§Ù',
              y: 'Ø¨ÙØ± ÙÙÙ',
              yy: '%d ÙÙÙ',
          },

          dayOfMonthOrdinalParse: /\d{1,2}(-ÙÛÙÙ|-Ø¦Ø§Ù|-Ú¾ÛÙ¾ØªÛ)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + '-ÙÛÙÙ';
                  case 'w':
                  case 'W':
                      return number + '-Ú¾ÛÙ¾ØªÛ';
                  default:
                      return number;
              }
          },
          preparse: function (string) {
              return string.replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string.replace(/,/g, 'Ø');
          },
          week: {
              // GB/T 7408-1994ãæ°æ®ååäº¤æ¢æ ¼å¼Â·ä¿¡æ¯äº¤æ¢Â·æ¥æåæ¶é´è¡¨ç¤ºæ³ãä¸ISO 8601:1988ç­æ
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 1st is the first week of the year.
          },
      });

      //! moment.js locale configuration

      function plural$6(word, num) {
          var forms = word.split('_');
          return num % 10 === 1 && num % 100 !== 11
              ? forms[0]
              : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
              ? forms[1]
              : forms[2];
      }
      function relativeTimeWithPlural$4(number, withoutSuffix, key) {
          var format = {
              ss: withoutSuffix ? 'ÑÐµÐºÑÐ½Ð´Ð°_ÑÐµÐºÑÐ½Ð´Ð¸_ÑÐµÐºÑÐ½Ð´' : 'ÑÐµÐºÑÐ½Ð´Ñ_ÑÐµÐºÑÐ½Ð´Ð¸_ÑÐµÐºÑÐ½Ð´',
              mm: withoutSuffix ? 'ÑÐ²Ð¸Ð»Ð¸Ð½Ð°_ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸_ÑÐ²Ð¸Ð»Ð¸Ð½' : 'ÑÐ²Ð¸Ð»Ð¸Ð½Ñ_ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸_ÑÐ²Ð¸Ð»Ð¸Ð½',
              hh: withoutSuffix ? 'Ð³Ð¾Ð´Ð¸Ð½Ð°_Ð³Ð¾Ð´Ð¸Ð½Ð¸_Ð³Ð¾Ð´Ð¸Ð½' : 'Ð³Ð¾Ð´Ð¸Ð½Ñ_Ð³Ð¾Ð´Ð¸Ð½Ð¸_Ð³Ð¾Ð´Ð¸Ð½',
              dd: 'Ð´ÐµÐ½Ñ_Ð´Ð½Ñ_Ð´Ð½ÑÐ²',
              MM: 'Ð¼ÑÑÑÑÑ_Ð¼ÑÑÑÑÑ_Ð¼ÑÑÑÑÑÐ²',
              yy: 'ÑÑÐº_ÑÐ¾ÐºÐ¸_ÑÐ¾ÐºÑÐ²',
          };
          if (key === 'm') {
              return withoutSuffix ? 'ÑÐ²Ð¸Ð»Ð¸Ð½Ð°' : 'ÑÐ²Ð¸Ð»Ð¸Ð½Ñ';
          } else if (key === 'h') {
              return withoutSuffix ? 'Ð³Ð¾Ð´Ð¸Ð½Ð°' : 'Ð³Ð¾Ð´Ð¸Ð½Ñ';
          } else {
              return number + ' ' + plural$6(format[key], +number);
          }
      }
      function weekdaysCaseReplace(m, format) {
          var weekdays = {
                  nominative: 'Ð½ÐµÐ´ÑÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÑÐ»Ð¾Ðº_Ð²ÑÐ²ÑÐ¾ÑÐ¾Ðº_ÑÐµÑÐµÐ´Ð°_ÑÐµÑÐ²ÐµÑ_Ð¿âÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð¾ÑÐ°'.split(
                      '_'
                  ),
                  accusative: 'Ð½ÐµÐ´ÑÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÑÐ»Ð¾Ðº_Ð²ÑÐ²ÑÐ¾ÑÐ¾Ðº_ÑÐµÑÐµÐ´Ñ_ÑÐµÑÐ²ÐµÑ_Ð¿âÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð¾ÑÑ'.split(
                      '_'
                  ),
                  genitive: 'Ð½ÐµÐ´ÑÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÑÐ»ÐºÐ°_Ð²ÑÐ²ÑÐ¾ÑÐºÐ°_ÑÐµÑÐµÐ´Ð¸_ÑÐµÑÐ²ÐµÑÐ³Ð°_Ð¿âÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð¾ÑÐ¸'.split(
                      '_'
                  ),
              },
              nounCase;

          if (m === true) {
              return weekdays['nominative']
                  .slice(1, 7)
                  .concat(weekdays['nominative'].slice(0, 1));
          }
          if (!m) {
              return weekdays['nominative'];
          }

          nounCase = /(\[[ÐÐ²Ð£Ñ]\]) ?dddd/.test(format)
              ? 'accusative'
              : /\[?(?:Ð¼Ð¸Ð½ÑÐ»Ð¾Ñ|Ð½Ð°ÑÑÑÐ¿Ð½Ð¾Ñ)? ?\] ?dddd/.test(format)
              ? 'genitive'
              : 'nominative';
          return weekdays[nounCase][m.day()];
      }
      function processHoursFunction(str) {
          return function () {
              return str + 'Ð¾' + (this.hours() === 11 ? 'Ð±' : '') + '] LT';
          };
      }

      hooks.defineLocale('uk', {
          months: {
              format: 'ÑÑÑÐ½Ñ_Ð»ÑÑÐ¾Ð³Ð¾_Ð±ÐµÑÐµÐ·Ð½Ñ_ÐºÐ²ÑÑÐ½Ñ_ÑÑÐ°Ð²Ð½Ñ_ÑÐµÑÐ²Ð½Ñ_Ð»Ð¸Ð¿Ð½Ñ_ÑÐµÑÐ¿Ð½Ñ_Ð²ÐµÑÐµÑÐ½Ñ_Ð¶Ð¾Ð²ÑÐ½Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´Ð°_Ð³ÑÑÐ´Ð½Ñ'.split(
                  '_'
              ),
              standalone: 'ÑÑÑÐµÐ½Ñ_Ð»ÑÑÐ¸Ð¹_Ð±ÐµÑÐµÐ·ÐµÐ½Ñ_ÐºÐ²ÑÑÐµÐ½Ñ_ÑÑÐ°Ð²ÐµÐ½Ñ_ÑÐµÑÐ²ÐµÐ½Ñ_Ð»Ð¸Ð¿ÐµÐ½Ñ_ÑÐµÑÐ¿ÐµÐ½Ñ_Ð²ÐµÑÐµÑÐµÐ½Ñ_Ð¶Ð¾Ð²ÑÐµÐ½Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´_Ð³ÑÑÐ´ÐµÐ½Ñ'.split(
                  '_'
              ),
          },
          monthsShort: 'ÑÑÑ_Ð»ÑÑ_Ð±ÐµÑ_ÐºÐ²ÑÑ_ÑÑÐ°Ð²_ÑÐµÑÐ²_Ð»Ð¸Ð¿_ÑÐµÑÐ¿_Ð²ÐµÑ_Ð¶Ð¾Ð²Ñ_Ð»Ð¸ÑÑ_Ð³ÑÑÐ´'.split(
              '_'
          ),
          weekdays: weekdaysCaseReplace,
          weekdaysShort: 'Ð½Ð´_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±'.split('_'),
          weekdaysMin: 'Ð½Ð´_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD.MM.YYYY',
              LL: 'D MMMM YYYY Ñ.',
              LLL: 'D MMMM YYYY Ñ., HH:mm',
              LLLL: 'dddd, D MMMM YYYY Ñ., HH:mm',
          },
          calendar: {
              sameDay: processHoursFunction('[Ð¡ÑÐ¾Ð³Ð¾Ð´Ð½Ñ '),
              nextDay: processHoursFunction('[ÐÐ°Ð²ÑÑÐ° '),
              lastDay: processHoursFunction('[ÐÑÐ¾ÑÐ° '),
              nextWeek: processHoursFunction('[Ð£] dddd ['),
              lastWeek: function () {
                  switch (this.day()) {
                      case 0:
                      case 3:
                      case 5:
                      case 6:
                          return processHoursFunction('[ÐÐ¸Ð½ÑÐ»Ð¾Ñ] dddd [').call(this);
                      case 1:
                      case 2:
                      case 4:
                          return processHoursFunction('[ÐÐ¸Ð½ÑÐ»Ð¾Ð³Ð¾] dddd [').call(this);
                  }
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ð·Ð° %s',
              past: '%s ÑÐ¾Ð¼Ñ',
              s: 'Ð´ÐµÐºÑÐ»ÑÐºÐ° ÑÐµÐºÑÐ½Ð´',
              ss: relativeTimeWithPlural$4,
              m: relativeTimeWithPlural$4,
              mm: relativeTimeWithPlural$4,
              h: 'Ð³Ð¾Ð´Ð¸Ð½Ñ',
              hh: relativeTimeWithPlural$4,
              d: 'Ð´ÐµÐ½Ñ',
              dd: relativeTimeWithPlural$4,
              M: 'Ð¼ÑÑÑÑÑ',
              MM: relativeTimeWithPlural$4,
              y: 'ÑÑÐº',
              yy: relativeTimeWithPlural$4,
          },
          // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
          meridiemParse: /Ð½Ð¾ÑÑ|ÑÐ°Ð½ÐºÑ|Ð´Ð½Ñ|Ð²ÐµÑÐ¾ÑÐ°/,
          isPM: function (input) {
              return /^(Ð´Ð½Ñ|Ð²ÐµÑÐ¾ÑÐ°)$/.test(input);
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 4) {
                  return 'Ð½Ð¾ÑÑ';
              } else if (hour < 12) {
                  return 'ÑÐ°Ð½ÐºÑ';
              } else if (hour < 17) {
                  return 'Ð´Ð½Ñ';
              } else {
                  return 'Ð²ÐµÑÐ¾ÑÐ°';
              }
          },
          dayOfMonthOrdinalParse: /\d{1,2}-(Ð¹|Ð³Ð¾)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'M':
                  case 'd':
                  case 'DDD':
                  case 'w':
                  case 'W':
                      return number + '-Ð¹';
                  case 'D':
                      return number + '-Ð³Ð¾';
                  default:
                      return number;
              }
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      var months$b = [
              'Ø¬ÙÙØ±Û',
              'ÙØ±ÙØ±Û',
              'ÙØ§Ø±Ú',
              'Ø§Ù¾Ø±ÛÙ',
              'ÙØ¦Û',
              'Ø¬ÙÙ',
              'Ø¬ÙÙØ§Ø¦Û',
              'Ø§Ú¯Ø³Øª',
              'Ø³ØªÙØ¨Ø±',
              'Ø§Ú©ØªÙØ¨Ø±',
              'ÙÙÙØ¨Ø±',
              'Ø¯Ø³ÙØ¨Ø±',
          ],
          days$2 = ['Ø§ØªÙØ§Ø±', 'Ù¾ÛØ±', 'ÙÙÚ¯Ù', 'Ø¨Ø¯Ú¾', 'Ø¬ÙØ¹Ø±Ø§Øª', 'Ø¬ÙØ¹Û', 'ÛÙØªÛ'];

      hooks.defineLocale('ur', {
          months: months$b,
          monthsShort: months$b,
          weekdays: days$2,
          weekdaysShort: days$2,
          weekdaysMin: days$2,
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'ddddØ D MMMM YYYY HH:mm',
          },
          meridiemParse: /ØµØ¨Ø­|Ø´Ø§Ù/,
          isPM: function (input) {
              return 'Ø´Ø§Ù' === input;
          },
          meridiem: function (hour, minute, isLower) {
              if (hour < 12) {
                  return 'ØµØ¨Ø­';
              }
              return 'Ø´Ø§Ù';
          },
          calendar: {
              sameDay: '[Ø¢Ø¬ Ø¨ÙÙØª] LT',
              nextDay: '[Ú©Ù Ø¨ÙÙØª] LT',
              nextWeek: 'dddd [Ø¨ÙÙØª] LT',
              lastDay: '[Ú¯Ø°Ø´ØªÛ Ø±ÙØ² Ø¨ÙÙØª] LT',
              lastWeek: '[Ú¯Ø°Ø´ØªÛ] dddd [Ø¨ÙÙØª] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s Ø¨Ø¹Ø¯',
              past: '%s ÙØ¨Ù',
              s: 'ÚÙØ¯ Ø³ÛÚ©ÙÚ',
              ss: '%d Ø³ÛÚ©ÙÚ',
              m: 'Ø§ÛÚ© ÙÙÙ¹',
              mm: '%d ÙÙÙ¹',
              h: 'Ø§ÛÚ© Ú¯Ú¾ÙÙ¹Û',
              hh: '%d Ú¯Ú¾ÙÙ¹Û',
              d: 'Ø§ÛÚ© Ø¯Ù',
              dd: '%d Ø¯Ù',
              M: 'Ø§ÛÚ© ÙØ§Û',
              MM: '%d ÙØ§Û',
              y: 'Ø§ÛÚ© Ø³Ø§Ù',
              yy: '%d Ø³Ø§Ù',
          },
          preparse: function (string) {
              return string.replace(/Ø/g, ',');
          },
          postformat: function (string) {
              return string.replace(/,/g, 'Ø');
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('uz-latn', {
          months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split(
              '_'
          ),
          monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
          weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split(
              '_'
          ),
          weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
          weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'D MMMM YYYY, dddd HH:mm',
          },
          calendar: {
              sameDay: '[Bugun soat] LT [da]',
              nextDay: '[Ertaga] LT [da]',
              nextWeek: 'dddd [kuni soat] LT [da]',
              lastDay: '[Kecha soat] LT [da]',
              lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Yaqin %s ichida',
              past: 'Bir necha %s oldin',
              s: 'soniya',
              ss: '%d soniya',
              m: 'bir daqiqa',
              mm: '%d daqiqa',
              h: 'bir soat',
              hh: '%d soat',
              d: 'bir kun',
              dd: '%d kun',
              M: 'bir oy',
              MM: '%d oy',
              y: 'bir yil',
              yy: '%d yil',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 7th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('uz', {
          months: 'ÑÐ½Ð²Ð°Ñ_ÑÐµÐ²ÑÐ°Ð»_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»_Ð¼Ð°Ð¹_Ð¸ÑÐ½_Ð¸ÑÐ»_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±Ñ_Ð¾ÐºÑÑÐ±Ñ_Ð½Ð¾ÑÐ±Ñ_Ð´ÐµÐºÐ°Ð±Ñ'.split(
              '_'
          ),
          monthsShort: 'ÑÐ½Ð²_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½_Ð¸ÑÐ»_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ_Ð½Ð¾Ñ_Ð´ÐµÐº'.split('_'),
          weekdays: 'Ð¯ÐºÑÐ°Ð½Ð±Ð°_ÐÑÑÐ°Ð½Ð±Ð°_Ð¡ÐµÑÐ°Ð½Ð±Ð°_Ð§Ð¾ÑÑÐ°Ð½Ð±Ð°_ÐÐ°Ð¹ÑÐ°Ð½Ð±Ð°_ÐÑÐ¼Ð°_Ð¨Ð°Ð½Ð±Ð°'.split('_'),
          weekdaysShort: 'Ð¯ÐºÑ_ÐÑÑ_Ð¡ÐµÑ_Ð§Ð¾Ñ_ÐÐ°Ð¹_ÐÑÐ¼_Ð¨Ð°Ð½'.split('_'),
          weekdaysMin: 'Ð¯Ðº_ÐÑ_Ð¡Ðµ_Ð§Ð¾_ÐÐ°_ÐÑ_Ð¨Ð°'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'D MMMM YYYY, dddd HH:mm',
          },
          calendar: {
              sameDay: '[ÐÑÐ³ÑÐ½ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]',
              nextDay: '[Ð­ÑÑÐ°Ð³Ð°] LT [Ð´Ð°]',
              nextWeek: 'dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]',
              lastDay: '[ÐÐµÑÐ° ÑÐ¾Ð°Ñ] LT [Ð´Ð°]',
              lastWeek: '[Ð£ÑÐ³Ð°Ð½] dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ð¯ÐºÐ¸Ð½ %s Ð¸ÑÐ¸Ð´Ð°',
              past: 'ÐÐ¸Ñ Ð½ÐµÑÐ° %s Ð¾Ð»Ð´Ð¸Ð½',
              s: 'ÑÑÑÑÐ°Ñ',
              ss: '%d ÑÑÑÑÐ°Ñ',
              m: 'Ð±Ð¸Ñ Ð´Ð°ÐºÐ¸ÐºÐ°',
              mm: '%d Ð´Ð°ÐºÐ¸ÐºÐ°',
              h: 'Ð±Ð¸Ñ ÑÐ¾Ð°Ñ',
              hh: '%d ÑÐ¾Ð°Ñ',
              d: 'Ð±Ð¸Ñ ÐºÑÐ½',
              dd: '%d ÐºÑÐ½',
              M: 'Ð±Ð¸Ñ Ð¾Ð¹',
              MM: '%d Ð¾Ð¹',
              y: 'Ð±Ð¸Ñ Ð¹Ð¸Ð»',
              yy: '%d Ð¹Ð¸Ð»',
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 7, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('vi', {
          months: 'thÃ¡ng 1_thÃ¡ng 2_thÃ¡ng 3_thÃ¡ng 4_thÃ¡ng 5_thÃ¡ng 6_thÃ¡ng 7_thÃ¡ng 8_thÃ¡ng 9_thÃ¡ng 10_thÃ¡ng 11_thÃ¡ng 12'.split(
              '_'
          ),
          monthsShort: 'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'chá»§ nháº­t_thá»© hai_thá»© ba_thá»© tÆ°_thá»© nÄm_thá»© sÃ¡u_thá»© báº£y'.split(
              '_'
          ),
          weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
          weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
          weekdaysParseExact: true,
          meridiemParse: /sa|ch/i,
          isPM: function (input) {
              return /^ch$/i.test(input);
          },
          meridiem: function (hours, minutes, isLower) {
              if (hours < 12) {
                  return isLower ? 'sa' : 'SA';
              } else {
                  return isLower ? 'ch' : 'CH';
              }
          },
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM [nÄm] YYYY',
              LLL: 'D MMMM [nÄm] YYYY HH:mm',
              LLLL: 'dddd, D MMMM [nÄm] YYYY HH:mm',
              l: 'DD/M/YYYY',
              ll: 'D MMM YYYY',
              lll: 'D MMM YYYY HH:mm',
              llll: 'ddd, D MMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[HÃ´m nay lÃºc] LT',
              nextDay: '[NgÃ y mai lÃºc] LT',
              nextWeek: 'dddd [tuáº§n tá»i lÃºc] LT',
              lastDay: '[HÃ´m qua lÃºc] LT',
              lastWeek: 'dddd [tuáº§n trÆ°á»c lÃºc] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: '%s tá»i',
              past: '%s trÆ°á»c',
              s: 'vÃ i giÃ¢y',
              ss: '%d giÃ¢y',
              m: 'má»t phÃºt',
              mm: '%d phÃºt',
              h: 'má»t giá»',
              hh: '%d giá»',
              d: 'má»t ngÃ y',
              dd: '%d ngÃ y',
              w: 'má»t tuáº§n',
              ww: '%d tuáº§n',
              M: 'má»t thÃ¡ng',
              MM: '%d thÃ¡ng',
              y: 'má»t nÄm',
              yy: '%d nÄm',
          },
          dayOfMonthOrdinalParse: /\d{1,2}/,
          ordinal: function (number) {
              return number;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('x-pseudo', {
          months: 'J~Ã¡Ã±ÃºÃ¡~rÃ½_F~Ã©brÃº~Ã¡rÃ½_~MÃ¡rc~h_Ãp~rÃ­l_~MÃ¡Ã½_~JÃºÃ±Ã©~_JÃºl~Ã½_ÃÃº~gÃºst~_SÃ©p~tÃ©mb~Ã©r_Ã~ctÃ³b~Ã©r_Ã~Ã³vÃ©m~bÃ©r_~DÃ©cÃ©~mbÃ©r'.split(
              '_'
          ),
          monthsShort: 'J~Ã¡Ã±_~FÃ©b_~MÃ¡r_~Ãpr_~MÃ¡Ã½_~JÃºÃ±_~JÃºl_~ÃÃºg_~SÃ©p_~Ãct_~ÃÃ³v_~DÃ©c'.split(
              '_'
          ),
          monthsParseExact: true,
          weekdays: 'S~ÃºÃ±dÃ¡~Ã½_MÃ³~Ã±dÃ¡Ã½~_TÃºÃ©~sdÃ¡Ã½~_WÃ©d~Ã±Ã©sd~Ã¡Ã½_T~hÃºrs~dÃ¡Ã½_~FrÃ­d~Ã¡Ã½_S~Ã¡tÃºr~dÃ¡Ã½'.split(
              '_'
          ),
          weekdaysShort: 'S~ÃºÃ±_~MÃ³Ã±_~TÃºÃ©_~WÃ©d_~ThÃº_~FrÃ­_~SÃ¡t'.split('_'),
          weekdaysMin: 'S~Ãº_MÃ³~_TÃº_~WÃ©_T~h_Fr~_SÃ¡'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'HH:mm',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY HH:mm',
              LLLL: 'dddd, D MMMM YYYY HH:mm',
          },
          calendar: {
              sameDay: '[T~Ã³dÃ¡~Ã½ Ã¡t] LT',
              nextDay: '[T~Ã³mÃ³~rrÃ³~w Ã¡t] LT',
              nextWeek: 'dddd [Ã¡t] LT',
              lastDay: '[Ã~Ã©st~Ã©rdÃ¡~Ã½ Ã¡t] LT',
              lastWeek: '[L~Ã¡st] dddd [Ã¡t] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'Ã­~Ã± %s',
              past: '%s Ã¡~gÃ³',
              s: 'Ã¡ ~fÃ©w ~sÃ©cÃ³~Ã±ds',
              ss: '%d s~Ã©cÃ³Ã±~ds',
              m: 'Ã¡ ~mÃ­Ã±~ÃºtÃ©',
              mm: '%d m~Ã­Ã±Ãº~tÃ©s',
              h: 'Ã¡~Ã± hÃ³~Ãºr',
              hh: '%d h~Ã³Ãºrs',
              d: 'Ã¡ ~dÃ¡Ã½',
              dd: '%d d~Ã¡Ã½s',
              M: 'Ã¡ ~mÃ³Ã±~th',
              MM: '%d m~Ã³Ã±t~hs',
              y: 'Ã¡ ~Ã½Ã©Ã¡r',
              yy: '%d Ã½~Ã©Ã¡rs',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      ~~((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('yo', {
          months: 'Sáº¹Ìráº¹Ì_EÌreÌleÌ_áº¸ráº¹ÌnaÌ_IÌgbeÌ_EÌbibi_OÌkuÌdu_Agáº¹mo_OÌguÌn_Owewe_á»ÌwaÌraÌ_BeÌluÌ_á»Ìpáº¹ÌÌ'.split(
              '_'
          ),
          monthsShort: 'Sáº¹Ìr_EÌrl_áº¸rn_IÌgb_EÌbi_OÌkuÌ_Agáº¹_OÌguÌ_Owe_á»ÌwaÌ_BeÌl_á»Ìpáº¹ÌÌ'.split('_'),
          weekdays: 'AÌiÌkuÌ_AjeÌ_IÌsáº¹Ìgun_á»já»ÌruÌ_á»já»Ìbá»_áº¸tiÌ_AÌbaÌmáº¹Ìta'.split('_'),
          weekdaysShort: 'AÌiÌk_AjeÌ_IÌsáº¹Ì_á»jr_á»jb_áº¸tiÌ_AÌbaÌ'.split('_'),
          weekdaysMin: 'AÌiÌ_Aj_IÌs_á»r_á»b_áº¸t_AÌb'.split('_'),
          longDateFormat: {
              LT: 'h:mm A',
              LTS: 'h:mm:ss A',
              L: 'DD/MM/YYYY',
              LL: 'D MMMM YYYY',
              LLL: 'D MMMM YYYY h:mm A',
              LLLL: 'dddd, D MMMM YYYY h:mm A',
          },
          calendar: {
              sameDay: '[OÌniÌ ni] LT',
              nextDay: '[á»Ìla ni] LT',
              nextWeek: "dddd [á»sáº¹Ì toÌn'bá»] [ni] LT",
              lastDay: '[AÌna ni] LT',
              lastWeek: 'dddd [á»sáº¹Ì toÌlá»Ì] [ni] LT',
              sameElse: 'L',
          },
          relativeTime: {
              future: 'niÌ %s',
              past: '%s ká»jaÌ',
              s: 'iÌsáº¹juÌ aayaÌ die',
              ss: 'aayaÌ %d',
              m: 'iÌsáº¹juÌ kan',
              mm: 'iÌsáº¹juÌ %d',
              h: 'waÌkati kan',
              hh: 'waÌkati %d',
              d: 'á»já»Ì kan',
              dd: 'á»já»Ì %d',
              M: 'osuÌ kan',
              MM: 'osuÌ %d',
              y: 'á»duÌn kan',
              yy: 'á»duÌn %d',
          },
          dayOfMonthOrdinalParse: /á»já»Ì\s\d{1,2}/,
          ordinal: 'á»já»Ì %d',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('zh-cn', {
          months: 'ä¸æ_äºæ_ä¸æ_åæ_äºæ_å­æ_ä¸æ_å«æ_ä¹æ_åæ_åä¸æ_åäºæ'.split(
              '_'
          ),
          monthsShort: '1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ'.split(
              '_'
          ),
          weekdays: 'æææ¥_ææä¸_ææäº_ææä¸_ææå_ææäº_ææå­'.split('_'),
          weekdaysShort: 'å¨æ¥_å¨ä¸_å¨äº_å¨ä¸_å¨å_å¨äº_å¨å­'.split('_'),
          weekdaysMin: 'æ¥_ä¸_äº_ä¸_å_äº_å­'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY/MM/DD',
              LL: 'YYYYå¹´MæDæ¥',
              LLL: 'YYYYå¹´MæDæ¥Ahç¹mmå',
              LLLL: 'YYYYå¹´MæDæ¥ddddAhç¹mmå',
              l: 'YYYY/M/D',
              ll: 'YYYYå¹´MæDæ¥',
              lll: 'YYYYå¹´MæDæ¥ HH:mm',
              llll: 'YYYYå¹´MæDæ¥dddd HH:mm',
          },
          meridiemParse: /åæ¨|æ©ä¸|ä¸å|ä¸­å|ä¸å|æä¸/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'åæ¨' || meridiem === 'æ©ä¸' || meridiem === 'ä¸å') {
                  return hour;
              } else if (meridiem === 'ä¸å' || meridiem === 'æä¸') {
                  return hour + 12;
              } else {
                  // 'ä¸­å'
                  return hour >= 11 ? hour : hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              var hm = hour * 100 + minute;
              if (hm < 600) {
                  return 'åæ¨';
              } else if (hm < 900) {
                  return 'æ©ä¸';
              } else if (hm < 1130) {
                  return 'ä¸å';
              } else if (hm < 1230) {
                  return 'ä¸­å';
              } else if (hm < 1800) {
                  return 'ä¸å';
              } else {
                  return 'æä¸';
              }
          },
          calendar: {
              sameDay: '[ä»å¤©]LT',
              nextDay: '[æå¤©]LT',
              nextWeek: function (now) {
                  if (now.week() !== this.week()) {
                      return '[ä¸]dddLT';
                  } else {
                      return '[æ¬]dddLT';
                  }
              },
              lastDay: '[æ¨å¤©]LT',
              lastWeek: function (now) {
                  if (this.week() !== now.week()) {
                      return '[ä¸]dddLT';
                  } else {
                      return '[æ¬]dddLT';
                  }
              },
              sameElse: 'L',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(æ¥|æ|å¨)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + 'æ¥';
                  case 'M':
                      return number + 'æ';
                  case 'w':
                  case 'W':
                      return number + 'å¨';
                  default:
                      return number;
              }
          },
          relativeTime: {
              future: '%så',
              past: '%så',
              s: 'å ç§',
              ss: '%d ç§',
              m: '1 åé',
              mm: '%d åé',
              h: '1 å°æ¶',
              hh: '%d å°æ¶',
              d: '1 å¤©',
              dd: '%d å¤©',
              w: '1 å¨',
              ww: '%d å¨',
              M: '1 ä¸ªæ',
              MM: '%d ä¸ªæ',
              y: '1 å¹´',
              yy: '%d å¹´',
          },
          week: {
              // GB/T 7408-1994ãæ°æ®ååäº¤æ¢æ ¼å¼Â·ä¿¡æ¯äº¤æ¢Â·æ¥æåæ¶é´è¡¨ç¤ºæ³ãä¸ISO 8601:1988ç­æ
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('zh-hk', {
          months: 'ä¸æ_äºæ_ä¸æ_åæ_äºæ_å­æ_ä¸æ_å«æ_ä¹æ_åæ_åä¸æ_åäºæ'.split(
              '_'
          ),
          monthsShort: '1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ'.split(
              '_'
          ),
          weekdays: 'æææ¥_ææä¸_ææäº_ææä¸_ææå_ææäº_ææå­'.split('_'),
          weekdaysShort: 'é±æ¥_é±ä¸_é±äº_é±ä¸_é±å_é±äº_é±å­'.split('_'),
          weekdaysMin: 'æ¥_ä¸_äº_ä¸_å_äº_å­'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY/MM/DD',
              LL: 'YYYYå¹´MæDæ¥',
              LLL: 'YYYYå¹´MæDæ¥ HH:mm',
              LLLL: 'YYYYå¹´MæDæ¥dddd HH:mm',
              l: 'YYYY/M/D',
              ll: 'YYYYå¹´MæDæ¥',
              lll: 'YYYYå¹´MæDæ¥ HH:mm',
              llll: 'YYYYå¹´MæDæ¥dddd HH:mm',
          },
          meridiemParse: /åæ¨|æ©ä¸|ä¸å|ä¸­å|ä¸å|æä¸/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'åæ¨' || meridiem === 'æ©ä¸' || meridiem === 'ä¸å') {
                  return hour;
              } else if (meridiem === 'ä¸­å') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'ä¸å' || meridiem === 'æä¸') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              var hm = hour * 100 + minute;
              if (hm < 600) {
                  return 'åæ¨';
              } else if (hm < 900) {
                  return 'æ©ä¸';
              } else if (hm < 1200) {
                  return 'ä¸å';
              } else if (hm === 1200) {
                  return 'ä¸­å';
              } else if (hm < 1800) {
                  return 'ä¸å';
              } else {
                  return 'æä¸';
              }
          },
          calendar: {
              sameDay: '[ä»å¤©]LT',
              nextDay: '[æå¤©]LT',
              nextWeek: '[ä¸]ddddLT',
              lastDay: '[æ¨å¤©]LT',
              lastWeek: '[ä¸]ddddLT',
              sameElse: 'L',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(æ¥|æ|é±)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + 'æ¥';
                  case 'M':
                      return number + 'æ';
                  case 'w':
                  case 'W':
                      return number + 'é±';
                  default:
                      return number;
              }
          },
          relativeTime: {
              future: '%så¾',
              past: '%så',
              s: 'å¹¾ç§',
              ss: '%d ç§',
              m: '1 åé',
              mm: '%d åé',
              h: '1 å°æ',
              hh: '%d å°æ',
              d: '1 å¤©',
              dd: '%d å¤©',
              M: '1 åæ',
              MM: '%d åæ',
              y: '1 å¹´',
              yy: '%d å¹´',
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('zh-mo', {
          months: 'ä¸æ_äºæ_ä¸æ_åæ_äºæ_å­æ_ä¸æ_å«æ_ä¹æ_åæ_åä¸æ_åäºæ'.split(
              '_'
          ),
          monthsShort: '1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ'.split(
              '_'
          ),
          weekdays: 'æææ¥_ææä¸_ææäº_ææä¸_ææå_ææäº_ææå­'.split('_'),
          weekdaysShort: 'é±æ¥_é±ä¸_é±äº_é±ä¸_é±å_é±äº_é±å­'.split('_'),
          weekdaysMin: 'æ¥_ä¸_äº_ä¸_å_äº_å­'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'YYYYå¹´MæDæ¥',
              LLL: 'YYYYå¹´MæDæ¥ HH:mm',
              LLLL: 'YYYYå¹´MæDæ¥dddd HH:mm',
              l: 'D/M/YYYY',
              ll: 'YYYYå¹´MæDæ¥',
              lll: 'YYYYå¹´MæDæ¥ HH:mm',
              llll: 'YYYYå¹´MæDæ¥dddd HH:mm',
          },
          meridiemParse: /åæ¨|æ©ä¸|ä¸å|ä¸­å|ä¸å|æä¸/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'åæ¨' || meridiem === 'æ©ä¸' || meridiem === 'ä¸å') {
                  return hour;
              } else if (meridiem === 'ä¸­å') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'ä¸å' || meridiem === 'æä¸') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              var hm = hour * 100 + minute;
              if (hm < 600) {
                  return 'åæ¨';
              } else if (hm < 900) {
                  return 'æ©ä¸';
              } else if (hm < 1130) {
                  return 'ä¸å';
              } else if (hm < 1230) {
                  return 'ä¸­å';
              } else if (hm < 1800) {
                  return 'ä¸å';
              } else {
                  return 'æä¸';
              }
          },
          calendar: {
              sameDay: '[ä»å¤©] LT',
              nextDay: '[æå¤©] LT',
              nextWeek: '[ä¸]dddd LT',
              lastDay: '[æ¨å¤©] LT',
              lastWeek: '[ä¸]dddd LT',
              sameElse: 'L',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(æ¥|æ|é±)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + 'æ¥';
                  case 'M':
                      return number + 'æ';
                  case 'w':
                  case 'W':
                      return number + 'é±';
                  default:
                      return number;
              }
          },
          relativeTime: {
              future: '%så§',
              past: '%så',
              s: 'å¹¾ç§',
              ss: '%d ç§',
              m: '1 åé',
              mm: '%d åé',
              h: '1 å°æ',
              hh: '%d å°æ',
              d: '1 å¤©',
              dd: '%d å¤©',
              M: '1 åæ',
              MM: '%d åæ',
              y: '1 å¹´',
              yy: '%d å¹´',
          },
      });

      //! moment.js locale configuration

      hooks.defineLocale('zh-tw', {
          months: 'ä¸æ_äºæ_ä¸æ_åæ_äºæ_å­æ_ä¸æ_å«æ_ä¹æ_åæ_åä¸æ_åäºæ'.split(
              '_'
          ),
          monthsShort: '1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ'.split(
              '_'
          ),
          weekdays: 'æææ¥_ææä¸_ææäº_ææä¸_ææå_ææäº_ææå­'.split('_'),
          weekdaysShort: 'é±æ¥_é±ä¸_é±äº_é±ä¸_é±å_é±äº_é±å­'.split('_'),
          weekdaysMin: 'æ¥_ä¸_äº_ä¸_å_äº_å­'.split('_'),
          longDateFormat: {
              LT: 'HH:mm',
              LTS: 'HH:mm:ss',
              L: 'YYYY/MM/DD',
              LL: 'YYYYå¹´MæDæ¥',
              LLL: 'YYYYå¹´MæDæ¥ HH:mm',
              LLLL: 'YYYYå¹´MæDæ¥dddd HH:mm',
              l: 'YYYY/M/D',
              ll: 'YYYYå¹´MæDæ¥',
              lll: 'YYYYå¹´MæDæ¥ HH:mm',
              llll: 'YYYYå¹´MæDæ¥dddd HH:mm',
          },
          meridiemParse: /åæ¨|æ©ä¸|ä¸å|ä¸­å|ä¸å|æä¸/,
          meridiemHour: function (hour, meridiem) {
              if (hour === 12) {
                  hour = 0;
              }
              if (meridiem === 'åæ¨' || meridiem === 'æ©ä¸' || meridiem === 'ä¸å') {
                  return hour;
              } else if (meridiem === 'ä¸­å') {
                  return hour >= 11 ? hour : hour + 12;
              } else if (meridiem === 'ä¸å' || meridiem === 'æä¸') {
                  return hour + 12;
              }
          },
          meridiem: function (hour, minute, isLower) {
              var hm = hour * 100 + minute;
              if (hm < 600) {
                  return 'åæ¨';
              } else if (hm < 900) {
                  return 'æ©ä¸';
              } else if (hm < 1130) {
                  return 'ä¸å';
              } else if (hm < 1230) {
                  return 'ä¸­å';
              } else if (hm < 1800) {
                  return 'ä¸å';
              } else {
                  return 'æä¸';
              }
          },
          calendar: {
              sameDay: '[ä»å¤©] LT',
              nextDay: '[æå¤©] LT',
              nextWeek: '[ä¸]dddd LT',
              lastDay: '[æ¨å¤©] LT',
              lastWeek: '[ä¸]dddd LT',
              sameElse: 'L',
          },
          dayOfMonthOrdinalParse: /\d{1,2}(æ¥|æ|é±)/,
          ordinal: function (number, period) {
              switch (period) {
                  case 'd':
                  case 'D':
                  case 'DDD':
                      return number + 'æ¥';
                  case 'M':
                      return number + 'æ';
                  case 'w':
                  case 'W':
                      return number + 'é±';
                  default:
                      return number;
              }
          },
          relativeTime: {
              future: '%så¾',
              past: '%så',
              s: 'å¹¾ç§',
              ss: '%d ç§',
              m: '1 åé',
              mm: '%d åé',
              h: '1 å°æ',
              hh: '%d å°æ',
              d: '1 å¤©',
              dd: '%d å¤©',
              M: '1 åæ',
              MM: '%d åæ',
              y: '1 å¹´',
              yy: '%d å¹´',
          },
      });

      hooks.locale('en');

      return hooks;

  })));
  }(momentWithLocales));

  var moment$1 = momentWithLocales.exports;

  var momentBusinessDays = {exports: {}};

  var moment = {exports: {}};

  (function (module, exports) {
  (function (global, factory) {
      module.exports = factory() ;
  }(commonjsGlobal, (function () {
      var hookCallback;

      function hooks() {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback(callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return (
              input instanceof Array ||
              Object.prototype.toString.call(input) === '[object Array]'
          );
      }

      function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return (
              input != null &&
              Object.prototype.toString.call(input) === '[object Object]'
          );
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
              return Object.getOwnPropertyNames(obj).length === 0;
          } else {
              var k;
              for (k in obj) {
                  if (hasOwnProp(obj, k)) {
                      return false;
                  }
              }
              return true;
          }
      }

      function isUndefined(input) {
          return input === void 0;
      }

      function isNumber(input) {
          return (
              typeof input === 'number' ||
              Object.prototype.toString.call(input) === '[object Number]'
          );
      }

      function isDate(input) {
          return (
              input instanceof Date ||
              Object.prototype.toString.call(input) === '[object Date]'
          );
      }

      function map(arr, fn) {
          var res = [],
              i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidEra: null,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false,
              parsedDateParts: [],
              era: null,
              meridiem: null,
              rfc2822: false,
              weekdayMismatch: false,
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this),
                  len = t.length >>> 0,
                  i;

              for (i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m),
                  parsedParts = some.call(flags.parsedDateParts, function (i) {
                      return i != null;
                  }),
                  isNowValid =
                      !isNaN(m._d.getTime()) &&
                      flags.overflow < 0 &&
                      !flags.empty &&
                      !flags.invalidEra &&
                      !flags.invalidMonth &&
                      !flags.invalidWeekday &&
                      !flags.weekdayMismatch &&
                      !flags.nullInput &&
                      !flags.invalidFormat &&
                      !flags.userInvalidated &&
                      (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  isNowValid =
                      isNowValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                  m._isValid = isNowValid;
              } else {
                  return isNowValid;
              }
          }
          return m._isValid;
      }

      function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          } else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = (hooks.momentProperties = []),
          updateInProgress = false;

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i = 0; i < momentProperties.length; i++) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
              this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment(obj) {
          return (
              obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
          );
      }

      function warn(msg) {
          if (
              hooks.suppressDeprecationWarnings === false &&
              typeof console !== 'undefined' &&
              console.warn
          ) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (hooks.deprecationHandler != null) {
                  hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  var args = [],
                      arg,
                      i,
                      key;
                  for (i = 0; i < arguments.length; i++) {
                      arg = '';
                      if (typeof arguments[i] === 'object') {
                          arg += '\n[' + i + '] ';
                          for (key in arguments[0]) {
                              if (hasOwnProp(arguments[0], key)) {
                                  arg += key + ': ' + arguments[0][key] + ', ';
                              }
                          }
                          arg = arg.slice(0, -2); // Remove trailing comma and space
                      } else {
                          arg = arguments[i];
                      }
                      args.push(arg);
                  }
                  warn(
                      msg +
                          '\nArguments: ' +
                          Array.prototype.slice.call(args).join('') +
                          '\n' +
                          new Error().stack
                  );
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
          return (
              (typeof Function !== 'undefined' && input instanceof Function) ||
              Object.prototype.toString.call(input) === '[object Function]'
          );
      }

      function set(config) {
          var prop, i;
          for (i in config) {
              if (hasOwnProp(config, i)) {
                  prop = config[i];
                  if (isFunction(prop)) {
                      this[i] = prop;
                  } else {
                      this['_' + i] = prop;
                  }
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                  '|' +
                  /\d{1,2}/.source
          );
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
              prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          for (prop in parentConfig) {
              if (
                  hasOwnProp(parentConfig, prop) &&
                  !hasOwnProp(childConfig, prop) &&
                  isObject(parentConfig[prop])
              ) {
                  // make sure changes to properties don't modify parent config
                  res[prop] = extend({}, res[prop]);
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i,
                  res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      };

      function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (
              (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
              absNumber
          );
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(
                      func.apply(this, arguments),
                      token
                  );
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
              i,
              length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '',
                  i;
              for (i = 0; i < length; i++) {
                  output += isFunction(array[i])
                      ? array[i].call(mom, format)
                      : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] =
              formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(
                  localFormattingTokens,
                  replaceLongDateFormatTokens
              );
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
      };

      function longDateFormat(key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper
              .match(formattingTokens)
              .map(function (tok) {
                  if (
                      tok === 'MMMM' ||
                      tok === 'MM' ||
                      tok === 'DD' ||
                      tok === 'dddd'
                  ) {
                      return tok.slice(1);
                  }
                  return tok;
              })
              .join('');

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate() {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal(number) {
          return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      };

      function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output)
              ? output(number, withoutSuffix, string, isFuture)
              : output.replace(/%d/i, number);
      }

      function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string'
              ? aliases[units] || aliases[units.toLowerCase()]
              : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
          var units = [],
              u;
          for (u in unitsObj) {
              if (hasOwnProp(unitsObj, u)) {
                  units.push({ unit: u, priority: priorities[u] });
              }
          }
          units.sort(function (a, b) {
              return a.priority - b.priority;
          });
          return units;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      function absFloor(number) {
          if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      function makeGetSet(unit, keepTime) {
          return function (value) {
              if (value != null) {
                  set$1(this, unit, value);
                  hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get(this, unit);
              }
          };
      }

      function get(mom, unit) {
          return mom.isValid()
              ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
              : NaN;
      }

      function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
              if (
                  unit === 'FullYear' &&
                  isLeapYear(mom.year()) &&
                  mom.month() === 1 &&
                  mom.date() === 29
              ) {
                  value = toInt(value);
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                      value,
                      mom.month(),
                      daysInMonth(value, mom.month())
                  );
              } else {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
              }
          }
      }

      // MOMENTS

      function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units]();
          }
          return this;
      }

      function stringSet(units, value) {
          if (typeof units === 'object') {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units),
                  i;
              for (i = 0; i < prioritized.length; i++) {
                  this[prioritized[i].unit](units[prioritized[i].unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      var match1 = /\d/, //       0 - 9
          match2 = /\d\d/, //      00 - 99
          match3 = /\d{3}/, //     000 - 999
          match4 = /\d{4}/, //    0000 - 9999
          match6 = /[+-]?\d{6}/, // -999999 - 999999
          match1to2 = /\d\d?/, //       0 - 99
          match3to4 = /\d\d\d\d?/, //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
          match1to3 = /\d{1,3}/, //       0 - 999
          match1to4 = /\d{1,4}/, //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
          matchUnsigned = /\d+/, //       0 - inf
          matchSigned = /[+-]?\d+/, //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          regexes;

      regexes = {};

      function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex)
              ? regex
              : function (isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex;
                };
      }

      function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(
              s
                  .replace('\\', '')
                  .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                      matched,
                      p1,
                      p2,
                      p3,
                      p4
                  ) {
                      return p1 || p2 || p3 || p4;
                  })
          );
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken(token, callback) {
          var i,
              func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (isNumber(callback)) {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;

      function mod(n, x) {
          return ((n % x) + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
              return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1
              ? isLeapYear(year)
                  ? 29
                  : 28
              : 31 - ((modMonth % 7) % 2);
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
              '_'
          ),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;

      function localeMonths(m, format) {
          if (!m) {
              return isArray(this._months)
                  ? this._months
                  : this._months['standalone'];
          }
          return isArray(this._months)
              ? this._months[m.month()]
              : this._months[
                    (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                        ? 'format'
                        : 'standalone'
                ][m.month()];
      }

      function localeMonthsShort(m, format) {
          if (!m) {
              return isArray(this._monthsShort)
                  ? this._monthsShort
                  : this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort)
              ? this._monthsShort[m.month()]
              : this._monthsShort[
                    MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                ][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
          var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp(
                      '^' + this.months(mom, '').replace('.', '') + '$',
                      'i'
                  );
                  this._shortMonthsParse[i] = new RegExp(
                      '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                      'i'
                  );
              }
              if (!strict && !this._monthsParse[i]) {
                  regex =
                      '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'MMMM' &&
                  this._longMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'MMM' &&
                  this._shortMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth(mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (!isNumber(value)) {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth(value) {
          if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
          } else {
              return get(this, 'Month');
          }
      }

      function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
      }

      function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsShortRegex')) {
                  this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict
                  ? this._monthsShortStrictRegex
                  : this._monthsShortRegex;
          }
      }

      function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict
                  ? this._monthsStrictRegex
                  : this._monthsRegex;
          }
      }

      function computeMonthsParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._monthsShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] =
              input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear() {
          return isLeapYear(this.year());
      }

      function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              date = new Date(y + 400, m, d, h, M, s, ms);
              if (isFinite(date.getFullYear())) {
                  date.setFullYear(y);
              }
          } else {
              date = new Date(y, m, d, h, M, s, ms);
          }

          return date;
      }

      function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              args = Array.prototype.slice.call(arguments);
              // preserve leap years using a full 400 year cycle, then reset
              args[0] = y + 400;
              date = new Date(Date.UTC.apply(null, args));
              if (isFinite(date.getUTCFullYear())) {
                  date.setUTCFullYear(y);
              }
          } else {
              date = new Date(Date.UTC.apply(null, arguments));
          }

          return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear,
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear,
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
          input,
          week,
          config,
          token
      ) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      };

      function localeFirstDayOfWeek() {
          return this._week.dow;
      }

      function localeFirstDayOfYear() {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
              return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
      }

      // LOCALES
      function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
      }

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;

      function localeWeekdays(m, format) {
          var weekdays = isArray(this._weekdays)
              ? this._weekdays
              : this._weekdays[
                    m && m !== true && this._weekdays.isFormat.test(format)
                        ? 'format'
                        : 'standalone'
                ];
          return m === true
              ? shiftWeekdays(weekdays, this._week.dow)
              : m
              ? weekdays[m.day()]
              : weekdays;
      }

      function localeWeekdaysShort(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysShort, this._week.dow)
              : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
      }

      function localeWeekdaysMin(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysMin, this._week.dow)
              : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
          var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._shortWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._minWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
              }
              if (!this._weekdaysParse[i]) {
                  regex =
                      '^' +
                      this.weekdays(mom, '') +
                      '|^' +
                      this.weekdaysShort(mom, '') +
                      '|^' +
                      this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'dddd' &&
                  this._fullWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'ddd' &&
                  this._shortWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'dd' &&
                  this._minWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
              return this.day() || 7;
          }
      }

      function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict
                  ? this._weekdaysStrictRegex
                  : this._weekdaysRegex;
          }
      }

      function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                  this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict
                  ? this._weekdaysShortStrictRegex
                  : this._weekdaysShortRegex;
          }
      }

      function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                  this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict
                  ? this._weekdaysMinStrictRegex
                  : this._weekdaysMinRegex;
          }
      }

      function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = regexEscape(this.weekdaysMin(mom, ''));
              shortp = regexEscape(this.weekdaysShort(mom, ''));
              longp = regexEscape(this.weekdays(mom, ''));
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._weekdaysShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
          this._weekdaysMinStrictRegex = new RegExp(
              '^(' + minPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return (
              '' +
              hFormat.apply(this) +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return (
              '' +
              this.hours() +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(
                  this.hours(),
                  this.minutes(),
                  lowercase
              );
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('k', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);

      function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }

      var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,

          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,

          week: defaultLocaleWeek,

          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,

          meridiemParse: defaultLocaleMeridiemParse,
      };

      // internal storage for locale config files
      var locales = {},
          localeFamilies = {},
          globalLocale;

      function commonPrefix(arr1, arr2) {
          var i,
              minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
              if (arr1[i] !== arr2[i]) {
                  return i;
              }
          }
          return minl;
      }

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0,
              j,
              next,
              locale,
              split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (
                      next &&
                      next.length >= j &&
                      commonPrefix(split, next) >= j - 1
                  ) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return globalLocale;
      }

      function loadLocale(name) {
          var oldLocale = null,
              aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (
              locales[name] === undefined &&
              'object' !== 'undefined' &&
              module &&
              module.exports
          ) {
              try {
                  oldLocale = globalLocale._abbr;
                  aliasedRequire = commonjsRequire;
                  aliasedRequire('./locale/' + name);
                  getSetGlobalLocale(oldLocale);
              } catch (e) {
                  // mark as not found to avoid repeating expensive file require call causing high CPU
                  // when trying to find en-US, en_US, en-us for every format call
                  locales[name] = null; // null means not found
              }
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = getLocale(key);
              } else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              } else {
                  if (typeof console !== 'undefined' && console.warn) {
                      //warn user if arguments are passed but the locale could not be set
                      console.warn(
                          'Locale ' + key + ' not found. Did you forget to load it?'
                      );
                  }
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale(name, config) {
          if (config !== null) {
              var locale,
                  parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple(
                      'defineLocaleOverride',
                      'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                  );
                  parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      parentConfig = locales[config.parentLocale]._config;
                  } else {
                      locale = loadLocale(config.parentLocale);
                      if (locale != null) {
                          parentConfig = locale._config;
                      } else {
                          if (!localeFamilies[config.parentLocale]) {
                              localeFamilies[config.parentLocale] = [];
                          }
                          localeFamilies[config.parentLocale].push({
                              name: name,
                              config: config,
                          });
                          return null;
                      }
                  }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                  localeFamilies[name].forEach(function (x) {
                      defineLocale(x.name, x.config);
                  });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);

              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale,
                  tmpLocale,
                  parentConfig = baseConfig;

              if (locales[name] != null && locales[name].parentLocale != null) {
                  // Update existing child locale in-place to avoid memory-leaks
                  locales[name].set(mergeConfigs(locales[name]._config, config));
              } else {
                  // MERGE
                  tmpLocale = loadLocale(name);
                  if (tmpLocale != null) {
                      parentConfig = tmpLocale._config;
                  }
                  config = mergeConfigs(parentConfig, config);
                  if (tmpLocale == null) {
                      // updateLocale is called for creating a new locale
                      // Set abbr so it will have a name (getters return
                      // undefined otherwise).
                      config.abbr = name;
                  }
                  locale = new Locale(config);
                  locale.parentLocale = locales[name];
                  locales[name] = locale;
              }

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                      if (name === getSetGlobalLocale()) {
                          getSetGlobalLocale(name);
                      }
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function getLocale(key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function listLocales() {
          return keys(locales);
      }

      function checkOverflow(m) {
          var overflow,
              a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH] < 0 || a[MONTH] > 11
                      ? MONTH
                      : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                      ? DATE
                      : a[HOUR] < 0 ||
                        a[HOUR] > 24 ||
                        (a[HOUR] === 24 &&
                            (a[MINUTE] !== 0 ||
                                a[SECOND] !== 0 ||
                                a[MILLISECOND] !== 0))
                      ? HOUR
                      : a[MINUTE] < 0 || a[MINUTE] > 59
                      ? MINUTE
                      : a[SECOND] < 0 || a[SECOND] > 59
                      ? SECOND
                      : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                      ? MILLISECOND
                      : -1;

              if (
                  getParsingFlags(m)._overflowDayOfYear &&
                  (overflow < YEAR || overflow > DATE)
              ) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [
              ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
              ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
              ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
              ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
              ['YYYY-DDD', /\d{4}-\d{3}/],
              ['YYYY-MM', /\d{4}-\d\d/, false],
              ['YYYYYYMMDD', /[+-]\d{10}/],
              ['YYYYMMDD', /\d{8}/],
              ['GGGG[W]WWE', /\d{4}W\d{3}/],
              ['GGGG[W]WW', /\d{4}W\d{2}/, false],
              ['YYYYDDD', /\d{7}/],
              ['YYYYMM', /\d{6}/, false],
              ['YYYY', /\d{4}/, false],
          ],
          // iso time formats and regexes
          isoTimes = [
              ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
              ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
              ['HH:mm:ss', /\d\d:\d\d:\d\d/],
              ['HH:mm', /\d\d:\d\d/],
              ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
              ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
              ['HHmmss', /\d\d\d\d\d\d/],
              ['HHmm', /\d\d\d\d/],
              ['HH', /\d\d/],
          ],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
              UT: 0,
              GMT: 0,
              EDT: -4 * 60,
              EST: -5 * 60,
              CDT: -5 * 60,
              CST: -6 * 60,
              MDT: -6 * 60,
              MST: -7 * 60,
              PDT: -7 * 60,
              PST: -8 * 60,
          };

      // date from iso format
      function configFromISO(config) {
          var i,
              l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      function extractFromRFC2822Strings(
          yearStr,
          monthStr,
          dayStr,
          hourStr,
          minuteStr,
          secondStr
      ) {
          var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10),
          ];

          if (secondStr) {
              result.push(parseInt(secondStr, 10));
          }

          return result;
      }

      function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
              return 2000 + year;
          } else if (year <= 999) {
              return 1900 + year;
          }
          return year;
      }

      function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s
              .replace(/\([^)]*\)|[\n\t]/g, ' ')
              .replace(/(\s\s+)/g, ' ')
              .replace(/^\s\s*/, '')
              .replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
              var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                  weekdayActual = new Date(
                      parsedInput[0],
                      parsedInput[1],
                      parsedInput[2]
                  ).getDay();
              if (weekdayProvided !== weekdayActual) {
                  getParsingFlags(config).weekdayMismatch = true;
                  config._isValid = false;
                  return false;
              }
          }
          return true;
      }

      function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
              return obsOffsets[obsOffset];
          } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
          } else {
              var hm = parseInt(numOffset, 10),
                  m = hm % 100,
                  h = (hm - m) / 100;
              return h * 60 + m;
          }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
              parsedArray;
          if (match) {
              parsedArray = extractFromRFC2822Strings(
                  match[4],
                  match[3],
                  match[2],
                  match[5],
                  match[6],
                  match[7]
              );
              if (!checkWeekday(match[1], parsedArray, config)) {
                  return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
          } else {
              config._isValid = false;
          }
      }

      // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          configFromRFC2822(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          if (config._strict) {
              config._isValid = false;
          } else {
              // Final attempt, use Input Fallback
              hooks.createFromInputFallback(config);
          }
      }

      hooks.createFromInputFallback = deprecate(
          'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
              'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
              'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
              return [
                  nowValue.getUTCFullYear(),
                  nowValue.getUTCMonth(),
                  nowValue.getUTCDate(),
              ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray(config) {
          var i,
              date,
              input = [],
              currentDate,
              expectedWeekday,
              yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (
                  config._dayOfYear > daysInYear(yearToUse) ||
                  config._dayOfYear === 0
              ) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] =
                  config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (
              config._a[HOUR] === 24 &&
              config._a[MINUTE] === 0 &&
              config._a[SECOND] === 0 &&
              config._a[MILLISECOND] === 0
          ) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(
              null,
              input
          );
          expectedWeekday = config._useUTC
              ? config._d.getUTCDay()
              : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (
              config._w &&
              typeof config._w.d !== 'undefined' &&
              config._w.d !== expectedWeekday
          ) {
              getParsingFlags(config).weekdayMismatch = true;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(
                  w.GG,
                  config._a[YEAR],
                  weekOfYear(createLocal(), 1, 4).year
              );
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from beginning of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to beginning of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
          }
          if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0,
              era;

          tokens =
              expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                  [])[0];
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(
                      string.indexOf(parsedInput) + parsedInput.length
                  );
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  } else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              } else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver =
              stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (
              config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0
          ) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(
              config._locale,
              config._a[HOUR],
              config._meridiem
          );

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
              config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }

          configFromArray(config);
          checkOverflow(config);
      }

      function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,
              scoreToBeat,
              i,
              currentScore,
              validFormatFound,
              bestFormatIsValid = false;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              validFormatFound = false;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (isValid(tempConfig)) {
                  validFormatFound = true;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (!bestFormatIsValid) {
                  if (
                      scoreToBeat == null ||
                      currentScore < scoreToBeat ||
                      validFormatFound
                  ) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                      if (validFormatFound) {
                          bestFormatIsValid = true;
                      }
                  }
              } else {
                  if (currentScore < scoreToBeat) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                  }
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i),
              dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map(
              [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
              function (obj) {
                  return obj && parseInt(obj, 10);
              }
          );

          configFromArray(config);
      }

      function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig(config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return createInvalid({ nullInput: true });
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
              config._d = input;
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          } else {
              configFromInput(config);
          }

          if (!isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
              config._d = new Date(hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (isObject(input)) {
              configFromObject(config);
          } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
          } else {
              hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};

          if (format === true || format === false) {
              strict = format;
              format = undefined;
          }

          if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
          }

          if (
              (isObject(input) && isObjectEmpty(input)) ||
              (isArray(input) && input.length === 0)
          ) {
              input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
              'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other < this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          ),
          prototypeMax = deprecate(
              'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other > this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +new Date();
      };

      var ordering = [
          'year',
          'quarter',
          'month',
          'week',
          'day',
          'hour',
          'minute',
          'second',
          'millisecond',
      ];

      function isDurationValid(m) {
          var key,
              unitHasDecimal = false,
              i;
          for (key in m) {
              if (
                  hasOwnProp(m, key) &&
                  !(
                      indexOf.call(ordering, key) !== -1 &&
                      (m[key] == null || !isNaN(m[key]))
                  )
              ) {
                  return false;
              }
          }

          for (i = 0; i < ordering.length; ++i) {
              if (m[ordering[i]]) {
                  if (unitHasDecimal) {
                      return false; // only allow non-integers for smallest unit
                  }
                  if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                      unitHasDecimal = true;
                  }
              }
          }

          return true;
      }

      function isValid$1() {
          return this._isValid;
      }

      function createInvalid$1() {
          return createDuration(NaN);
      }

      function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds =
              +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;

          this._data = {};

          this._locale = getLocale();

          this._bubble();
      }

      function isDuration(obj) {
          return obj instanceof Duration;
      }

      function absRound(number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if (
                  (dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
              ) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      // FORMATTING

      function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset(),
                  sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return (
                  sign +
                  zeroFill(~~(offset / 60), 2) +
                  separator +
                  zeroFill(~~offset % 60, 2)
              );
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
              chunk,
              parts,
              minutes;

          if (matches === null) {
              return null;
          }

          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);

          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff =
                  (isMoment(input) || isDate(input)
                      ? input.valueOf()
                      : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
          } else {
              return createLocal(input).local();
          }
      }

      function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
                  if (input === null) {
                      return this;
                  }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      addSubtract(
                          this,
                          createDuration(input - offset, 'm'),
                          1,
                          false
                      );
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone(input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset() {
          if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                  this.utcOffset(tZone);
              } else {
                  this.utcOffset(0, true);
              }
          }
          return this;
      }

      function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime() {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {},
              other;

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted =
                  this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal() {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration(input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms: input._milliseconds,
                  d: input._days,
                  M: input._months,
              };
          } else if (isNumber(input) || !isNaN(+input)) {
              duration = {};
              if (key) {
                  duration[key] = +input;
              } else {
                  duration.milliseconds = +input;
              }
          } else if ((match = aspNetRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: 0,
                  d: toInt(match[DATE]) * sign,
                  h: toInt(match[HOUR]) * sign,
                  m: toInt(match[MINUTE]) * sign,
                  s: toInt(match[SECOND]) * sign,
                  ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
              };
          } else if ((match = isoRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: parseIso(match[2], sign),
                  M: parseIso(match[3], sign),
                  w: parseIso(match[4], sign),
                  d: parseIso(match[5], sign),
                  h: parseIso(match[6], sign),
                  m: parseIso(match[7], sign),
                  s: parseIso(match[8], sign),
              };
          } else if (duration == null) {
              // checks for null or undefined
              duration = {};
          } else if (
              typeof duration === 'object' &&
              ('from' in duration || 'to' in duration)
          ) {
              diffRes = momentsDifference(
                  createLocal(duration.from),
                  createLocal(duration.to)
              );

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
              ret._isValid = input._isValid;
          }

          return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {};

          res.months =
              other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +base.clone().add(res.months, 'M');

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return { milliseconds: 0, months: 0 };
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(
                      name,
                      'moment().' +
                          name +
                          '(period, number) is deprecated. Please use moment().' +
                          name +
                          '(number, period). ' +
                          'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                  );
                  tmp = val;
                  val = period;
                  period = tmp;
              }

              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
          };
      }

      function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (months) {
              setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
              set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
              hooks.updateOffset(mom, days || months);
          }
      }

      var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');

      function isString(input) {
          return typeof input === 'string' || input instanceof String;
      }

      // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
      function isMomentInput(input) {
          return (
              isMoment(input) ||
              isDate(input) ||
              isString(input) ||
              isNumber(input) ||
              isNumberOrStringArray(input) ||
              isMomentInputObject(input) ||
              input === null ||
              input === undefined
          );
      }

      function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'years',
                  'year',
                  'y',
                  'months',
                  'month',
                  'M',
                  'days',
                  'day',
                  'd',
                  'dates',
                  'date',
                  'D',
                  'hours',
                  'hour',
                  'h',
                  'minutes',
                  'minute',
                  'm',
                  'seconds',
                  'second',
                  's',
                  'milliseconds',
                  'millisecond',
                  'ms',
              ],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function isNumberOrStringArray(input) {
          var arrayTest = isArray(input),
              dataTypeTest = false;
          if (arrayTest) {
              dataTypeTest =
                  input.filter(function (item) {
                      return !isNumber(item) && isString(input);
                  }).length === 0;
          }
          return arrayTest && dataTypeTest;
      }

      function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'sameDay',
                  'nextDay',
                  'lastDay',
                  'nextWeek',
                  'lastWeek',
                  'sameElse',
              ],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6
              ? 'sameElse'
              : diff < -1
              ? 'lastWeek'
              : diff < 0
              ? 'lastDay'
              : diff < 1
              ? 'sameDay'
              : diff < 2
              ? 'nextDay'
              : diff < 7
              ? 'nextWeek'
              : 'sameElse';
      }

      function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
              if (!arguments[0]) {
                  time = undefined;
                  formats = undefined;
              } else if (isMomentInput(arguments[0])) {
                  time = arguments[0];
                  formats = undefined;
              } else if (isCalendarSpec(arguments[0])) {
                  formats = arguments[0];
                  time = undefined;
              }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse',
              output =
                  formats &&
                  (isFunction(formats[format])
                      ? formats[format].call(this, now)
                      : formats[format]);

          return this.format(
              output || this.localeData().calendar(format, this, createLocal(now))
          );
      }

      function clone() {
          return new Moment(this);
      }

      function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
              return false;
          }
          inclusivity = inclusivity || '()';
          return (
              (inclusivity[0] === '('
                  ? this.isAfter(localFrom, units)
                  : !this.isBefore(localFrom, units)) &&
              (inclusivity[1] === ')'
                  ? this.isBefore(localTo, units)
                  : !this.isAfter(localTo, units))
          );
      }

      function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return (
                  this.clone().startOf(units).valueOf() <= inputMs &&
                  inputMs <= this.clone().endOf(units).valueOf()
              );
          }
      }

      function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
      }

      function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
      }

      function diff(input, units, asFloat) {
          var that, zoneDelta, output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          switch (units) {
              case 'year':
                  output = monthDiff(this, that) / 12;
                  break;
              case 'month':
                  output = monthDiff(this, that);
                  break;
              case 'quarter':
                  output = monthDiff(this, that) / 3;
                  break;
              case 'second':
                  output = (this - that) / 1e3;
                  break; // 1000
              case 'minute':
                  output = (this - that) / 6e4;
                  break; // 1000 * 60
              case 'hour':
                  output = (this - that) / 36e5;
                  break; // 1000 * 60 * 60
              case 'day':
                  output = (this - that - zoneDelta) / 864e5;
                  break; // 1000 * 60 * 60 * 24, negate dst
              case 'week':
                  output = (this - that - zoneDelta) / 6048e5;
                  break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default:
                  output = this - that;
          }

          return asFloat ? output : absFloor(output);
      }

      function monthDiff(a, b) {
          if (a.date() < b.date()) {
              // end-of-month calculations work correct when the start month has more
              // days than the end month.
              return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2,
              adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
          if (!this.isValid()) {
              return null;
          }
          var utc = keepOffset !== true,
              m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(
                  m,
                  utc
                      ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                      : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
              );
          }
          if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                  return this.toDate().toISOString();
              } else {
                  return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                      .toISOString()
                      .replace('Z', formatMoment(m, 'Z'));
              }
          }
          return formatMoment(
              m,
              utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
          );
      }

      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */
      function inspect() {
          if (!this.isValid()) {
              return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
              zone = '',
              prefix,
              year,
              datetime,
              suffix;
          if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
              zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';

          return this.format(prefix + year + datetime + suffix);
      }

      function format(inputString) {
          if (!inputString) {
              inputString = this.isUtc()
                  ? hooks.defaultFormatUtc
                  : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ to: this, from: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
      }

      function to(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ from: this, to: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale(key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData() {
          return this._locale;
      }

      var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

      // actual modulo - handles negative numbers (for dates before 1970):
      function mod$1(dividend, divisor) {
          return ((dividend % divisor) + divisor) % divisor;
      }

      function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return new Date(y, m, d).valueOf();
          }
      }

      function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return Date.UTC(y, m, d);
          }
      }

      function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year(), 0, 1);
                  break;
              case 'quarter':
                  time = startOfDate(
                      this.year(),
                      this.month() - (this.month() % 3),
                      1
                  );
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month(), 1);
                  break;
              case 'week':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - this.weekday()
                  );
                  break;
              case 'isoWeek':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - (this.isoWeekday() - 1)
                  );
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date());
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time -= mod$1(
                      time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                      MS_PER_HOUR
                  );
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_MINUTE);
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_SECOND);
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year() + 1, 0, 1) - 1;
                  break;
              case 'quarter':
                  time =
                      startOfDate(
                          this.year(),
                          this.month() - (this.month() % 3) + 3,
                          1
                      ) - 1;
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                  break;
              case 'week':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - this.weekday() + 7
                      ) - 1;
                  break;
              case 'isoWeek':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - (this.isoWeekday() - 1) + 7
                      ) - 1;
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time +=
                      MS_PER_HOUR -
                      mod$1(
                          time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                          MS_PER_HOUR
                      ) -
                      1;
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
      }

      function unix() {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate() {
          return new Date(this.valueOf());
      }

      function toArray() {
          var m = this;
          return [
              m.year(),
              m.month(),
              m.date(),
              m.hour(),
              m.minute(),
              m.second(),
              m.millisecond(),
          ];
      }

      function toObject() {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds(),
          };
      }

      function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2() {
          return isValid(this);
      }

      function parsingFlags() {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt() {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict,
          };
      }

      addFormatToken('N', 0, 0, 'eraAbbr');
      addFormatToken('NN', 0, 0, 'eraAbbr');
      addFormatToken('NNN', 0, 0, 'eraAbbr');
      addFormatToken('NNNN', 0, 0, 'eraName');
      addFormatToken('NNNNN', 0, 0, 'eraNarrow');

      addFormatToken('y', ['y', 1], 'yo', 'eraYear');
      addFormatToken('y', ['yy', 2], 0, 'eraYear');
      addFormatToken('y', ['yyy', 3], 0, 'eraYear');
      addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

      addRegexToken('N', matchEraAbbr);
      addRegexToken('NN', matchEraAbbr);
      addRegexToken('NNN', matchEraAbbr);
      addRegexToken('NNNN', matchEraName);
      addRegexToken('NNNNN', matchEraNarrow);

      addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
          input,
          array,
          config,
          token
      ) {
          var era = config._locale.erasParse(input, token, config._strict);
          if (era) {
              getParsingFlags(config).era = era;
          } else {
              getParsingFlags(config).invalidEra = input;
          }
      });

      addRegexToken('y', matchUnsigned);
      addRegexToken('yy', matchUnsigned);
      addRegexToken('yyy', matchUnsigned);
      addRegexToken('yyyy', matchUnsigned);
      addRegexToken('yo', matchEraYearOrdinal);

      addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
      addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
              match = input.match(config._locale._eraYearOrdinalRegex);
          }

          if (config._locale.eraYearOrdinalParse) {
              array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
              array[YEAR] = parseInt(input, 10);
          }
      });

      function localeEras(m, format) {
          var i,
              l,
              date,
              eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
              switch (typeof eras[i].since) {
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].since).startOf('day');
                      eras[i].since = date.valueOf();
                      break;
              }

              switch (typeof eras[i].until) {
                  case 'undefined':
                      eras[i].until = +Infinity;
                      break;
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].until).startOf('day').valueOf();
                      eras[i].until = date.valueOf();
                      break;
              }
          }
          return eras;
      }

      function localeErasParse(eraName, format, strict) {
          var i,
              l,
              eras = this.eras(),
              name,
              abbr,
              narrow;
          eraName = eraName.toUpperCase();

          for (i = 0, l = eras.length; i < l; ++i) {
              name = eras[i].name.toUpperCase();
              abbr = eras[i].abbr.toUpperCase();
              narrow = eras[i].narrow.toUpperCase();

              if (strict) {
                  switch (format) {
                      case 'N':
                      case 'NN':
                      case 'NNN':
                          if (abbr === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNN':
                          if (name === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNNN':
                          if (narrow === eraName) {
                              return eras[i];
                          }
                          break;
                  }
              } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                  return eras[i];
              }
          }
      }

      function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
              return hooks(era.since).year();
          } else {
              return hooks(era.since).year() + (year - era.offset) * dir;
          }
      }

      function getEraName() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].name;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].name;
              }
          }

          return '';
      }

      function getEraNarrow() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].narrow;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].narrow;
              }
          }

          return '';
      }

      function getEraAbbr() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].abbr;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].abbr;
              }
          }

          return '';
      }

      function getEraYear() {
          var i,
              l,
              dir,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              dir = eras[i].since <= eras[i].until ? +1 : -1;

              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (
                  (eras[i].since <= val && val <= eras[i].until) ||
                  (eras[i].until <= val && val <= eras[i].since)
              ) {
                  return (
                      (this.year() - hooks(eras[i].since).year()) * dir +
                      eras[i].offset
                  );
              }
          }

          return this.year();
      }

      function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
      }

      function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }

      function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }

      function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
      }

      function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
      }

      function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
      }

      function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
      }

      function computeErasParse() {
          var abbrPieces = [],
              namePieces = [],
              narrowPieces = [],
              mixedPieces = [],
              i,
              l,
              eras = this.eras();

          for (i = 0, l = eras.length; i < l; ++i) {
              namePieces.push(regexEscape(eras[i].name));
              abbrPieces.push(regexEscape(eras[i].abbr));
              narrowPieces.push(regexEscape(eras[i].narrow));

              mixedPieces.push(regexEscape(eras[i].name));
              mixedPieces.push(regexEscape(eras[i].abbr));
              mixedPieces.push(regexEscape(eras[i].narrow));
          }

          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp(
              '^(' + narrowPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);

      // PARSING

      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
          input,
          week,
          config,
          token
      ) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.week(),
              this.weekday(),
              this.localeData()._week.dow,
              this.localeData()._week.doy
          );
      }

      function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.isoWeek(),
              this.isoWeekday(),
              1,
              4
          );
      }

      function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
      }

      function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
      }

      function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter(input) {
          return input == null
              ? Math.ceil((this.month() + 1) / 3)
              : this.month((input - 1) * 3 + (this.month() % 3));
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIORITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict
              ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
              : locale._dayOfMonthOrdinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear(input) {
          var dayOfYear =
              Math.round(
                  (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
              ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });

      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);

      var token, getSetMillisecond;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }

      getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;

      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
              return 'Moment<' + this.format() + '>';
          };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
          'dates accessor is deprecated. Use date instead.',
          getSetDayOfMonth
      );
      proto.months = deprecate(
          'months accessor is deprecated. Use month instead',
          getSetMonth
      );
      proto.years = deprecate(
          'years accessor is deprecated. Use year instead',
          getSetYear
      );
      proto.zone = deprecate(
          'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
          getSetZone
      );
      proto.isDSTShifted = deprecate(
          'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
          isDaylightSavingTimeShifted
      );

      function createUnix(input) {
          return createLocal(input * 1000);
      }

      function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat(string) {
          return string;
      }

      var proto$1 = Locale.prototype;

      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;

      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;

      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;

      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;

      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1(format, index, field, setter) {
          var locale = getLocale(),
              utc = createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return get$1(format, index, field, 'month');
          }

          var i,
              out = [];
          for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0,
              i,
              out = [];

          if (index != null) {
              return get$1(format, (index + shift) % 7, field, 'day');
          }

          for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
          eras: [
              {
                  since: '0001-01-01',
                  until: +Infinity,
                  offset: 1,
                  name: 'Anno Domini',
                  narrow: 'AD',
                  abbr: 'AD',
              },
              {
                  since: '0000-12-31',
                  until: -Infinity,
                  offset: 1,
                  name: 'Before Christ',
                  narrow: 'BC',
                  abbr: 'BC',
              },
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      toInt((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
      });

      // Side effect imports

      hooks.lang = deprecate(
          'moment.lang is deprecated. Use moment.locale instead.',
          getSetGlobalLocale
      );
      hooks.langData = deprecate(
          'moment.langData is deprecated. Use moment.localeData instead.',
          getLocale
      );

      var mathAbs = Math.abs;

      function abs() {
          var data = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);

          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);

          return this;
      }

      function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
      }

      function absCeil(number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble() {
          var milliseconds = this._milliseconds,
              days = this._days,
              months = this._months,
              data = this._data,
              seconds,
              minutes,
              hours,
              years,
              monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (
              !(
                  (milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0)
              )
          ) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;

          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;

          hours = absFloor(minutes / 60);
          data.hours = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days = days;
          data.months = months;
          data.years = years;

          return this;
      }

      function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return (days * 4800) / 146097;
      }

      function monthsToDays(months) {
          // the reverse of daysToMonths
          return (months * 146097) / 4800;
      }

      function as(units) {
          if (!this.isValid()) {
              return NaN;
          }
          var days,
              months,
              milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'quarter' || units === 'year') {
              days = this._days + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              switch (units) {
                  case 'month':
                      return months;
                  case 'quarter':
                      return months / 3;
                  case 'year':
                      return months / 12;
              }
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week':
                      return days / 7 + milliseconds / 6048e5;
                  case 'day':
                      return days + milliseconds / 864e5;
                  case 'hour':
                      return days * 24 + milliseconds / 36e5;
                  case 'minute':
                      return days * 1440 + milliseconds / 6e4;
                  case 'second':
                      return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond':
                      return Math.floor(days * 864e5) + milliseconds;
                  default:
                      throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function valueOf$1() {
          if (!this.isValid()) {
              return NaN;
          }
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs(alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y');

      function clone$1() {
          return createDuration(this);
      }

      function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
          return function () {
              return this.isValid() ? this._data[name] : NaN;
          };
      }

      var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');

      function weeks() {
          return absFloor(this.days() / 7);
      }

      var round = Math.round,
          thresholds = {
              ss: 44, // a few seconds to seconds
              s: 45, // seconds to minute
              m: 45, // minutes to hour
              h: 22, // hours to day
              d: 26, // days to month/week
              w: null, // weeks to month
              M: 11, // months to year
          };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
              seconds = round(duration.as('s')),
              minutes = round(duration.as('m')),
              hours = round(duration.as('h')),
              days = round(duration.as('d')),
              months = round(duration.as('M')),
              weeks = round(duration.as('w')),
              years = round(duration.as('y')),
              a =
                  (seconds <= thresholds.ss && ['s', seconds]) ||
                  (seconds < thresholds.s && ['ss', seconds]) ||
                  (minutes <= 1 && ['m']) ||
                  (minutes < thresholds.m && ['mm', minutes]) ||
                  (hours <= 1 && ['h']) ||
                  (hours < thresholds.h && ['hh', hours]) ||
                  (days <= 1 && ['d']) ||
                  (days < thresholds.d && ['dd', days]);

          if (thresholds.w != null) {
              a =
                  a ||
                  (weeks <= 1 && ['w']) ||
                  (weeks < thresholds.w && ['ww', weeks]);
          }
          a = a ||
              (months <= 1 && ['M']) ||
              (months < thresholds.M && ['MM', months]) ||
              (years <= 1 && ['y']) || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
              return round;
          }
          if (typeof roundingFunction === 'function') {
              round = roundingFunction;
              return true;
          }
          return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
              thresholds.ss = limit - 1;
          }
          return true;
      }

      function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var withSuffix = false,
              th = thresholds,
              locale,
              output;

          if (typeof argWithSuffix === 'object') {
              argThresholds = argWithSuffix;
              argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
              withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === 'object') {
              th = Object.assign({}, thresholds, argThresholds);
              if (argThresholds.s != null && argThresholds.ss == null) {
                  th.ss = argThresholds.s - 1;
              }
          }

          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
          return (x > 0) - (x < 0) || +x;
      }

      function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000,
              days = abs$1(this._days),
              months = abs$1(this._months),
              minutes,
              hours,
              years,
              s,
              total = this.asSeconds(),
              totalSign,
              ymSign,
              daysSign,
              hmsSign;

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

          return (
              totalSign +
              'P' +
              (years ? ymSign + years + 'Y' : '') +
              (months ? ymSign + months + 'M' : '') +
              (days ? daysSign + days + 'D' : '') +
              (hours || minutes || seconds ? 'T' : '') +
              (hours ? hmsSign + hours + 'H' : '') +
              (minutes ? hmsSign + minutes + 'M' : '') +
              (seconds ? hmsSign + s + 'S' : '')
          );
      }

      var proto$2 = Duration.prototype;

      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;

      proto$2.toIsoString = deprecate(
          'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
          toISOString$1
      );
      proto$2.lang = lang;

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      //! moment.js

      hooks.version = '2.29.1';

      setHookCallback(createLocal);

      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD', // <input type="date" />
          TIME: 'HH:mm', // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW', // <input type="week" />
          MONTH: 'YYYY-MM', // <input type="month" />
      };

      return hooks;

  })));
  }(moment));

  (function (module) {

  if (typeof commonjsRequire === 'function') {
    var moment$1 = moment.exports;
  }

  moment$1.fn.isHoliday = function () {
    var locale = this.localeData();

    if (locale._holidays) {
      if (locale._holidays.indexOf(this.format(locale._holidayFormat)) >= 0)
        return true;
    }

    if (locale.holiday) {
      if (locale.holiday(this)) {
        return true;
      }
      return false;
    }

    return false;
  };

  moment$1.fn.isBusinessDay = function () {
    var locale = this.localeData();
    var defaultWorkingWeekdays = [1, 2, 3, 4, 5];
    var workingWeekdays = locale._workingWeekdays || defaultWorkingWeekdays;

    if (this.isHoliday()) return false;
    if (workingWeekdays.indexOf(this.day()) >= 0) return true;

    return false;
  };

  moment$1.fn.businessDaysIntoMonth = function () {
    if (!this.isValid()) {
      return NaN;
    }
    var businessDay = this.isBusinessDay() ? this : this.prevBusinessDay();
    var monthBusinessDays = businessDay.monthBusinessDays();
    var businessDaysIntoMonth;
    monthBusinessDays.map(function (day, index) {
      if (day.format('M/DD/YY') === businessDay.format('M/DD/YY')) {
        businessDaysIntoMonth = index + 1;
      }
    });
    return businessDaysIntoMonth;
  };

  moment$1.fn.businessDiff = function (param, relative) {
    var d1 = this.clone();
    var d2 = param.clone();
    var positive = d1 >= d2;
    var start = d1 < d2 ? d1 : d2;
    var end = d2 > d1 ? d2 : d1;

    var daysBetween = 0;

    if (start.format('DD/MM/YYYY') === end.format('DD/MM/YYYY')) {
      return daysBetween;
    }

    while (start < end) {
      if (start.isBusinessDay()) {
        daysBetween++;
      }
      start.add(1, 'd');
    }

    if (relative) {
      return positive ? daysBetween : -daysBetween;
    }

    return daysBetween;
  };

  moment$1.fn.businessAdd = function (number, period) {
    var day = this.clone();
    if (!day.isValid()) {
      return day;
    }

    if (number < 0) {
      number = Math.round(-1 * number) * -1;
    } else {
      number = Math.round(number);
    }

    var signal = number < 0 ? -1 : 1;
    period = typeof period !== 'undefined' ? period : 'days';

    var remaining = Math.abs(number);
    while (remaining > 0) {
      day.add(signal, period);

      if (day.isBusinessDay()) {
        remaining--;
      }
    }

    return day;
  };

  moment$1.fn.businessSubtract = function (number, period) {
    return this.businessAdd(-number, period);
  };

  moment$1.fn.nextBusinessDay = function () {
    var locale = this.localeData();

    var loop = 1;
    var defaultNextBusinessDayLimit = 7;
    var limit = locale._nextBusinessDayLimit || defaultNextBusinessDayLimit;
    while (loop < limit) {
      if (this.add(1, 'd').isBusinessDay()) {
        break;
      }
      loop++;
    }
    return this;
  };

  moment$1.fn.prevBusinessDay = function () {
    var locale = this.localeData();

    var loop = 1;
    var defaultPrevBusinessDayLimit = 7;
    var limit = locale._prevBusinessDayLimit || defaultPrevBusinessDayLimit;
    while (loop < limit) {
      if (this.subtract(1, 'd').isBusinessDay()) {
        break;
      }
      loop++;
    }
    return this;
  };

  moment$1.fn.monthBusinessDays = function (partialEndDate) {
    if (!this.isValid()) {
      return [];
    }
    var me = this.clone();
    var day = me.clone().startOf('month');
    var end = partialEndDate ? partialEndDate : me.clone().endOf('month');
    var daysArr = [];
    var done = false;
    while (!done) {
      if (day.isBusinessDay()) {
        daysArr.push(day.clone());
      }
      if (end.diff(day.add(1, 'd')) < 0) {
        done = true;
      }
    }
    return daysArr;
  };

  moment$1.fn.monthNaturalDays = function (fromToday) {
    if (!this.isValid()) {
      return [];
    }
    var me = this.clone();
    var day = fromToday ? me.clone() : me.clone().startOf('month');
    var end = me.clone().endOf('month');
    var daysArr = [];
    var done = false;
    while (!done) {
      daysArr.push(day.clone());
      if (end.diff(day.add(1, 'd')) < 0) {
        done = true;
      }
    }
    return daysArr;
  };

  moment$1.fn.monthBusinessWeeks = function (fromToday) {
    fromToday = fromToday || false;
    var me = this.clone();
    var startDate = fromToday ? me.clone() : me.clone().startOf('month');
    return getBusinessWeeks(this, fromToday, null, startDate);
  };

  moment$1.fn.businessWeeksBetween = function (endDate) {
    var me = this.clone();
    var startDate = me.clone();
    return getBusinessWeeks(this, false, endDate, startDate);
  };

  var getBusinessWeeks = function (self, fromToday, endDate, startDate) {
    if (!self.isValid()) {
      return [];
    }
    var me = self.clone();
    var day = startDate;
    var end = endDate ? moment$1(endDate).clone() : me.clone().endOf('month');
    var weeksArr = [];
    var daysArr = [];
    var done = false;

    while (!done) {
      if (day.day() >= 1 && day.day() < 6) {
        daysArr.push(day.clone());
      }
      if (day.day() === 5) {
        weeksArr.push(daysArr);
        daysArr = [];
      }
      if (end.diff(day.add(1, 'd')) < 0) {
        if (daysArr.length < 5) {
          weeksArr.push(daysArr);
        }
        done = true;
      }
    }
    return weeksArr;
  };

  moment$1.fn.monthNaturalWeeks = function (fromToday) {
    if (!this.isValid()) {
      return [];
    }
    var me = this.clone();
    var day = fromToday ? me.clone() : me.clone().startOf('month');
    var end = me.clone().endOf('month');
    var weeksArr = [];
    var daysArr = [];
    var done = false;

    while (!done) {
      daysArr.push(day.clone());
      if (day.day() === 6) {
        weeksArr.push(daysArr);
        daysArr = [];
      }
      if (end.diff(day.add(1, 'd')) < 0) {
        if (daysArr.length < 7) {
          weeksArr.push(daysArr);
        }
        done = true;
      }
    }
    return weeksArr;
  };

  if (module.exports) {
    module.exports = moment$1;
  }
  }(momentBusinessDays));

  // Development-related helper functions
  /**
   * NotePlan API properties which should not be traversed when stringifying an object
   */
  const PARAM_BLACKLIST = ['note', 'referencedBlocks', 'availableThemes', 'currentTheme', 'linkedNoteTitles', 'linkedItems']; // fields not to be traversed (e.g. circular references)

  const dt = () => {
    const d = new Date();
    const pad = value => {
      return value < 10 ? `0${value}` : value.toString();
    };
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${d.toLocaleTimeString('en-GB')}`;
  };

  /**
   * JSON.stringify() with support for Prototype properties
   * @author @dwertheimer
   *
   * @param {object} obj
   * @param {string | number} space - A String or Number of spaces that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
   * @returns {string} stringified object
   * @example console.log(JSP(obj, '\t')) // prints the full object with newlines and tabs for indentation
   */
  function JSP(obj, space = 2) {
    if (typeof obj !== 'object' || obj instanceof Date) {
      return String(obj);
    } else {
      if (Array.isArray(obj)) {
        const arrInfo = [];
        let isValues = false;
        obj.forEach((item, i) => {
          if (typeof item === 'object') {
            arrInfo.push(`[${i}] = ${JSP(item, space)}`);
          } else {
            isValues = true;
            arrInfo.push(`${item}`);
          }
        });
        return `${isValues ? '[' : ''}${arrInfo.join(isValues ? ', ' : ',\n')}${isValues ? ']' : ''}`;
      }
      const propNames = getFilteredProps(obj);
      const fullObj = propNames.reduce((acc, propName) => {
        if (!/^__/.test(propName)) {
          if (Array.isArray(obj[propName])) {
            try {
              if (PARAM_BLACKLIST.indexOf(propName) === -1) {
                acc[propName] = obj[propName].map(x => {
                  if (typeof x === 'object' && !(x instanceof Date)) {
                    return JSP(x, '');
                  } else {
                    return x;
                  }
                });
              } else {
                acc[propName] = obj[propName]; //do not traverse any further
              }
            } catch (error) {
              logDebug$1('helpers/dev', `Caught error in JSP for propname=${propName} : ${error} typeof obj[propName]=${typeof obj[propName]} isArray=${String(Array.isArray(obj[propName]))} len=${obj[propName]?.length} \n VALUE: ${JSON.stringify(obj[propName])}`);
            }
          } else {
            acc[propName] = obj[propName];
          }
        }
        return acc;
      }, {});
      // return cleanStringifiedResults(JSON.stringify(fullObj, null, space ?? null))
      return typeof fullObj === 'object' && !(fullObj instanceof Date) ? JSON.stringify(fullObj, null, space ?? null) : 'date';
    }
  }

  /**
   * Console.logs all property names/values of an object to console with text preamble
   * @author @dwertheimer
   *
   * @param {object} obj - array or object
   * @param {string} preamble - (optional) text to prepend to the output
   * @param {string | number} space - A String or Number of spaces that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
   * @example clo(obj, 'myObj:')
   */
  function clo(obj, preamble = '', space = 2) {
    if (!obj) {
      logDebug$1(preamble, `null`);
      return;
    }
    if (typeof obj !== 'object') {
      logDebug$1(preamble, `${obj}`);
    } else {
      logDebug$1(preamble, JSP(obj, space));
    }
  }

  /**
   * Create a list of the properties of an object, including inherited properties (which are not typically visible in JSON.stringify)
   * Often includes a bunch of properties that are not useful for the user, e.g. constructor, __proto__
   * See getFilteredProps for a cleaner version
   * @author @dwertheimer (via StackOverflow)
   *
   * @param {object} inObj
   * @returns {Array<string>}
   * @reference https://stackoverflow.com/questions/59228638/console-log-an-object-does-not-log-the-method-added-via-prototype-in-node-js-c
   */
  function getAllPropertyNames(inObj) {
    let obj = inObj;
    const props = [];
    do {
      Object.getOwnPropertyNames(obj).forEach(function (prop) {
        if (props.indexOf(prop) === -1) {
          props.push(prop);
        }
      });
    } while (obj = Object.getPrototypeOf(obj));
    return props;
  }

  /**
   * Get the properties of interest (i.e. excluding all the ones added automatically)
   * @author @dwertheimer
   * @param {object} object
   * @returns {Array<string>} - an array of the interesting properties of the object
   */
  const getFilteredProps = object => {
    const ignore = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'propertyIsEnumerable', 'isPrototypeOf'];
    if (typeof object !== 'object' || Array.isArray(object)) {
      // console.log(`getFilteredProps improper type: ${typeof object}`)
      return [];
    }
    return getAllPropertyNames(object).filter(prop => !/(^__)|(constructor)/.test(prop) && !ignore.includes(prop));
  };

  /**
   * Converts any to message string
   * @author @codedungeon
   * @param {any} message
   * @returns {string}
   */
  const _message = message => {
    let logMessage = '';
    switch (typeof message) {
      case 'string':
        logMessage = message;
        break;
      case 'object':
        if (Array.isArray(message)) {
          logMessage = message.toString();
        } else {
          logMessage = message instanceof Date ? message.toString() : JSON.stringify(message);
        }
        break;
      default:
        logMessage = message.toString();
        break;
    }
    return logMessage;
  };
  const LOG_LEVELS = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'none'];
  const LOG_LEVEL_STRINGS = ['| DEBUG |', '| INFO  |', 'ð¥º WARNð¥º', 'âï¸ERRORâï¸', 'none'];

  /**
   * Formats log output to include timestamp pluginId, pluginVersion
   * @author @codedungeon
   * @param {any} pluginInfo
   * @param {any} message
   * @param {string} type
   * @returns {string}
   */
  function log(pluginInfo, message = '', type = 'INFO') {
    const thisMessageLevel = LOG_LEVELS.indexOf(type);
    const thisIndicator = LOG_LEVEL_STRINGS[thisMessageLevel];
    let msg = '';
    let pluginId = '';
    let pluginVersion = '';
    // let msgType = ''
    const isPluginJson = typeof pluginInfo === 'object' && pluginInfo.hasOwnProperty('plugin.id');
    if (isPluginJson) {
      pluginId = pluginInfo.hasOwnProperty('plugin.id') ? pluginInfo['plugin.id'] : 'INVALID_PLUGIN_ID';
      pluginVersion = pluginInfo.hasOwnProperty('plugin.version') ? pluginInfo['plugin.version'] : 'INVALID_PLUGIN_VERSION';
      msg = `${dt().padEnd(19)} ${thisIndicator} ${pluginId} v${pluginVersion} :: ${_message(message)}`;
    } else {
      if (message.length > 0) {
        // msg = `${dt().padEnd(19)} | ${thisIndicator.padEnd(7)} | ${pluginInfo} :: ${_message(message)}`
        msg = `${dt().padEnd(19)} ${thisIndicator} ${pluginInfo} :: ${_message(message)}`;
      } else {
        // msg = `${dt().padEnd(19)} | ${thisIndicator.padEnd(7)} | ${_message(pluginInfo)}`
        msg = `${dt().padEnd(19)} ${thisIndicator} ${_message(pluginInfo)}`;
      }
    }
    let userLogLevel = 1;
    const pluginSettings = typeof DataStore !== 'undefined' ? DataStore.settings : null;
    // this was the main offender.  Perform a null change against a value that is `undefined` will be true
    // sure wish NotePlan would not return `undefined` but instead null, then the previous implementataion would not have failed
    if (pluginSettings && pluginSettings.hasOwnProperty('_logLevel')) {
      // eslint-disable-next-line
      userLogLevel = pluginSettings['_logLevel'];
    }
    const userLogLevelIndex = LOG_LEVELS.indexOf(userLogLevel);
    if (thisMessageLevel >= userLogLevelIndex) {
      console.log(msg);
    }
    return msg;
  }

  /**
   * Formats log output as ERROR to include timestamp pluginId, pluginVersion
   * @author @codedungeon
   * @param {any} pluginInfo
   * @param {any} message
   * @returns {string}
   */
  function logError(pluginInfo, error) {
    if (typeof error === 'object' && error != null) {
      const msg = `${error.filename ?? '<unknown file>'} ${error.lineNumber ?? '<unkonwn line>'}: ${error.message}`;
      return log(pluginInfo, msg, 'ERROR');
    }
    return log(pluginInfo, error, 'ERROR');
  }

  /**
   * Formats log output as WARN to include timestamp pluginId, pluginVersion
   * @author @codedungeon
   * @param {any} pluginInfo
   * @param {any} message
   * @returns {void}
   */
  function logWarn(pluginInfo, message = '') {
    return log(pluginInfo, message, 'WARN');
  }

  /**
   * Formats log output as WARN to include timestamp pluginId, pluginVersion
   * @author @dwertheimer
   * @param {any} pluginInfo
   * @param {any} message
   * @returns {void}
   */
  function logDebug$1(pluginInfo, message = '') {
    return log(pluginInfo, message, 'DEBUG');
  }

  //-------------------------------------------------------------------------------

  //-----------------------------------------------------------
  // CONSTANTS
  const MOMENT_FORMAT_NP_ISO = 'YYYY-MM-DD';
  const MOMENT_FORMAT_NP_DAY = 'YYYYMMDD';
  const MOMENT_FORMAT_NP_WEEK = 'YYYY-[W]WW';
  const MOMENT_FORMAT_NP_MONTH = 'YYYY-MM';
  const MOMENT_FORMAT_NP_QUARTER = 'YYYY-[Q]Q';
  const RE_DATE = '\\d{4}-[01]\\d-[0123]\\d'; // find ISO dates of form YYYY-MM-DD (stricter than before)
  const RE_YYYYMMDD_DATE = '\\d{4}[01]\\d[0123]\\d'; // version of above that finds dates of form YYYYMMDD
  const RE_ISO_DATE = RE_DATE; // now earlier RE_DATE made the same as this stricter one

  // Week regex strings
  const RE_NP_WEEK_SPEC = '\\d{4}\\-W[0-5]\\d'; // find dates of form YYYY-Wnn
  /**
   * Constant version of getTodaysDateHyphenated()
   * This uses local time, so shouldn't get TZ problems.
   * @author @jgclark
   */
  const todaysDateISOString = moment$1().format('YYYY-MM-DD');

  // Note: there are others in NPdateTime.js that use locale settings

  moment$1().toISOString().replace('T', ' ').slice(0, 16);
  function unhyphenateString(dateString) {
    return dateString.replace(/-/g, '');
  }

  /**
   * Take a NP display date string and convert to one to use in API calls. In practice this leaves week, month, quarter, year dates alone, but changes YYYY-MM-DD to YYYYMMDD.
   * @param {string} dateStrIn from filename
   * @returns {string}
   */
  function getAPIDateStrFromDisplayDateStr(dateStrIn) {
    if (dateStrIn.match(RE_ISO_DATE)) {
      return unhyphenateString(dateStrIn);
    } else {
      return dateStrIn;
    }
  }

  /**
   * WARNING: Only for use where Monday is the user's first day of the week. See NPdateTime::getNPWeekData() for use with other days of the week.
   * @param {Date} inDate
   * @returns string
   */
  function getNPWeekStr(inDate) {
    // Using 'moment' library, with Monday first day of week
    const dateMoment = moment$1(inDate);
    return dateMoment.format(MOMENT_FORMAT_NP_WEEK);
  }

  //-------------------------------------------------------------------------------
  moment$1().toDate().toLocaleString();
  function pad(n) {
    return n < 10 ? `0${n}` : String(n);
  }

  /**
   * Get all the week details for a given unhyphenated|hyphenated(ISO8601) date string, a week string (YYYY-Wnn) or a Date object
   * Week info is offset depending on the NotePlan setting for the first day of the week
   * Note: requires API calls introduced in v3.7.0
   * @param {string} dateIn - date string in format YYYY-MM-DD, YYYYMMDD, YYYY-Wnn OR a Date object (default = today).
   * Note: Make sure that if you send in a date object that it's a date in the correct time/timezone you want.
   * If you create a new date of your own without a time (e.g. new Date("2022-01-01")) it could produce a date
   * in a previous or next day depending on your timezone. So if you are creating the date, just send through the date string rather than a date object.
   * @param {number} offsetIncrement - number of days|weeks|month to add (or negative=subtract) to date (default: 0)
   * @param {string} offsetType - the increment to add/subtract: 'day'|'week'|'month'|'year' (default: 'week'). Note: not quarters!
   * @returns { NotePlanWeekInfo | null } - an object with all the week details, or null if there's an error
   * getNPWeekData: alias weekInfo, weekData, getWeek, weeklyNote
   * {
   *   weekNumber: number, // e.g. 1
   *   weekYear: number, // e.g. 2022
   *   weekString: string, // e.g. 2022-W01
   *   startDate: Date,
   *   endDate: Date,
   *   date: Date,
   * }
   * @author @dwertheimer, extended by @jgclark
   */
  function getNPWeekData(dateIn = new Date(), offsetIncrement = 0, offsetType = 'week') {
    try {
      if (NotePlan?.environment?.buildVersion < 876 ?? true) {
        // to allow NPDateTime.test.js to run
        throw new Error('Sorry; week API calls requires NotePlan v3.7 or newer.');
      }
      let dateStrFormat = 'YYYY-MM-DD',
        newMom;
      if (typeof dateIn === 'string') {
        if (new RegExp(RE_YYYYMMDD_DATE).test(dateIn)) dateStrFormat = 'YYYYMMDD';
        if (new RegExp(RE_NP_WEEK_SPEC).test(dateIn)) dateStrFormat = 'YYYY-[W]WW';
        newMom = moment$1(dateIn, dateStrFormat).add(offsetIncrement, offsetType);
      } else {
        newMom = moment$1(dateIn).add(offsetIncrement, offsetType);
      }
      if (newMom) {
        const date = newMom.toDate();
        if (date) {
          const weekNumber = Calendar.weekNumber(date);
          const startDate = Calendar.startOfWeek(date);
          const endDate = Calendar.endOfWeek(date);
          const weekStartYear = startDate.getFullYear();
          const weekEndYear = endDate.getFullYear();
          const weekYear = weekStartYear === weekEndYear ? weekStartYear : weekNumber === 1 ? weekEndYear : weekStartYear;
          const weekString = `${weekYear}-W${pad(weekNumber)}`;
          return {
            weekNumber,
            startDate,
            endDate,
            weekYear,
            date,
            weekString
          };
        }
      }
      return null;
    } catch (err) {
      logError('NPdateTime::getNPWeekData', err.message);
      return null;
    }
  }

  /**
   * Get array of dates relative to today for day, week and month.
   * @author @jgclark
   * @returns {Array<Object>} relative date name, relative date string, TNote for that relative date
   */
  function getRelativeDates() {
    try {
      const relativeDates = [];
      const todayMom = moment$1();

      // Calculate relative dates. Remember to clone todayMom first as moments aren't immutable
      const thisDateStrDisplay = moment$1(todayMom).format(MOMENT_FORMAT_NP_ISO);
      let thisDateStr = moment$1(todayMom).format(MOMENT_FORMAT_NP_DAY);
      relativeDates.push({
        relName: 'today',
        dateStr: thisDateStrDisplay,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).subtract(1, 'days').startOf('day').format(MOMENT_FORMAT_NP_DAY);
      relativeDates.push({
        relName: 'yesterday',
        dateStr: thisDateStrDisplay,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).add(1, 'days').startOf('day').format(MOMENT_FORMAT_NP_DAY);
      relativeDates.push({
        relName: 'tomorrow',
        dateStr: thisDateStrDisplay,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });

      // can't start with moment as NP weeks count differently
      // $FlowIgnore[incompatible-type]
      let thisNPWeekInfo = getNPWeekData(new Date());
      thisDateStr = thisNPWeekInfo.weekString;
      relativeDates.push({
        relName: 'this week',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      // $FlowIgnore[incompatible-type]
      thisNPWeekInfo = getNPWeekData(new Date(), -1);
      // $FlowIgnore[incompatible-use]
      thisDateStr = thisNPWeekInfo.weekString;
      relativeDates.push({
        relName: 'last week',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      // $FlowIgnore[incompatible-type]
      thisNPWeekInfo = getNPWeekData(new Date(), 1);
      // $FlowIgnore[incompatible-use]
      thisDateStr = thisNPWeekInfo.weekString;
      relativeDates.push({
        relName: 'next week',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).startOf('month').format(MOMENT_FORMAT_NP_MONTH);
      relativeDates.push({
        relName: 'this month',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).subtract(1, 'month').startOf('month').format(MOMENT_FORMAT_NP_MONTH);
      relativeDates.push({
        relName: 'last month',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).add(1, 'month').startOf('month').format(MOMENT_FORMAT_NP_MONTH);
      relativeDates.push({
        relName: 'next month',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).startOf('quarter').format(MOMENT_FORMAT_NP_QUARTER);
      relativeDates.push({
        relName: 'this quarter',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).subtract(1, 'quarter').startOf('quarter').format(MOMENT_FORMAT_NP_QUARTER);
      relativeDates.push({
        relName: 'last quarter',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });
      thisDateStr = moment$1(todayMom).add(1, 'quarter').startOf('quarter').format(MOMENT_FORMAT_NP_QUARTER);
      relativeDates.push({
        relName: 'next quarter',
        dateStr: thisDateStr,
        note: DataStore.calendarNoteByDateString(thisDateStr)
      });

      // for (const rd of relativeDates) {
      //   const noteTitle = (rd.note) ? displayTitle(rd.note) : '(error)'
      //   logDebug('getRelativeDates', `${rd.name ?? ''}: ${rd.dateStr ?? ''} / ${noteTitle}`)
      // }
      return relativeDates;
    } catch (err) {
      logError('getRelativeDates', `${err.name}: ${err.message}`);
      return [{}]; // for completeness
    }
  }

  /** Detect free variable `global` from Node.js. */

  var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal$1;

  var freeGlobal = _freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$3 = freeGlobal || freeSelf || Function('return this')();

  var _root = root$3;

  var root$2 = _root;

  /** Built-in value references. */
  var Symbol$4 = root$2.Symbol;

  var _Symbol = Symbol$4;

  var Symbol$3 = _Symbol;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$4.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag$1;

  /** Used for built-in method references. */

  var objectProto$3 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$3.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString$1;

  var Symbol$2 = _Symbol,
      getRawTag = _getRawTag,
      objectToString = _objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$1(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  var _baseGetTag = baseGetTag$1;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */

  function isObject$3(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject$3;

  var baseGetTag = _baseGetTag,
      isObject$2 = isObject_1;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$2(value) {
    if (!isObject$2(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction$2;

  var root$1 = _root;

  /** Used to detect overreaching core-js shims. */
  var coreJsData$1 = root$1['__core-js_shared__'];

  var _coreJsData = coreJsData$1;

  var coreJsData = _coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$1(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked$1;

  /** Used for built-in method references. */

  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$1(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource$1;

  var isFunction$1 = isFunction_1,
      isMasked = _isMasked,
      isObject$1 = isObject_1,
      toSource = _toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$1(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  var _baseIsNative = baseIsNative$1;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */

  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue$1;

  var baseIsNative = _baseIsNative,
      getValue = _getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$2(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative$2;

  var getNative$1 = _getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate$4 = getNative$1(Object, 'create');

  var _nativeCreate = nativeCreate$4;

  var nativeCreate$3 = _nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear$1;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete$1;

  var nativeCreate$2 = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$2) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet$1;

  var nativeCreate$1 = _nativeCreate;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  }

  var _hashHas = hashHas$1;

  var nativeCreate = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  var _hashSet = hashSet$1;

  var hashClear = _hashClear,
      hashDelete = _hashDelete,
      hashGet = _hashGet,
      hashHas = _hashHas,
      hashSet = _hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$1(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype['delete'] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;

  var _Hash = Hash$1;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */

  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear$1;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */

  function eq$1(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq$1;

  var eq = eq_1;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$4(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf$4;

  var assocIndexOf$3 = _assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$1(key) {
    var data = this.__data__,
        index = assocIndexOf$3(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete$1;

  var assocIndexOf$2 = _assocIndexOf;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$1(key) {
    var data = this.__data__,
        index = assocIndexOf$2(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet$1;

  var assocIndexOf$1 = _assocIndexOf;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas$1;

  var assocIndexOf = _assocIndexOf;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$1(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet$1;

  var listCacheClear = _listCacheClear,
      listCacheDelete = _listCacheDelete,
      listCacheGet = _listCacheGet,
      listCacheHas = _listCacheHas,
      listCacheSet = _listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$1(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$1.prototype.clear = listCacheClear;
  ListCache$1.prototype['delete'] = listCacheDelete;
  ListCache$1.prototype.get = listCacheGet;
  ListCache$1.prototype.has = listCacheHas;
  ListCache$1.prototype.set = listCacheSet;

  var _ListCache = ListCache$1;

  var getNative = _getNative,
      root = _root;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root, 'Map');

  var _Map = Map$1;

  var Hash = _Hash,
      ListCache = _ListCache,
      Map = _Map;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  var _mapCacheClear = mapCacheClear$1;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */

  function isKeyable$1(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable$1;

  var isKeyable = _isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$4(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData$4;

  var getMapData$3 = _getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete$1;

  var getMapData$2 = _getMapData;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet$1;

  var getMapData$1 = _getMapData;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas$1;

  var getMapData = _getMapData;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$1(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet$1;

  var mapCacheClear = _mapCacheClear,
      mapCacheDelete = _mapCacheDelete,
      mapCacheGet = _mapCacheGet,
      mapCacheHas = _mapCacheHas,
      mapCacheSet = _mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$1(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$1.prototype.clear = mapCacheClear;
  MapCache$1.prototype['delete'] = mapCacheDelete;
  MapCache$1.prototype.get = mapCacheGet;
  MapCache$1.prototype.has = mapCacheHas;
  MapCache$1.prototype.set = mapCacheSet;

  var _MapCache = MapCache$1;

  var MapCache = _MapCache;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize$1(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize$1.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize$1.Cache = MapCache;

  var memoize_1 = memoize$1;

  var memoize = memoize_1;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped$1(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped$1;

  var memoizeCapped = _memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  var Symbol$1 = _Symbol;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
      symbolProto ? symbolProto.toString : undefined;

  /* eslint-disable max-len */ //---------------------------------------------------------------------
  // Regex definitions for NotePlan and its plugins
  // @jgclark, last updated 28.7.2023
  //---------------------------------------------------------------------
  //
  // This file holds definitions that don't live in more specific helper files, and also lists other files with useful regexes.
  //
  // Note: these are JavaScript RegExp objects.
  // They are then difficult to use in composition to more complex regexes: to do that start with simpler strings.
  //
  // The main ways to use them are:
  // - string.match(RE_NAME) -> array of matches
  // - RE_NAME.test(string) -> boolean
  //
  // Note: some have 'g' (global) or 'i' (case insensitive) flags set
  //---------------------------------------------------------------------
  // Times, Dates
  const RE_SCHEDULED_DATES_G = />(today|tomorrow|yesterday|(([0-9]{4})(-((0[1-9]|1[0-2])(-(0[1-9]|1[0-9]|2[0-9]|3[0-1]))?|Q[1-4]|W0[1-9]|W[1-4]\d|W5[0-3]))?))/g; // from Eduard, but tweaked to ignore ones that start with @ rather than >
  const RE_ARROW_DATES_G = />(today|tomorrow|yesterday|(([0-9]{4})(-((0[1-9]|1[0-2])(-(0[1-9]|1[0-9]|2[0-9]|3[0-1]))?|Q[1-4]|W0[1-9]|W[1-4]\d|W5[0-3]))?))</g; // as above but with a closing '<'

  // In helpers/dateTime.js:
  // - RE_TIME
  // - RE_DATE
  // - RE_YYYYMMDD_DATE
  // - RE_DATE_CAPTURE
  // - RE_ISO_DATE
  // - RE_PLUS_DATE_G
  // - RE_PLUS_DATE
  // - RE_SCHEDULED_ISO_DATE
  // - RE_DATE_TIME
  // - RE_BARE_DATE
  // - RE_BARE_DATE_CAPTURE
  // - RE_FILE_EXTENSIONS_GROUP
  // - RE_NP_DAY_SPEC
  // - RE_NP_WEEK_SPEC
  // - WEEK_NOTE_LINK
  // - RE_BARE_WEEKLY_DATE
  // - RE_BARE_WEEKLY_DATE_CAPTURE
  // - RE_NP_MONTH_SPEC
  // - RE_NP_QUARTER_SPEC
  // - RE_NP_YEAR_SPEC

  // @done(...)
  // In helpers/dateTime.js
  // - RE_DATE_INTERVAL
  // - RE_OFFSET_DATE
  // - RE_OFFSET_DATE_CAPTURE

  // Note filenames and links
  // In helpers/dateTime.js
  // - RE_WEEKLY_NOTE_FILENAME
  // - MONTH_NOTE_LINK
  // - RE_MONTHLY_NOTE_FILENAME
  // - QUARTER_NOTE_LINK
  // - RE_QUARTERLY_NOTE_FILENAME
  // - YEAR_NOTE_LINK
  // - RE_YEARLY_NOTE_FILENAME

  // Paragraphs
  // In helpers/paragraph.js:
  // - RE_URI
  // - RE_MARKDOWN_PATH
  // - RE_SYNC_MARKER

  // @done() markers
  // In helpers/dateTime.js
  // - RE_DONE_DATE_TIME
  // - RE_DONE_DATE_TIME_CAPTURES
  // - RE_DONE_DATE_OR_DATE_TIME_DATE_CAPTURE
  // - RE_DONE_DATE_OPT_TIME

  // Calendar / Event items
  const RE_EVENT_LINK = /!\[.*\]\(\d{4}-[01]\d-[0123]\d\s[0-2]\d:[0-5]\d:.*?:.*?:[A-F0-9-]{36,37}:.*?:.*?:.*?:.*?:.*?:(.+?):.*?:.*?:(#[A-F0-9]{6})\)/;
  // In helpers / calendar.js:
  // - RE_EVENT_ID

  // Time Blocks
  // In helpers / timeblocks.js:  (note the duplication)
  // - RE_ISO_DATE
  // - RE_HOURS
  // - RE_HOURS_EXT
  // - RE_MINUTES
  // - RE_TIME
  // - RE_TIME_EXT
  // - RE_AMPM
  // - RE_AMPM_OPT
  // - RE_TIME_TO
  // - RE_DONE_DATETIME
  // - RE_DONE_DATE_OPT_TIME
  // - RE_TIMEBLOCK_PART_A
  // - RE_TIMEBLOCK_PART_B
  // - RE_TIMEBLOCK_PART_C
  // - RE_TIMEBLOCK
  // - RE_TIMEBLOCK_APP
  // - RE_ALLOWED_TIME_BLOCK_LINE_START
  // - RE_TIMEBLOCK_FOR_THEMES

  // notelinks
  const RE_NOTELINK_G = /\[\[[^\[]+\]\]/g;

  // URLs and Links
  const RE_MARKDOWN_LINKS_CAPTURE_G = /\[([^\]]+)\]\(([^\)]+)\)/g;
  const RE_SIMPLE_URI_MATCH = /(\w+:\/\/[\w\.\/\?\#\&\d\-\=%*~,]+)/;
  const RE_SIMPLE_BARE_URI_MATCH_G = /((?!([\("'])).|^)(\b\w+:\/{1,3}[\w\.\/\?\#\&\d\-\=\@%*~,]+)/gi; // complex because it's still avoiding negative look-behind (though support is apparently coming in Safari 16.4 etc.)

  // Synced lines
  const RE_SYNC_MARKER = /\^[A-Za-z0-9]{6}(?![A-Za-z0-9])/;

  //-----------------------------------------------------------------------------

  /**
   * Convert bare URLs to display as HTML links
   * @author @jgclark
   * @tests in jest file
   * @param {string} original string
   * @param {boolean?} addWebIcon before the link? (default: true)
   * @param {boolean?} truncateIfNecessary the display of the link? (default: true)
   */
  function changeBareLinksToHTMLLink(original, addWebIcon = true, truncateIfNecessary = true) {
    let output = original;
    const captures = Array.from(original.matchAll(RE_SIMPLE_BARE_URI_MATCH_G) ?? []);
    if (captures.length > 0) {
      // clo(captures, `${String(captures.length)} results from bare URL matches:`)
      for (const capture of captures) {
        const linkURL = capture[3];
        const URLForDisplay = truncateIfNecessary && linkURL.length > 20 ? linkURL.slice(0, 50) + '...' : linkURL;
        // logDebug('changeBareLinksToHTMLLink', `${linkURL} / ${URLForDisplay}`)
        if (addWebIcon) {
          // not displaying icon
          output = output.replace(linkURL, `<a class="externalLink" href="${linkURL}"><i class="fa-regular fa-globe pad-right"></i>${URLForDisplay}</a>`);
        } else {
          output = output.replace(linkURL, `<a class="externalLink" href="${linkURL}">${URLForDisplay}</a>`);
        }
      }
    }
    return output;
  }

  /**
   * Change [title](URI) markdown links to <a href="URI">title</a> HTML style
   * @author @jgclark
   * @tests in jest file
   * @param {string} original string
   * @param {boolean?} addWebIcon before the link? (default: true)
   */
  function changeMarkdownLinksToHTMLLink(original, addWebIcon = true) {
    let output = original;
    const captures = Array.from(original.matchAll(RE_MARKDOWN_LINKS_CAPTURE_G) ?? []);
    if (captures.length > 0) {
      // clo(captures, `${String(captures.length)} results from markdown link matches:`)
      // Matches come in pairs, so process a pair at a time
      for (const capture of captures) {
        const linkTitle = capture[1];
        const linkURL = capture[2];
        if (addWebIcon) {
          // not displaying icon
          output = output.replace(`[${linkTitle}](${linkURL})`, `<a class="externalLink" href="${linkURL}"><i class="fa-regular fa-globe pad-right"></i>${linkTitle}</a>`);
        } else {
          output = output.replace(`[${linkTitle}](${linkURL})`, `<a class="externalLink" href="${linkURL}">${linkTitle}</a>`);
        }
      }
    }
    return output;
  }

  /**
   * Strip URLs from a string (leaves the [text] of the link intact by default)
   * @author @dwertheimer
   * @tests in jest file
   * @param {string} original
   * @param {boolean} leaveLinkText - if true, leaves the [text] of a wiki link intact
   * @returns {string} the string without any URLs
   */
  function stripLinksFromString(original, leaveLinkText = true) {
    let output = original;
    const captures = Array.from(original.matchAll(/(\[([^\]]+)\]\(([^\)]+)\))|(\w+:\/\/[\w\.\/\?\#\&\d\-\=%*,]+)/g) ?? []);
    if (captures.length > 0) {
      // clo(captures, `${String(captures.length)} results from markdown link matches:`)
      // Matches come in pairs, so process a pair at a time
      for (const capture of captures) {
        if (capture[2]) output = output.replace(capture[1], leaveLinkText ? `[${capture[2]}]` : ''); // [text](url)
        else output = output.replace(capture[0], ''); // bare url
        output = output.replace(/\s{2,}/, ' ').trimRight();
      }
    }
    return output;
  }

  /**
   * Strip `>today` and scheduled dates of form `>YYYY-MM-DD` that point to today from the input string
   * TODO: write tests
   * @author @jgclark
   * @param {string} original
   * @returns {string} altered string
   */
  function stripTodaysDateRefsFromString(original) {
    let output = original;
    const REGEX = new RegExp(`>(${todaysDateISOString}|today)`, 'g');
    const captures = output.match(REGEX) ?? [];
    if (captures.length > 0) {
      // clo(captures, `results from >(${todaysDateISOString}|today) match:`)
      for (const capture of captures) {
        output = output.replace(capture, '').replace(/\s{2,}/, ' ').trimRight();
      }
    }
    return output;
  }

  /**
   * Strip refs to this week (of form `>YYYY-Www`) from the input string
   * TODO: tests
   * @author @jgclark
   * @param {string} original
   * @returns {string} altered string
   */
  function stripThisWeeksDateRefsFromString(original) {
    let output = original;
    const thisWeekStr = getNPWeekStr(new Date());
    const REGEX = new RegExp(`>${thisWeekStr}`, 'g');
    const captures = output.match(REGEX) ?? [];
    if (captures.length > 0) {
      // clo(captures, `results from >${thisWeekStr} match:`)
      for (const capture of captures) {
        output = output.replace(capture, '').replace(/\s{2,}/, ' ').trimRight();
      }
    }
    return output;
  }

  /**
   * Strip all `<YYYY-MM-DD` dates from the input string
   * @author @jgclark
   * @tests in jest file
   * @param {string} original
   * @returns {string} altered string
   */
  function stripBackwardsDateRefsFromString(original) {
    let output = original;
    const REGEX = new RegExp(`<${RE_ISO_DATE}`, 'g');
    const captures = Array.from(output.matchAll(REGEX) ?? []);
    if (captures.length > 0) {
      // clo(captures, `results from <YYYY-MM-DD match:`)
      for (const capture of captures) {
        output = output.replace(capture[0], '').replace(/\s{2,}/, ' ').trimRight();
      }
    }
    return output;
  }

  //-----------------------------------------------------------------------------
  //-----------------------------------------------------------------------------

  /**
   * Perform substring match, ignoring case
   * Note: COPY TO AVOID CIRCULAR DEPENDENCY
   */
  function caseInsensitiveSubstringMatch(searchTerm, textToSearch) {
    const re = new RegExp(`${searchTerm}`, 'i'); // = case insensitive match
    return re.test(textToSearch);
  }

  /**
   * Check to see if search term is present within a URL or file path, using case insensitive searching.
   * Now updated to _not match_ if the search term is present in the rest of the line.
   * @author @jgclark
   *
   * @tests available in jest file
   * @param {string} term - term to check
   * @param {string} string - string to check in
   * @return {boolean} true if found
   */
  function isTermInURL(term, searchString) {
    // create version of searchString that doesn't include the URL and test that first
    const searchStringWithoutURL = stripLinksFromString(searchString);
    const success = caseInsensitiveSubstringMatch(term, searchStringWithoutURL) ? false : RE_SIMPLE_URI_MATCH.test(searchString);

    // logDebug('isTermInURL', `looking for ${term} in ${searchString} ${String(caseInsensitiveSubstringMatch(term, searchStringWithoutURL))} / ${searchStringWithoutURL} ${String(RE_SIMPLE_URI_MATCH.test(searchStringWithoutURL))} -> ${String(success)}`)
    return success;
  }

  /**
   * Is 'term' (typically a #tag) found in [[...]] or a URL in a string which may contain 0 or more notelinks and URLs?
   * @tests are in a commented-out function in jest file
   * @param {string} input
   * @param {string} term
   * @returns {boolean} true if found
   */
  function isTermInNotelinkOrURI(input, term) {
    if (term === '') {
      logWarn(`isTermInNotelinkOrURI`, `empty search term`);
      return false;
    }
    if (input === '') {
      logWarn(`isTermInNotelinkOrURI`, `empty input string to search`);
      return false;
    }
    // Where is the term in the input?
    const index = input.indexOf(term);
    if (index < 0) {
      // logDebug(`isTermInNotelinkOrURI`, `term ${term} not found in'${input}'`)
      return false;
    }
    // Find any [[...]] ranges
    const matches = input.matchAll(RE_NOTELINK_G);
    if (matches) {
      for (const match of matches) {
        clo(match);
        const rangeStart = match.index;
        const rangeEnd = match.index + match[0].length;
        // logDebug(`isTermInNotelinkOrURI`, `[[...]] range: ${String(rangeStart)}-${String(rangeEnd)}`)
        if (index >= rangeStart && index <= rangeEnd) {
          return true;
        }
      }
    }
    // Check for URL ranges. Following isn't perfect, but close enough for URLs on their own or in a [markdown](link).
    return isTermInURL(term, input);
  }

  //-----------------------------------------------------------------------------
  getRelativeDates();

  //-------------------------------------------------------------------------------

  /**
   * Get the folder name from the full NP (project) note filename, without leading or trailing slash.
   * Except for items in root folder -> '/'.
   * @author @jgclark
   * @param {string} fullFilename - full filename to get folder name part from
   * @returns {string} folder/subfolder name
   */
  function getFolderFromFilename(fullFilename) {
    try {
      // First deal with special case of file in root -> '/'
      if (!fullFilename.includes('/')) {
        return '/';
      }
      // drop first character if it's a slash
      const filename = fullFilename.startsWith('/') ? fullFilename.substr(1) : fullFilename;
      const filenameParts = filename.split('/');
      return filenameParts.slice(0, filenameParts.length - 1).join('/');
    } catch (error) {
      logError('folders/getFolderFromFilename', `Error getting folder from filename '${fullFilename}: ${error.message}`);
      return '(error)';
    }
  }

  var frontMatter = {exports: {}};

  var jsYaml$1 = {};

  var loader$1 = {};

  var common$6 = {};

  function isNothing(subject) {
    return (typeof subject === 'undefined') || (subject === null);
  }


  function isObject(subject) {
    return (typeof subject === 'object') && (subject !== null);
  }


  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];

    return [ sequence ];
  }


  function extend(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }


  function repeat(string, count) {
    var result = '', cycle;

    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }

    return result;
  }


  function isNegativeZero(number) {
    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
  }


  common$6.isNothing      = isNothing;
  common$6.isObject       = isObject;
  common$6.toArray        = toArray;
  common$6.repeat         = repeat;
  common$6.isNegativeZero = isNegativeZero;
  common$6.extend         = extend;

  function YAMLException$4(reason, mark) {
    // Super constructor
    Error.call(this);

    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

    // Include stack trace in error object
    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = (new Error()).stack || '';
    }
  }


  // Inherit from Error
  YAMLException$4.prototype = Object.create(Error.prototype);
  YAMLException$4.prototype.constructor = YAMLException$4;


  YAMLException$4.prototype.toString = function toString(compact) {
    var result = this.name + ': ';

    result += this.reason || '(unknown reason)';

    if (!compact && this.mark) {
      result += ' ' + this.mark.toString();
    }

    return result;
  };


  var exception = YAMLException$4;

  var common$5 = common$6;


  function Mark$1(name, buffer, position, line, column) {
    this.name     = name;
    this.buffer   = buffer;
    this.position = position;
    this.line     = line;
    this.column   = column;
  }


  Mark$1.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;

    if (!this.buffer) return null;

    indent = indent || 4;
    maxLength = maxLength || 75;

    head = '';
    start = this.position;

    while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > (maxLength / 2 - 1)) {
        head = ' ... ';
        start += 5;
        break;
      }
    }

    tail = '';
    end = this.position;

    while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > (maxLength / 2 - 1)) {
        tail = ' ... ';
        end -= 5;
        break;
      }
    }

    snippet = this.buffer.slice(start, end);

    return common$5.repeat(' ', indent) + head + snippet + tail + '\n' +
           common$5.repeat(' ', indent + this.position - start + head.length) + '^';
  };


  Mark$1.prototype.toString = function toString(compact) {
    var snippet, where = '';

    if (this.name) {
      where += 'in "' + this.name + '" ';
    }

    where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

    if (!compact) {
      snippet = this.getSnippet();

      if (snippet) {
        where += ':\n' + snippet;
      }
    }

    return where;
  };


  var mark = Mark$1;

  var YAMLException$3 = exception;

  var TYPE_CONSTRUCTOR_OPTIONS = [
    'kind',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'defaultStyle',
    'styleAliases'
  ];

  var YAML_NODE_KINDS = [
    'scalar',
    'sequence',
    'mapping'
  ];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type$h(tag, options) {
    options = options || {};

    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });

    // TODO: Add tag format check.
    this.tag          = tag;
    this.kind         = options['kind']         || null;
    this.resolve      = options['resolve']      || function () { return true; };
    this.construct    = options['construct']    || function (data) { return data; };
    this.instanceOf   = options['instanceOf']   || null;
    this.predicate    = options['predicate']    || null;
    this.represent    = options['represent']    || null;
    this.defaultStyle = options['defaultStyle'] || null;
    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }

  var type = Type$h;

  /*eslint-disable max-len*/

  var common$4        = common$6;
  var YAMLException$2 = exception;
  var Type$g          = type;


  function compileList(schema, name, result) {
    var exclude = [];

    schema.include.forEach(function (includedSchema) {
      result = compileList(includedSchema, name, result);
    });

    schema[name].forEach(function (currentType) {
      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });

      result.push(currentType);
    });

    return result.filter(function (type, index) {
      return exclude.indexOf(index) === -1;
    });
  }


  function compileMap(/* lists... */) {
    var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {}
        }, index, length;

    function collectType(type) {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }

    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }


  function Schema$5(definition) {
    this.include  = definition.include  || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];

    this.implicit.forEach(function (type) {
      if (type.loadKind && type.loadKind !== 'scalar') {
        throw new YAMLException$2('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }
    });

    this.compiledImplicit = compileList(this, 'implicit', []);
    this.compiledExplicit = compileList(this, 'explicit', []);
    this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
  }


  Schema$5.DEFAULT = null;


  Schema$5.create = function createSchema() {
    var schemas, types;

    switch (arguments.length) {
      case 1:
        schemas = Schema$5.DEFAULT;
        types = arguments[0];
        break;

      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;

      default:
        throw new YAMLException$2('Wrong number of arguments for Schema.create function');
    }

    schemas = common$4.toArray(schemas);
    types = common$4.toArray(types);

    if (!schemas.every(function (schema) { return schema instanceof Schema$5; })) {
      throw new YAMLException$2('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
    }

    if (!types.every(function (type) { return type instanceof Type$g; })) {
      throw new YAMLException$2('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    return new Schema$5({
      include: schemas,
      explicit: types
    });
  };


  var schema = Schema$5;

  var Type$f = type;

  var str = new Type$f('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function (data) { return data !== null ? data : ''; }
  });

  var Type$e = type;

  var seq = new Type$e('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function (data) { return data !== null ? data : []; }
  });

  var Type$d = type;

  var map = new Type$d('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function (data) { return data !== null ? data : {}; }
  });

  var Schema$4 = schema;


  var failsafe = new Schema$4({
    explicit: [
      str,
      seq,
      map
    ]
  });

  var Type$c = type;

  function resolveYamlNull(data) {
    if (data === null) return true;

    var max = data.length;

    return (max === 1 && data === '~') ||
           (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  var _null = new Type$c('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function () { return '~';    },
      lowercase: function () { return 'null'; },
      uppercase: function () { return 'NULL'; },
      camelcase: function () { return 'Null'; }
    },
    defaultStyle: 'lowercase'
  });

  var Type$b = type;

  function resolveYamlBoolean(data) {
    if (data === null) return false;

    var max = data.length;

    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
           (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
  }

  function constructYamlBoolean(data) {
    return data === 'true' ||
           data === 'True' ||
           data === 'TRUE';
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }

  var bool = new Type$b('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function (object) { return object ? 'true' : 'false'; },
      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
      camelcase: function (object) { return object ? 'True' : 'False'; }
    },
    defaultStyle: 'lowercase'
  });

  var common$3 = common$6;
  var Type$a   = type;

  function isHexCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
           ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
           ((0x61/* a */ <= c) && (c <= 0x66/* f */));
  }

  function isOctCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
  }

  function isDecCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;

    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;

    if (!max) return false;

    ch = data[index];

    // sign
    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }

    if (ch === '0') {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index];

      // base 2, base 8, base 16

      if (ch === 'b') {
        // base 2
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (ch !== '0' && ch !== '1') return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'x') {
        // base 16
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }

      // base 8
      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 10 (except 0) or base 60

    // value should not start with `_`;
    if (ch === '_') return false;

    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (ch === ':') break;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }

    // Should have digits and should not end with `_`
    if (!hasDigits || ch === '_') return false;

    // if !base60 - done;
    if (ch !== ':') return true;

    // base60 almost not used, no needs to optimize
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }

  function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];

    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }

    ch = value[0];

    if (ch === '-' || ch === '+') {
      if (ch === '-') sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === '0') return 0;

    if (ch === '0') {
      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x') return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }

    if (value.indexOf(':') !== -1) {
      value.split(':').forEach(function (v) {
        digits.unshift(parseInt(v, 10));
      });

      value = 0;
      base = 1;

      digits.forEach(function (d) {
        value += (d * base);
        base *= 60;
      });

      return sign * value;

    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return (Object.prototype.toString.call(object)) === '[object Number]' &&
           (object % 1 === 0 && !common$3.isNegativeZero(object));
  }

  var int = new Type$a('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
      octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
      decimal:     function (obj) { return obj.toString(10); },
      /* eslint-disable max-len */
      hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary:      [ 2,  'bin' ],
      octal:       [ 8,  'oct' ],
      decimal:     [ 10, 'dec' ],
      hexadecimal: [ 16, 'hex' ]
    }
  });

  var common$2 = common$6;
  var Type$9   = type;

  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
    // .2e4, .2
    // special case, seems not from spec
    '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
    // 20:59
    '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
    // .inf
    '|[-+]?\\.(?:inf|Inf|INF)' +
    // .nan
    '|\\.(?:nan|NaN|NAN))$');

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) ||
        // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === '_') {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign, base, digits;

    value  = data.replace(/_/g, '').toLowerCase();
    sign   = value[0] === '-' ? -1 : 1;
    digits = [];

    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }

    if (value === '.inf') {
      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

    } else if (value === '.nan') {
      return NaN;

    } else if (value.indexOf(':') >= 0) {
      value.split(':').forEach(function (v) {
        digits.unshift(parseFloat(v, 10));
      });

      value = 0.0;
      base = 1;

      digits.forEach(function (d) {
        value += d * base;
        base *= 60;
      });

      return sign * value;

    }
    return sign * parseFloat(value, 10);
  }


  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case 'lowercase': return '.nan';
        case 'uppercase': return '.NAN';
        case 'camelcase': return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '.inf';
        case 'uppercase': return '.INF';
        case 'camelcase': return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '-.inf';
        case 'uppercase': return '-.INF';
        case 'camelcase': return '-.Inf';
      }
    } else if (common$2.isNegativeZero(object)) {
      return '-0.0';
    }

    res = object.toString(10);

    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }

  function isFloat(object) {
    return (Object.prototype.toString.call(object) === '[object Number]') &&
           (object % 1 !== 0 || common$2.isNegativeZero(object));
  }

  var float = new Type$9('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });

  var Schema$3 = schema;


  var json = new Schema$3({
    include: [
      failsafe
    ],
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });

  var Schema$2 = schema;


  var core = new Schema$2({
    include: [
      json
    ]
  });

  var Type$8 = type;

  var YAML_DATE_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9])'                    + // [2] month
    '-([0-9][0-9])$');                   // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9]?)'                   + // [2] month
    '-([0-9][0-9]?)'                   + // [3] day
    '(?:[Tt]|[ \\t]+)'                 + // ...
    '([0-9][0-9]?)'                    + // [4] hour
    ':([0-9][0-9])'                    + // [5] minute
    ':([0-9][0-9])'                    + // [6] second
    '(?:\\.([0-9]*))?'                 + // [7] fraction
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
    '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0,
        delta = null, tz_hour, tz_minute, date;

    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

    if (match === null) throw new Error('Date resolve error');

    // match: [1] year [2] month [3] day

    year = +(match[1]);
    month = +(match[2]) - 1; // JS month starts with 0
    day = +(match[3]);

    if (!match[4]) { // no hour
      return new Date(Date.UTC(year, month, day));
    }

    // match: [4] hour [5] minute [6] second [7] fraction

    hour = +(match[4]);
    minute = +(match[5]);
    second = +(match[6]);

    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) { // milli-seconds
        fraction += '0';
      }
      fraction = +fraction;
    }

    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

    if (match[9]) {
      tz_hour = +(match[10]);
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
      if (match[9] === '-') delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

    if (delta) date.setTime(date.getTime() - delta);

    return date;
  }

  function representYamlTimestamp(object /*, style*/) {
    return object.toISOString();
  }

  var timestamp = new Type$8('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });

  var Type$7 = type;

  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }

  var merge = new Type$7('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });

  /*eslint-disable no-bitwise*/

  var NodeBuffer;

  try {
    // A trick for browserified version, to not include `Buffer` shim
    var _require$1 = commonjsRequire;
    NodeBuffer = _require$1('buffer').Buffer;
  } catch (__) {}

  var Type$6       = type;


  // [ 64, 65, 66 ] -> [ padding, CR, LF ]
  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


  function resolveYamlBinary(data) {
    if (data === null) return false;

    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

    // Convert one by one.
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));

      // Skip CR/LF
      if (code > 64) continue;

      // Fail on illegal characters
      if (code < 0) return false;

      bitlen += 6;
    }

    // If there are any bits left, source was corrupted
    return (bitlen % 8) === 0;
  }

  function constructYamlBinary(data) {
    var idx, tailbits,
        input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];

    // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx < max; idx++) {
      if ((idx % 4 === 0) && idx) {
        result.push((bits >> 16) & 0xFF);
        result.push((bits >> 8) & 0xFF);
        result.push(bits & 0xFF);
      }

      bits = (bits << 6) | map.indexOf(input.charAt(idx));
    }

    // Dump tail

    tailbits = (max % 4) * 6;

    if (tailbits === 0) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push((bits >> 10) & 0xFF);
      result.push((bits >> 2) & 0xFF);
    } else if (tailbits === 12) {
      result.push((bits >> 4) & 0xFF);
    }

    // Wrap into Buffer for NodeJS and leave Array for browser
    if (NodeBuffer) {
      // Support node 6.+ Buffer API when available
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }

    return result;
  }

  function representYamlBinary(object /*, style*/) {
    var result = '', bits = 0, idx, tail,
        max = object.length,
        map = BASE64_MAP;

    // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx < max; idx++) {
      if ((idx % 3 === 0) && idx) {
        result += map[(bits >> 18) & 0x3F];
        result += map[(bits >> 12) & 0x3F];
        result += map[(bits >> 6) & 0x3F];
        result += map[bits & 0x3F];
      }

      bits = (bits << 8) + object[idx];
    }

    // Dump tail

    tail = max % 3;

    if (tail === 0) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[(bits >> 10) & 0x3F];
      result += map[(bits >> 4) & 0x3F];
      result += map[(bits << 2) & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[(bits >> 2) & 0x3F];
      result += map[(bits << 4) & 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }

  var binary = new Type$6('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });

  var Type$5 = type;

  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2       = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;

    var objectKeys = [], index, length, pair, pairKey, pairHasKey,
        object = data;

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;

      if (_toString$2.call(pair) !== '[object Object]') return false;

      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }

      if (!pairHasKey) return false;

      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  var omap = new Type$5('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });

  var Type$4 = type;

  var _toString$1 = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      if (_toString$1.call(pair) !== '[object Object]') return false;

      keys = Object.keys(pair);

      if (keys.length !== 1) return false;

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      keys = Object.keys(pair);

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return result;
  }

  var pairs = new Type$4('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });

  var Type$3 = type;

  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;

    var key, object = data;

    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  var set = new Type$3('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });

  var Schema$1 = schema;


  var default_safe = new Schema$1({
    include: [
      core
    ],
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });

  var Type$2 = type;

  function resolveJavascriptUndefined() {
    return true;
  }

  function constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/
    return undefined;
  }

  function representJavascriptUndefined() {
    return '';
  }

  function isUndefined(object) {
    return typeof object === 'undefined';
  }

  var _undefined = new Type$2('tag:yaml.org,2002:js/undefined', {
    kind: 'scalar',
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });

  var Type$1 = type;

  function resolveJavascriptRegExp(data) {
    if (data === null) return false;
    if (data.length === 0) return false;

    var regexp = data,
        tail   = /\/([gim]*)$/.exec(data),
        modifiers = '';

    // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars
    if (regexp[0] === '/') {
      if (tail) modifiers = tail[1];

      if (modifiers.length > 3) return false;
      // if expression starts with /, is should be properly terminated
      if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
    }

    return true;
  }

  function constructJavascriptRegExp(data) {
    var regexp = data,
        tail   = /\/([gim]*)$/.exec(data),
        modifiers = '';

    // `/foo/gim` - tail can be maximum 4 chars
    if (regexp[0] === '/') {
      if (tail) modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }

    return new RegExp(regexp, modifiers);
  }

  function representJavascriptRegExp(object /*, style*/) {
    var result = '/' + object.source + '/';

    if (object.global) result += 'g';
    if (object.multiline) result += 'm';
    if (object.ignoreCase) result += 'i';

    return result;
  }

  function isRegExp(object) {
    return Object.prototype.toString.call(object) === '[object RegExp]';
  }

  var regexp = new Type$1('tag:yaml.org,2002:js/regexp', {
    kind: 'scalar',
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });

  var esprima;

  // Browserified version does not have esprima
  //
  // 1. For node.js just require module as deps
  // 2. For browser try to require mudule via external AMD system.
  //    If not found - try to fallback to window.esprima. If not
  //    found too - then fail to parse.
  //
  try {
    // workaround to exclude package from browserify list.
    var _require = commonjsRequire;
    esprima = _require('esprima');
  } catch (_) {
    /* eslint-disable no-redeclare */
    /* global window */
    if (typeof window !== 'undefined') esprima = window.esprima;
  }

  var Type = type;

  function resolveJavascriptFunction(data) {
    if (data === null) return false;

    try {
      var source = '(' + data + ')',
          ast    = esprima.parse(source, { range: true });

      if (ast.type                    !== 'Program'             ||
          ast.body.length             !== 1                     ||
          ast.body[0].type            !== 'ExpressionStatement' ||
          (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
            ast.body[0].expression.type !== 'FunctionExpression')) {
        return false;
      }

      return true;
    } catch (err) {
      return false;
    }
  }

  function constructJavascriptFunction(data) {
    /*jslint evil:true*/

    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      throw new Error('Failed to resolve function');
    }

    ast.body[0].expression.params.forEach(function (param) {
      params.push(param.name);
    });

    body = ast.body[0].expression.body.range;

    // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.
    if (ast.body[0].expression.body.type === 'BlockStatement') {
      /*eslint-disable no-new-func*/
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    // ES6 arrow functions can omit the BlockStatement. In that case, just return
    // the body.
    /*eslint-disable no-new-func*/
    return new Function(params, 'return ' + source.slice(body[0], body[1]));
  }

  function representJavascriptFunction(object /*, style*/) {
    return object.toString();
  }

  function isFunction(object) {
    return Object.prototype.toString.call(object) === '[object Function]';
  }

  var _function = new Type('tag:yaml.org,2002:js/function', {
    kind: 'scalar',
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });

  var Schema = schema;


  var default_full = Schema.DEFAULT = new Schema({
    include: [
      default_safe
    ],
    explicit: [
      _undefined,
      regexp,
      _function
    ]
  });

  /*eslint-disable max-len,no-use-before-define*/

  var common$1              = common$6;
  var YAMLException$1       = exception;
  var Mark                = mark;
  var DEFAULT_SAFE_SCHEMA$1 = default_safe;
  var DEFAULT_FULL_SCHEMA$1 = default_full;


  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


  var CONTEXT_FLOW_IN   = 1;
  var CONTEXT_FLOW_OUT  = 2;
  var CONTEXT_BLOCK_IN  = 3;
  var CONTEXT_BLOCK_OUT = 4;


  var CHOMPING_CLIP  = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP  = 3;


  var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


  function _class(obj) { return Object.prototype.toString.call(obj); }

  function is_EOL(c) {
    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
  }

  function is_WHITE_SPACE(c) {
    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
  }

  function is_WS_OR_EOL(c) {
    return (c === 0x09/* Tab */) ||
           (c === 0x20/* Space */) ||
           (c === 0x0A/* LF */) ||
           (c === 0x0D/* CR */);
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C/* , */ ||
           c === 0x5B/* [ */ ||
           c === 0x5D/* ] */ ||
           c === 0x7B/* { */ ||
           c === 0x7D/* } */;
  }

  function fromHexCode(c) {
    var lc;

    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    /*eslint-disable no-bitwise*/
    lc = c | 0x20;

    if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78/* x */) { return 2; }
    if (c === 0x75/* u */) { return 4; }
    if (c === 0x55/* U */) { return 8; }
    return 0;
  }

  function fromDecimalCode(c) {
    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return (c === 0x30/* 0 */) ? '\x00' :
          (c === 0x61/* a */) ? '\x07' :
          (c === 0x62/* b */) ? '\x08' :
          (c === 0x74/* t */) ? '\x09' :
          (c === 0x09/* Tab */) ? '\x09' :
          (c === 0x6E/* n */) ? '\x0A' :
          (c === 0x76/* v */) ? '\x0B' :
          (c === 0x66/* f */) ? '\x0C' :
          (c === 0x72/* r */) ? '\x0D' :
          (c === 0x65/* e */) ? '\x1B' :
          (c === 0x20/* Space */) ? ' ' :
          (c === 0x22/* " */) ? '\x22' :
          (c === 0x2F/* / */) ? '/' :
          (c === 0x5C/* \ */) ? '\x5C' :
          (c === 0x4E/* N */) ? '\x85' :
          (c === 0x5F/* _ */) ? '\xA0' :
          (c === 0x4C/* L */) ? '\u2028' :
          (c === 0x50/* P */) ? '\u2029' : '';
  }

  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(
      ((c - 0x010000) >> 10) + 0xD800,
      ((c - 0x010000) & 0x03FF) + 0xDC00
    );
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }


  function State$1(input, options) {
    this.input = input;

    this.filename  = options['filename']  || null;
    this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA$1;
    this.onWarning = options['onWarning'] || null;
    this.legacy    = options['legacy']    || false;
    this.json      = options['json']      || false;
    this.listener  = options['listener']  || null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap       = this.schema.compiledTypeMap;

    this.length     = input.length;
    this.position   = 0;
    this.line       = 0;
    this.lineStart  = 0;
    this.lineIndent = 0;

    this.documents = [];

    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/

  }


  function generateError(state, message) {
    return new YAMLException$1(
      message,
      new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
  }

  function throwError(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }


  var directiveHandlers = {

    YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (state.version !== null) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (args.length !== 1) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

    TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (args.length !== 2) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
  };


  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 0x09 ||
                (0x20 <= _character && _character <= 0x10FFFF))) {
            throwError(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, 'the stream contains non-printable characters');
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common$1.isObject(source)) {
      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;

    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, 'nested arrays are not supported inside keys');
        }

        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
          keyNode[index] = '[object Object]';
        }
      }
    }

    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
      keyNode = '[object Object]';
    }


    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json &&
          !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
          _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, 'duplicated mapping key');
      }
      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A/* LF */) {
      state.position++;
    } else if (ch === 0x0D/* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
        state.position++;
      }
    } else {
      throwError(state, 'a line break is expected');
    }

    state.line += 1;
    state.lineStart = state.position;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments && ch === 0x23/* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
      }

      if (is_EOL(ch)) {
        readLineBreak(state);

        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20/* Space */) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;

    ch = state.input.charCodeAt(_position);

    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
        ch === state.input.charCodeAt(_position + 1) &&
        ch === state.input.charCodeAt(_position + 2)) {

      _position += 3;

      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common$1.repeat('\n', count - 1);
    }
  }


  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch)      ||
        is_FLOW_INDICATOR(ch) ||
        ch === 0x23/* # */    ||
        ch === 0x26/* & */    ||
        ch === 0x2A/* * */    ||
        ch === 0x21/* ! */    ||
        ch === 0x7C/* | */    ||
        ch === 0x3E/* > */    ||
        ch === 0x27/* ' */    ||
        ch === 0x22/* " */    ||
        ch === 0x25/* % */    ||
        ch === 0x40/* @ */    ||
        ch === 0x60/* ` */) {
      return false;
    }

    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A/* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) ||
            withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }

      } else if (ch === 0x23/* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }

      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
                 withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;

      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch,
        captureStart, captureEnd;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27/* ' */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27/* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27/* ' */) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a single quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexResult,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22/* " */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22/* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;

      } else if (ch === 0x5C/* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;

        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;

            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;

        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a double quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _tag     = state.tag,
        _result,
        _anchor  = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = {},
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B/* [ */) {
      terminator = 0x5D;/* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B/* { */) {
      terminator = 0x7D;/* } */
      isMapping = true;
      _result = {};
    } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, 'missed comma between flow collection entries');
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F/* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C/* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }

    throwError(state, 'unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping       = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent     = nodeIndent,
        emptyLines     = 0,
        atMoreIndented = false,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C/* | */) {
      folding = false;
    } else if (ch === 0x3E/* > */) {
      folding = true;
    } else {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }

      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, 'repeat of an indentation width identifier');
        }

      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (is_WHITE_SPACE(ch));

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (!is_EOL(ch) && (ch !== 0));
      }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;

      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent < textIndent) &&
             (ch === 0x20/* Space */)) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }

      // End of the scalar.
      if (state.lineIndent < textIndent) {

        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) { // i.e. only if the scalar is not empty.
            state.result += '\n';
          }
        }

        // Break this `while` cycle and go to the funciton's epilogue.
        break;
      }

      // Folded style: use fancy rules to handle line breaks.
      if (folding) {

        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          // except for the first content line (cf. Example 8.1)
          state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common$1.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) { // i.e. only if we have already read some scalar content.
            state.result += ' ';
          }

        // Several line breaks - perceive as different lines.
        } else {
          state.result += common$1.repeat('\n', emptyLines);
        }

      // Literal style: just add exact number of line breaks between content lines.
      } else {
        // Keep all line breaks except the header line break.
        state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) && (ch !== 0)) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag      = state.tag,
        _anchor   = state.anchor,
        _result   = [],
        following,
        detected  = false,
        ch;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {

      if (ch !== 0x2D/* - */) {
        break;
      }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }
    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _pos,
        _tag          = state.tag,
        _anchor       = state.anchor,
        _result       = {},
        overridableKeys = {},
        keyTag        = null,
        keyNode       = null,
        valueNode     = null,
        atExplicitKey = false,
        detected      = false,
        ch;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.
      _pos = state.position;

      //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by "?") and second for the value (denoted by ":")
      //
      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

        if (ch === 0x3F/* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;

        } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;

        } else {
          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
        }

        state.position += 1;
        ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A/* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;

          } else if (detected) {
            throwError(state, 'can not read an implicit mapping pair; a colon is missed');

          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }

        } else if (detected) {
          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else {
        break; // Reading is done. Go to the epilogue.
      }

      //
      // Common reading code for both explicit and implicit notations.
      //
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if (state.lineIndent > nodeIndent && (ch !== 0)) {
        throwError(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    //
    // Epilogue.
    //

    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }

    // Expose the resulting mapping.
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed    = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x21/* ! */) return false;

    if (state.tag !== null) {
      throwError(state, 'duplication of a tag property');
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C/* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);

    } else if (ch === 0x21/* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);

    } else {
      tagHandle = '!';
    }

    _position = state.position;

    if (isVerbatim) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (ch !== 0 && ch !== 0x3E/* > */);

      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {

        if (ch === 0x21/* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, 'tag suffix cannot contain flow indicator characters');
      }
    }

    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;

    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;

    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;

    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;

    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x26/* & */) return false;

    if (state.anchor !== null) {
      throwError(state, 'duplication of an anchor property');
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an anchor node must contain at least one character');
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x2A/* * */) return false;

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an alias node must contain at least one character');
    }

    alias = state.input.slice(_position, state.position);

    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
        atNewLine  = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener('open', state);
    }

    state.tag    = null;
    state.anchor = null;
    state.kind   = null;
    state.result = null;

    allowBlockStyles = allowBlockScalars = allowBlockCollections =
      CONTEXT_BLOCK_OUT === nodeContext ||
      CONTEXT_BLOCK_IN  === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections &&
            (readBlockSequence(state, blockIndent) ||
             readBlockMapping(state, blockIndent, flowIndent)) ||
            readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
              readSingleQuotedScalar(state, flowIndent) ||
              readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;

          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError(state, 'alias node should not have any properties');
            }

          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = '?';
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag !== null && state.tag !== '!') {
      if (state.tag === '?') {
        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only automatically assigned to plain scalars.
        //
        // We only need to check kind conformity in case user explicitly assigns '?'
        // tag, for example like this: "!<?> [0]"
        //
        if (state.result !== null && state.kind !== 'scalar') {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }

        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];

          if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];

        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }

        if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
          throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
        } else {
          state.result = type.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, 'unknown tag !<' + state.tag + '>');
      }
    }

    if (state.listener !== null) {
      state.listener('close', state);
    }
    return state.tag !== null ||  state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent > 0 || ch !== 0x25/* % */) {
        break;
      }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError(state, 'directive name must not be less than one character in length');
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23/* # */) {
          do { ch = state.input.charCodeAt(++state.position); }
          while (ch !== 0 && !is_EOL(ch));
          break;
        }

        if (is_EOL(ch)) break;

        _position = state.position;

        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 &&
        state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);

    } else if (hasDirectives) {
      throwError(state, 'directives end mark is expected');
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks &&
        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart && testDocumentSeparator(state)) {

      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }

    if (state.position < (state.length - 1)) {
      throwError(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }


  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {

      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
        input += '\n';
      }

      // Strip BOM
      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State$1(input, options);

    var nullpos = input.indexOf('\0');

    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, 'null byte is not allowed in input');
    }

    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += '\0';

    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position < (state.length - 1)) {
      readDocument(state);
    }

    return state.documents;
  }


  function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    var documents = loadDocuments(input, options);

    if (typeof iterator !== 'function') {
      return documents;
    }

    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }


  function load(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException$1('expected a single document in the stream, but found more');
  }


  function safeLoadAll(input, iterator, options) {
    if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    return loadAll(input, iterator, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options));
  }


  function safeLoad(input, options) {
    return load(input, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options));
  }


  loader$1.loadAll     = loadAll;
  loader$1.load        = load;
  loader$1.safeLoadAll = safeLoadAll;
  loader$1.safeLoad    = safeLoad;

  var dumper$1 = {};

  /*eslint-disable no-use-before-define*/

  var common              = common$6;
  var YAMLException       = exception;
  var DEFAULT_FULL_SCHEMA = default_full;
  var DEFAULT_SAFE_SCHEMA = default_safe;

  var _toString       = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  var CHAR_TAB                  = 0x09; /* Tab */
  var CHAR_LINE_FEED            = 0x0A; /* LF */
  var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
  var CHAR_SPACE                = 0x20; /* Space */
  var CHAR_EXCLAMATION          = 0x21; /* ! */
  var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
  var CHAR_SHARP                = 0x23; /* # */
  var CHAR_PERCENT              = 0x25; /* % */
  var CHAR_AMPERSAND            = 0x26; /* & */
  var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
  var CHAR_ASTERISK             = 0x2A; /* * */
  var CHAR_COMMA                = 0x2C; /* , */
  var CHAR_MINUS                = 0x2D; /* - */
  var CHAR_COLON                = 0x3A; /* : */
  var CHAR_EQUALS               = 0x3D; /* = */
  var CHAR_GREATER_THAN         = 0x3E; /* > */
  var CHAR_QUESTION             = 0x3F; /* ? */
  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
  var CHAR_VERTICAL_LINE        = 0x7C; /* | */
  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

  var ESCAPE_SEQUENCES = {};

  ESCAPE_SEQUENCES[0x00]   = '\\0';
  ESCAPE_SEQUENCES[0x07]   = '\\a';
  ESCAPE_SEQUENCES[0x08]   = '\\b';
  ESCAPE_SEQUENCES[0x09]   = '\\t';
  ESCAPE_SEQUENCES[0x0A]   = '\\n';
  ESCAPE_SEQUENCES[0x0B]   = '\\v';
  ESCAPE_SEQUENCES[0x0C]   = '\\f';
  ESCAPE_SEQUENCES[0x0D]   = '\\r';
  ESCAPE_SEQUENCES[0x1B]   = '\\e';
  ESCAPE_SEQUENCES[0x22]   = '\\"';
  ESCAPE_SEQUENCES[0x5C]   = '\\\\';
  ESCAPE_SEQUENCES[0x85]   = '\\N';
  ESCAPE_SEQUENCES[0xA0]   = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';

  var DEPRECATED_BOOLEANS_SYNTAX = [
    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
  ];

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;

    if (map === null) return {};

    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }
      type = schema.compiledTypeMap['fallback'][tag];

      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;

    string = character.toString(16).toUpperCase();

    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
    }

    return '\\' + handle + common.repeat('0', length - string.length) + string;
  }

  function State(options) {
    this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
    this.indent        = Math.max(1, (options['indent'] || 2));
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid   = options['skipInvalid'] || false;
    this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
    this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys      = options['sortKeys'] || false;
    this.lineWidth     = options['lineWidth'] || 80;
    this.noRefs        = options['noRefs'] || false;
    this.noCompatMode  = options['noCompatMode'] || false;
    this.condenseFlow  = options['condenseFlow'] || false;

    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;

    this.tag = null;
    this.result = '';

    this.duplicates = [];
    this.usedDuplicates = null;
  }

  // Indents every line in a string. Empty lines (\n only) are not indented.
  function indentString(string, spaces) {
    var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;

    while (position < length) {
      next = string.indexOf('\n', position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length && line !== '\n') result += ind;

      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return '\n' + common.repeat(' ', state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  }

  // [33] s-white ::= s-space | s-tab
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }

  // Returns true if the character can be printed without escaping.
  // From YAML 1.2: "any allowed characters known to be non-printable
  // should also be escaped. [However,] This isnât mandatory"
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
  function isPrintable(c) {
    return  (0x00020 <= c && c <= 0x00007E)
        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
        ||  (0x10000 <= c && c <= 0x10FFFF);
  }

  // [34] ns-char ::= nb-char - s-white
  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
  // [26] b-char  ::= b-line-feed | b-carriage-return
  // [24] b-line-feed       ::=     #xA    /* LF */
  // [25] b-carriage-return ::=     #xD    /* CR */
  // [3]  c-byte-order-mark ::=     #xFEFF
  function isNsChar(c) {
    return isPrintable(c) && !isWhitespace(c)
      // byte-order-mark
      && c !== 0xFEFF
      // b-char
      && c !== CHAR_CARRIAGE_RETURN
      && c !== CHAR_LINE_FEED;
  }

  // Simplified test for values allowed after the first character in plain style.
  function isPlainSafe(c, prev) {
    // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
    // where nb-char ::= c-printable - b-char - c-byte-order-mark.
    return isPrintable(c) && c !== 0xFEFF
      // - c-flow-indicator
      && c !== CHAR_COMMA
      && c !== CHAR_LEFT_SQUARE_BRACKET
      && c !== CHAR_RIGHT_SQUARE_BRACKET
      && c !== CHAR_LEFT_CURLY_BRACKET
      && c !== CHAR_RIGHT_CURLY_BRACKET
      // - ":" - "#"
      // /* An ns-char preceding */ "#"
      && c !== CHAR_COLON
      && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));
  }

  // Simplified test for values allowed as the first character in plain style.
  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    return isPrintable(c) && c !== 0xFEFF
      && !isWhitespace(c) // - s-white
      // - (c-indicator ::=
      // â-â | â?â | â:â | â,â | â[â | â]â | â{â | â}â
      && c !== CHAR_MINUS
      && c !== CHAR_QUESTION
      && c !== CHAR_COLON
      && c !== CHAR_COMMA
      && c !== CHAR_LEFT_SQUARE_BRACKET
      && c !== CHAR_RIGHT_SQUARE_BRACKET
      && c !== CHAR_LEFT_CURLY_BRACKET
      && c !== CHAR_RIGHT_CURLY_BRACKET
      // | â#â | â&â | â*â | â!â | â|â | â=â | â>â | â'â | â"â
      && c !== CHAR_SHARP
      && c !== CHAR_AMPERSAND
      && c !== CHAR_ASTERISK
      && c !== CHAR_EXCLAMATION
      && c !== CHAR_VERTICAL_LINE
      && c !== CHAR_EQUALS
      && c !== CHAR_GREATER_THAN
      && c !== CHAR_SINGLE_QUOTE
      && c !== CHAR_DOUBLE_QUOTE
      // | â%â | â@â | â`â)
      && c !== CHAR_PERCENT
      && c !== CHAR_COMMERCIAL_AT
      && c !== CHAR_GRAVE_ACCENT;
  }

  // Determines whether block indentation indicator is required.
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN   = 1,
      STYLE_SINGLE  = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED  = 4,
      STYLE_DOUBLE  = 5;

  // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 => no limit.
  // Pre-conditions: str.length > 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(string.charCodeAt(0))
            && !isWhitespace(string.charCodeAt(string.length - 1));

    if (singleLineOnly) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          // Check if any line can be folded.
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine ||
              // Foldable line = too long, and not more-indented.
              (i - previousLineBreak - 1 > lineWidth &&
               string[previousLineBreak + 1] !== ' ');
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
      // in case the end is missing a \n
      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
        (i - previousLineBreak - 1 > lineWidth &&
         string[previousLineBreak + 1] !== ' '));
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string 'true' vs. the boolean true.
      return plain && !testAmbiguousType(string)
        ? STYLE_PLAIN : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }

  // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //    â¢ No ending newline => unaffected; already using strip "-" chomping.
  //    â¢ Ending newline    => removed then restored.
  //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
  function writeScalar(state, string, level, iskey) {
    state.dump = (function () {
      if (string.length === 0) {
        return "''";
      }
      if (!state.noCompatMode &&
          DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth â¤ 40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.
      var lineWidth = state.lineWidth === -1
        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

      // Without knowing if keys are implicit/explicit, assume implicit for safety.
      var singleLineOnly = iskey
        // No block styles in flow mode.
        || (state.flowLevel > -1 && level >= state.flowLevel);
      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException('impossible error: invalid scalar style');
      }
    }());
  }

  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip =          string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : (clip ? '' : '-');

    return indentIndicator + chomp + '\n';
  }

  // (See the note for writeScalar.)
  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  }

  // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;

    // first line (possibly an empty line)
    var result = (function () {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }());
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented;

    // rest of the lines
    var match;
    while ((match = lineRe.exec(string))) {
      var prefix = match[1], line = match[2];
      moreIndented = (line[0] === ' ');
      result += prefix
        + (!prevMoreIndented && !moreIndented && line !== ''
          ? '\n' : '')
        + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  }

  // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
  function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line;

    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = '';

    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while ((match = breakRe.exec(line))) {
      next = match.index;
      // maintain invariant: curr - start <= width
      if (next - start > width) {
        end = (curr > start) ? curr : next; // derive end <= length-2
        result += '\n' + line.slice(start, end);
        // skip the space that was output as \n
        start = end + 1;                    // derive start <= length-1
      }
      curr = next;
    }

    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += '\n';
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  }

  // Escapes a double-quoted string.
  function escapeString(string) {
    var result = '';
    var char, nextChar;
    var escapeSeq;

    for (var i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
      if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
          // Combine the surrogate pair and store it escaped.
          result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
          // Advance index one extra since we already used that char here.
          i++; continue;
        }
      }
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char)
        ? string[i]
        : escapeSeq || encodeHex(char);
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag    = state.tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(state, level, object[index], false, false)) {
        if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag    = state.tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {

      pairBuffer = '';
      if (index !== 0) pairBuffer += ', ';

      if (state.condenseFlow) pairBuffer += '"';

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length > 1024) pairBuffer += '? ';

      pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new YAMLException('sortKeys must be a boolean or a function');
    }

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = (state.tag !== null && state.tag !== '?') ||
                     (state.dump && state.dump.length > 1024);

      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf  || type.predicate) &&
          (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
          (!type.predicate  || type.predicate(object))) {

        state.tag = explicit ? type.tag : '?';

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  }

  // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString.call(state.dump);

    if (block) {
      block = (state.flowLevel < 0 || state.flowLevel > level);
    }

    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
      compact = false;
    }

    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === '[object Object]') {
        if (block && (Object.keys(state.dump).length !== 0)) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
        if (block && (state.dump.length !== 0)) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid) return false;
        throw new YAMLException('unacceptable kind of an object to dump ' + type);
      }

      if (state.tag !== null && state.tag !== '?') {
        state.dump = '!<' + state.tag + '> ' + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;

    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList,
        index,
        length;

    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump(input, options) {
    options = options || {};

    var state = new State(options);

    if (!state.noRefs) getDuplicateReferences(input, state);

    if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

    return '';
  }

  function safeDump(input, options) {
    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }

  dumper$1.dump     = dump;
  dumper$1.safeDump = safeDump;

  var loader = loader$1;
  var dumper = dumper$1;


  function deprecated(name) {
    return function () {
      throw new Error('Function ' + name + ' is deprecated and cannot be used.');
    };
  }


  jsYaml$1.Type                = type;
  jsYaml$1.Schema              = schema;
  jsYaml$1.FAILSAFE_SCHEMA     = failsafe;
  jsYaml$1.JSON_SCHEMA         = json;
  jsYaml$1.CORE_SCHEMA         = core;
  jsYaml$1.DEFAULT_SAFE_SCHEMA = default_safe;
  jsYaml$1.DEFAULT_FULL_SCHEMA = default_full;
  jsYaml$1.load                = loader.load;
  jsYaml$1.loadAll             = loader.loadAll;
  jsYaml$1.safeLoad            = loader.safeLoad;
  jsYaml$1.safeLoadAll         = loader.safeLoadAll;
  jsYaml$1.dump                = dumper.dump;
  jsYaml$1.safeDump            = dumper.safeDump;
  jsYaml$1.YAMLException       = exception;

  // Deprecated schema names from JS-YAML 2.0.x
  jsYaml$1.MINIMAL_SCHEMA = failsafe;
  jsYaml$1.SAFE_SCHEMA    = default_safe;
  jsYaml$1.DEFAULT_SCHEMA = default_full;

  // Deprecated functions from JS-YAML 1.x.x
  jsYaml$1.scan           = deprecated('scan');
  jsYaml$1.parse          = deprecated('parse');
  jsYaml$1.compose        = deprecated('compose');
  jsYaml$1.addConstructor = deprecated('addConstructor');

  var yaml = jsYaml$1;


  var jsYaml = yaml;

  var parser = jsYaml;
  var optionalByteOrderMark = '\\ufeff?';
  var platform = typeof process !== 'undefined' ? process.platform : '';
  var pattern = '^(' +
    optionalByteOrderMark +
    '(= yaml =|---)' +
    '$([\\s\\S]*?)' +
    '^(?:\\2|\\.\\.\\.)\\s*' +
    '$' +
    (platform === 'win32' ? '\\r?' : '') +
    '(?:\\n)?)';
  // NOTE: If this pattern uses the 'g' flag the `regex` variable definition will
  // need to be moved down into the functions that use it.
  var regex = new RegExp(pattern, 'm');

  frontMatter.exports = extractor;
  frontMatter.exports.test = test;

  function extractor (string, options) {
    string = string || '';
    var defaultOptions = { allowUnsafe: false };
    options = options instanceof Object ? { ...defaultOptions, ...options } : defaultOptions;
    options.allowUnsafe = Boolean(options.allowUnsafe);
    var lines = string.split(/(\r?\n)/);
    if (lines[0] && /= yaml =|---/.test(lines[0])) {
      return parse(string, options.allowUnsafe)
    } else {
      return {
        attributes: {},
        body: string,
        bodyBegin: 1
      }
    }
  }

  function computeLocation (match, body) {
    var line = 1;
    var pos = body.indexOf('\n');
    var offset = match.index + match[0].length;

    while (pos !== -1) {
      if (pos >= offset) {
        return line
      }
      line++;
      pos = body.indexOf('\n', pos + 1);
    }

    return line
  }

  function parse (string, allowUnsafe) {
    var match = regex.exec(string);
    if (!match) {
      return {
        attributes: {},
        body: string,
        bodyBegin: 1
      }
    }

    var loader = allowUnsafe ? parser.load : parser.safeLoad;
    var yaml = match[match.length - 1].replace(/^\s+|\s+$/g, '');
    var attributes = loader(yaml) || {};
    var body = string.replace(match[0], '');
    var line = computeLocation(match, string);

    return {
      attributes: attributes,
      body: body,
      bodyBegin: line,
      frontmatter: yaml
    }
  }

  function test (string) {
    string = string || '';

    return regex.test(string)
  }

  // ---------------------------------------------------------

  // add basic ***bolditalic*** styling
  // add basic **bold** or __bold__ styling
  // add basic *italic* or _italic_ styling
  function convertBoldAndItalicToHTML(input) {
    let output = input;
    const RE_BOLD_ITALIC_PHRASE = new RegExp(/\*\*\*\b(.*?)\b\*\*\*/, 'g');
    let captures = output.matchAll(RE_BOLD_ITALIC_PHRASE);
    if (captures) {
      for (const capture of captures) {
        // logDebug('convertBoldAndItalicToHTML', `- making bold-italic with [${String(capture)}]`)
        output = output.replace(capture[0], `<b><em>${capture[1]}</em></b>`);
      }
    }

    // add basic **bold** or __bold__ styling
    const RE_BOLD_PHRASE = new RegExp(/([_\*]{2})([^_*]+?)\1/, 'g');
    captures = output.matchAll(RE_BOLD_PHRASE);
    if (captures) {
      for (const capture of captures) {
        // logDebug('convertBoldAndItalicToHTML', `- making bold with [${String(capture)}]`)
        output = output.replace(capture[0], `<b>${capture[2]}</b>`);
      }
    }

    // add basic *italic* or _italic_ styling
    // Note: uses a simplified regex that needs to come after bold above
    const RE_ITALIC_PHRASE = new RegExp(/([_\*])([^*]+?)\1/, 'g');
    captures = output.matchAll(RE_ITALIC_PHRASE);
    if (captures) {
      for (const capture of captures) {
        // logDebug('convertBoldAndItalicToHTML', `- making italic with [${String(capture)}]`)
        output = output.replace(capture[0], `<em>${capture[2]}</em>`);
      }
    }
    return output;
  }

  // Simplify NP event links
  // of the form `![ð](2023-01-13 18:00:::F9766457-9C4E-49C8-BC45-D8D821280889:::NA:::Contact X about Y:::#63DA38)`
  function simplifyNPEventLinksForHTML(input) {
    let output = input;
    const captures = output.match(RE_EVENT_LINK);
    if (captures) {
      // clo(captures, 'results from NP event link matches:')
      // Matches come in threes (plus full match), so process four at a time
      for (let c = 0; c < captures.length; c = c + 3) {
        const eventLink = captures[c];
        const eventTitle = captures[c + 1];
        const eventColor = captures[c + 2];
        output = output.replace(eventLink, `<i class="fa-regular fa-calendar" style="color: ${eventColor}"></i> <span class="event-link">${eventTitle}</span>`);
      }
    }
    return output;
  }

  // Simplify embedded images of the form ![image](...) by replacing with an icon.
  // (This also helps remove false positives for ! priority indicator)
  function simplifyInlineImagesForHTML(input) {
    let output = input;
    const captures = output.match(/!\[image\]\([^\)]+\)/g);
    if (captures) {
      // clo(captures, 'results from embedded image match:')
      for (const capture of captures) {
        logDebug$1(`simplifyInlineImagesForHTML`, capture);
        output = output.replace(capture, `<i class="fa-regular fa-image"></i> `);
        logDebug$1(`simplifyInlineImagesForHTML`, `-> ${output}`);
      }
    }
    return output;
  }

  // Display hashtags with .hashtag style
  // Note: need to make only one capture group, and use 'g'lobal flag
  function convertHashtagsToHTML(input) {
    let output = input;
    // const captures = output.match(/(\s|^|\"|\'|\(|\[|\{)(?!#[\d[:punct:]]+(\s|$))(#([^[:punct:]\s]|[\-_\/])+?\(.*?\)|#([^[:punct:]\s]|[\-_\/])+)/) // regex from @EduardMe's file
    // const captures = output.match(/(\s|^|\"|\'|\(|\[|\{)(?!#[\d\'\"]+(\s|$))(#([^\'\"\s]|[\-_\/])+?\(.*?\)|#([^\'\"\s]|[\-_\/])+)/) // regex from @EduardMe's file without :punct:
    const captures = output.match(/\B(?:#|ï¼)((?![\p{N}_]+(?:$|\b|\s))(?:[\p{L}\p{M}\p{N}_]{1,60}))/gu); // copes with Unicode characters, with help from https://stackoverflow.com/a/74926188/3238281
    if (captures) {
      // clo(captures, 'results from hashtag matches:')
      for (const capture of captures) {
        // logDebug('convertHashtagsToHTML', `capture: ${capture}`)
        if (!isTermInNotelinkOrURI(output, capture)) {
          output = output.replace(capture, `<span class="hashtag">${capture}</span>`);
        }
      }
    }
    return output;
  }

  // Display mentions with .attag style. Now includes also parts in brackets directly after it.
  // Note: need to make only one capture group, and use 'g'lobal flag
  function convertMentionsToHTML(input) {
    let output = input;
    // const captures = output.match(/(\s|^|\"|\'|\(|\[|\{)(?!@[\d[:punct:]]+(\s|$))(@([^[:punct:]\s]|[\-_\/])+?\(.*?\)|@([^[:punct:]\s]|[\-_\/])+)/) // regex from @EduardMe's file
    // const captures = output.match(/(\s|^|\"|\'|\(|\[|\{)(?!@[\d\`\"]+(\s|$))(@([^\`\"\s]|[\-_\/])+?\(.*?\)|@([^\`\"\s]|[\-_\/])+)/) // regex from @EduardMe's file, without [:punct:]
    const captures = output.match(/\B@((?![\p{N}_]+(?:$|\b|\s))(?:[\p{L}\p{M}\p{N}_]{1,60})(\(.*?\))?)/gu); // copes with Unicode characters, with help from https://stackoverflow.com/a/74926188/3238281
    if (captures) {
      // clo(captures, 'results from mention matches:')
      for (const capture of captures) {
        const match = capture; //[2] // part from @
        output = output.replace(match, `<span class="attag">${match}</span>`);
      }
    }
    return output;
  }

  /**
   * Convert markdown `pre-formatted` fragments to HTML with .code class
   * @param {string} input
   * @returns {string} output
   */
  function convertPreformattedToHTML(input) {
    let output = input;
    const captures = output.match(/`.*?`/g);
    if (captures) {
      // clo(captures, 'results from code matches:')
      for (const capture of captures) {
        const match = capture;
        output = output.replace(match, `<span class="code">${match.slice(1, -1)}</span>`);
      }
    }
    return output;
  }

  // Display mentions with .code style
  function convertHighlightsToHTML(input) {
    let output = input;
    const captures = output.match(/==.*?==/g);
    if (captures) {
      // clo(captures, 'results from highlight matches:')
      for (const capture of captures) {
        const match = capture;
        output = output.replace(match, `<span class="highlighted">${match.slice(2, -2)}</span>`);
      }
    }
    return output;
  }

  // Display underlined with .underlined style
  // TODO: regex isn't quite right. But can't get original one to work for reasons I can't understand
  // But does cope with lone ~ in URLs
  function convertUnderlinedToHTML(input) {
    let output = input;
    // const captures = output.match(/(?:[\s^])~.*?~(?:[\s$])/g)
    const captures = output.match(/~[\w\-'"]*?~/g);
    if (captures) {
      clo(captures, 'results from underlined matches:');
      for (const capture of captures) {
        const match = capture;
        output = output.replace(match, `<span class="underlined">${match.slice(1, -1)}</span>`);
      }
    }
    return output;
  }

  // Display strike text with .strikethrough style
  //
  function convertStrikethroughToHTML(input) {
    let output = input;
    const captures = output.match(/~~.*?~~/g);
    if (captures) {
      // clo(captures, 'results from strikethrough matches:')
      for (const capture of captures) {
        const match = capture;
        output = output.replace(match, `<span class="strikethrough">${match.slice(2, -2)}</span>`);
      }
    }
    return output;
  }
  function convertNPBlockIDToHTML(input) {
    // Replace blockID sync indicator with icon
    // NB: needs to go after #hashtag change above, as it includes a # marker for colors.
    let output = input;
    const captures = output.match(RE_SYNC_MARKER);
    if (captures) {
      // clo(captures, 'results from RE_SYNC_MARKER match:')
      for (const capture of captures) {
        output = output.replace(capture, '<i class="fa-solid fa-asterisk" style="color: #71b3c0;"></i>');
      }
    }
    return output;
  }

  /**
   * Truncate visible part of HTML string, without breaking the HTML tags, or markdown links.
   * @param {string} htmlIn
   * @param {number} maxLength of output
   * @param {boolean} dots - add ellipsis to end?
   * @returns {string} truncated HTML
   * TODO: write tests for this
   */
  function truncateHTML(htmlIn, maxLength, dots = true) {
    let inHTMLTag = false;
    let inMDLink = false;
    let truncatedHTML = '';
    let lengthLeft = maxLength;
    for (let index = 0; index < htmlIn.length; index++) {
      if (!lengthLeft || lengthLeft === 0) {
        // no lengthLeft: stop processing
        break;
      }
      if (htmlIn[index] === '<' && htmlIn.slice(index).includes('>')) {
        // if we've started an HTML tag stop counting
        // logDebug('truncateHTML', `started HTML tag at ${String(index)}`)
        inHTMLTag = true;
      }
      if (htmlIn[index] === '[' && htmlIn.slice(index).match(/\]\(.*\)/)) {
        // if we've started a MD link tag stop counting
        // logDebug('truncateHTML', `started MD link at ${String(index)}`)
        inMDLink = true;
      }
      if (!inHTMLTag && !inMDLink) {
        lengthLeft--;
      }
      if (htmlIn[index] === '>' && inHTMLTag) {
        // logDebug('truncateHTML', `stopped HTML tag at ${String(index)}`)
        inHTMLTag = false;
      }
      if (htmlIn[index] === ')' && inMDLink) {
        // logDebug('truncateHTML', `stopped MD link at ${String(index)}`)
        inMDLink = false;
      }
      truncatedHTML += htmlIn[index];
    }
    if (dots) {
      truncatedHTML = `${truncatedHTML} â¦`;
    }
    logDebug$1('truncateHTML', `{${htmlIn}} -> {${truncatedHTML}}`);
    return truncatedHTML;
  }

  /**
   * Represents the main content for a single item within a section
   */
  function ItemContent(inputObj) {
    const {
      item /*thisSection*/
    } = inputObj;
    const para = item.para;
    // const itemType = para.type

    console.log(`ItemContent for '${para?.content ?? '<error>'}'`);

    // compute the things we need later
    const mainContent = makeParaContentToLookLikeNPDisplayInReact(item, 140); // TODO: other cases for this

    // console.log(`-> ${mainContent}`)

    // TODO(later): try not to live dangerously!
    return /*#__PURE__*/React__default["default"].createElement("a", {
      className: "content",
      dangerouslySetInnerHTML: {
        __html: mainContent
      }
    });
  }

  /**
   * Produce an HTML version of the provided paragraph's content to mimic NP's native display of markdown (as best we can). Currently this:
   * - simplifies NP event links, and tries to colour them
   * - turns MD links -> HTML links
   * - truncates the display of raw URLs if necessary
   * - turns NP sync ids -> blue asterisk icon
   * - turns #hashtags and @mentions the colour that the theme displays them
   * - turns >date markers the colour that the theme displays them
   * - styles in bold/italic
   * Note: the actual note link is added following load by adding click handler to all items with class "sectionItemContent" (which already have a basic <a>...</a> wrapper).
   * It additionally:
   * - truncates the overall string if requested
   * - if noteTitle is supplied, then either 'append' it as a active NP note title, or make it the active NP note link for 'all' the string.
   * @author @jgclark
   * @param {SectionItem} thisItem
   * @param {string?} truncateLength (optional) length of string after which to truncate. Will not truncate if set to 0.
   * @returns {string} HTML string
   */
  function makeParaContentToLookLikeNPDisplayInReact(thisItem,
  // noteLinkStyle: string = "all", // or "append"
  truncateLength = 0) {
    try {
      const {
        para
      } = thisItem;
      if (!para || !para.content) {
        throw new Error(`No para/content in item ${thisItem.ID}`);
      }
      const filename = para.filename ?? '<error>';
      const origContent = para.content ?? '<error>';
      const noteTitle = para.title ?? '';
      console.log(`makeParaContent...: for '${thisItem.ID}' / noteTitle '${noteTitle}' / filename '${filename}' / {${origContent}}`);
      // Start with the content of the item
      let output = origContent;

      // // See if there's a !, !!, !!! or >> in the line, and if so set taskPriority accordingly
      // const taskPriority = getTaskPriority(output)
      // if (taskPriority > 0) {
      //   output = removeTaskPriorityIndicators(output)
      // }
      const taskPriority = para.priority ?? 0;
      if (noteTitle === '(error)') {
        console.error(`makeParaContent...: ERROR starting with noteTitle '(error)' for '${origContent}'`);
      }

      // Simplify NP event links of the form
      // `![ð](2023-01-13 18:00:::F9766457-9C4E-49C8-BC45-D8D821280889:::NA:::Contact X about Y:::#63DA38)` to HTML with icon
      output = simplifyNPEventLinksForHTML(output);

      // Simplify embedded images of the form ![image](...) by replacing with an icon.
      // (This also helps remove false positives for ! priority indicator)
      output = simplifyInlineImagesForHTML(output);

      // Display markdown links of the form [title](URI) as HTML links
      output = changeMarkdownLinksToHTMLLink(output);

      // Display bare URLs as HTML links
      output = changeBareLinksToHTMLLink(output);

      // Display hashtags with .hashtag style
      output = convertHashtagsToHTML(output);

      // Display mentions with .attag style
      output = convertMentionsToHTML(output);

      // Display pre-formatted with .code style
      output = convertPreformattedToHTML(output);

      // Display time blocks with .timeBlock style
      // TODO:
      // output = convertTimeBlockToHTML(output)

      // Display strikethrough with .strikethrough style
      output = convertStrikethroughToHTML(output);

      // Display highlights with .code style
      output = convertHighlightsToHTML(output);

      // Replace blockID sync indicator with icon
      // NB: needs to go after #hashtag change above, as it includes a # marker for colors.
      output = convertNPBlockIDToHTML(output);

      // Strip `>today` and scheduled dates of form `>YYYY-MM-DD` that point to today
      output = stripTodaysDateRefsFromString(output);

      // Strip refs to this week (of form `>YYYY-Www`)
      output = stripThisWeeksDateRefsFromString(output);

      // Strip all `<YYYY-MM-DD` dates
      output = stripBackwardsDateRefsFromString(output);

      // add basic ***bolditalic*** styling
      // add basic **bold** or __bold__ styling
      // add basic *italic* or _italic_ styling
      output = convertBoldAndItalicToHTML(output);

      // Display underline with .underlined style
      output = convertUnderlinedToHTML(output);

      // Add suitable colouring to 'arrow' >date< items
      // (Needs to go before match on >date dates)
      let captures = output.match(RE_ARROW_DATES_G);
      if (captures) {
        // clo(captures, 'results from arrow >date< match:')
        for (const capture of captures) {
          // output = output.replace(capture, `<span style="color: var(--tint-color);">${capture}</span>`)
          console.log(`makeParaContet...: - making arrow date with ${capture}`);
          // Replace >date< with HTML link, aware that this will interrupt the <a>...</a> that will come around the whole string, and so it needs to make <a>...</a> regions for the rest of the string before and after the capture.
          const dateFilenamePart = capture.slice(1, -1);
          const noteTitleWithOpenAction = makeNoteTitleWithOpenActionFromNPDateStr(dateFilenamePart, thisItem.ID);
          output = output.replace(capture, `</a>${noteTitleWithOpenAction}<a class="content">`);
        }
      }

      // Add suitable colouring to remaining >date items
      captures = output.match(RE_SCHEDULED_DATES_G);
      if (captures) {
        // clo(captures, 'results from >date match:')
        for (const capture of captures) {
          output = output.replace(capture, `<span style="color: var(--tint-color);">${capture}</span>`);
        }
      }

      // Replace [[notelinks]] with HTML equivalent, and coloured
      // Note: needs to go after >date section above
      captures = output.match(/\[\[(.*?)\]\]/);
      if (captures) {
        // clo(captures, 'results from [[notelinks]] match:')
        for (const capturedTitle of captures) {
          // console.log(`makeParaContet...: - making notelink with ${thisItem.filename}, ${capturedTitle}`)
          // Replace [[notelinks]] with HTML equivalent, aware that this will interrupt the <a>...</a> that will come around the whole string, and so it needs to make <a>...</a> regions for the rest of the string before and after the capture.
          const noteTitleWithOpenAction = makeNoteTitleWithOpenActionFromTitle(capturedTitle);
          output = output.replace(`[[${capturedTitle}]]`, `</a>${noteTitleWithOpenAction}<a>`);
        }
      }

      // Truncate the HTML string if wanted (avoiding breaking in middle of HTML tags)
      // Note: Best done before the note link is added
      if (truncateLength > 0 && thisItem.para.content.length > truncateLength) {
        output = truncateHTML(output, truncateLength, true);
      }

      // If we already know (from above) there's a !, !!, !!! or >> in the line add priorityN styling around the whole string. Where it is "working-on", it uses priority5.
      // Note: this wrapping needs to go last.
      if (taskPriority > 0) {
        output = `<span class="priority${String(taskPriority)}">${output}</span>`;
      }

      // console.log(`makeParaContet...: \n-> ${output}`)
      return output;
    } catch (error) {
      console.error(`ItemContent::makeParaContentToLookLikeNPDisplayInReact âï¸ERRORâï¸  ${error.message}`);
      return '';
    }
  }

  /**
   * Wrap string with href onClick event to show note in editor,
   * using noteTitle param.
   * Note: based only on 'noteTitle', not a filename
   * @param {string} noteTitle
   * @returns {string} output
   */
  function makeNoteTitleWithOpenActionFromTitle(noteTitle) {
    try {
      // console.log(`makeNoteTitleWithOpenActionFromTitle: - making notelink from ${noteTitle}`)
      // Pass request back to plugin
      // Note: not passing rawContent (param 4) as its not needed
      return `<a class="noteTitle sectionItem" {()=>onClickDashboardItem({itemID:'fake', type:'showNoteInEditorFromTitle', encodedFilename:'${encodeURIComponent(noteTitle)}', encodedContent:''}}><i class="fa-regular fa-file-lines pad-right"></i> ${noteTitle}</a>`;
    } catch (error) {
      console.log(`makeNoteTitleWithOpenActionFromTitle: ERROR ${error.message} for input '${noteTitle}'`);
      return '(error)';
    }
  }

  /**
   * Wrap string with href onClick event to show note in editor,
   * using item.filename param.
   * @param {string} NPDateStr
   * @param {string} noteTitle
   * @returns {string} output
   */
  function makeNoteTitleWithOpenActionFromNPDateStr(NPDateStr, itemID) {
    try {
      const dateFilename = `${getAPIDateStrFromDisplayDateStr(NPDateStr)}.${DataStore.defaultFileExtension}`;
      // console.log(`makeNoteTitleWithOpenActionFromNPDateStr: - making notelink with ${NPDateStr} / ${dateFilename}`)
      // Pass request back to plugin, as a single object
      return `<a class="noteTitle sectionItem" {()=>onClickDashboardItem({itemID: '${itemID}', type: 'showNoteInEditorFromFilename', encodedFilename: '${encodeURIComponent(dateFilename)}', encodedContent: ''}}><i class="fa-regular fa-file-lines pad-right"></i> ${NPDateStr}</a>`;
    } catch (error) {
      console.log(`makeNoteTitleWithOpenActionFromNPDateStr: ERROR ${error.message} for input '${NPDateStr}'`);
      return '(error)';
    }
  }

  //--------------------------------------------------------------------------
  /**
   * Represents the main content for a single item within a section
   */
  function ItemNoteLink(inputObj) {
    const {
      item,
      thisSection
    } = inputObj;
    console.log(`ItemNoteLink for ${item.itemFilename}`);

    // compute the things we need later
    const noteTitle = item.itemNoteTitle;
    if (noteTitle && noteTitle !== thisSection.sectionFilename) {
      const encodedNoteTitle = encodeURIComponent(noteTitle);
      const dataObjectToPassToFunction = {
        itemID: 'fake',
        type: 'showNoteInEditorFromTitle',
        encodedFilename: encodedNoteTitle,
        encodedContent: ''
      };
      return /*#__PURE__*/React__default["default"].createElement("a", {
        className: "noteTitle sectionItem"
        // $FlowIgnore[cannot-resolve-name]
        ,
        onClick: () => onClickDashboardItem(dataObjectToPassToFunction)
      }, /*#__PURE__*/React__default["default"].createElement("i", {
        className: "fa-regular fa-file-lines pad-left pad-right"
      }), noteTitle);
    } else {
      console.log();
      return;
    }
  }

  /* eslint-disable no-undef */ //--------------------------------------------------------------------------
  /**
   * Represents a single item within a section, displaying its status, content, and actions.
   */
  function ItemRow(inputObj) {
    try {
      const {
        pluginData
      } = useAppContext();
      const config = pluginData.settings;
      // clo(config)

      const {
        item,
        thisSection
      } = inputObj;
      const itemType = item.itemType;
      const sectionType = thisSection.sectionType;
      console.log(`ItemRow for section ${sectionType}#${thisSection.ID}:${itemType}`);

      // -------------------------------------------------------
      if (itemType === 'review') {
        // Display a Project item
        const itemFilename = item.itemFilename;
        const encodedItemFilename = encodeRFC3986URIComponent(itemFilename);
        // console.log(`- 'review': ${itemFilename}`)
        const noteTitle = item.itemNoteTitle ?? '<no title>';
        // console.log(`- making notelink with ${itemFilename}, ${noteTitle}`)
        const folderNamePart = config.includeFolderName && getFolderFromFilename(itemFilename) !== '' ? `${getFolderFromFilename(itemFilename)} / ` : '';
        // console.log(`- folderNamePart = ${folderNamePart}`)

        const projectContent = `${folderNamePart}${makeNoteTitleWithOpenActionFromFilename(item, noteTitle)}`;
        // console.log(`- projectContent = ${projectContent}`)

        const dataObjectToPassToControlDialog = {
          OS: 'macOS',
          // TODO: NotePlan.environment.platform,
          itemID: item.ID,
          // $FlowIgnore(cannot-resolve-name)
          encodedTitle: encodeRFC3986URIComponent(projectContent)
        };

        // Pass request back to plugin, as a single object
        const dataObjToPassToOnClick = {
          itemID: item.ID,
          type: 'showNoteInEditorFromFilename',
          encodedFilename: encodedItemFilename,
          encodedContent: ''
        };
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemRow",
          id: item.ID,
          "data-section-type": sectionType
          // $FlowIgnore(cannot-resolve-name)
          ,
          "data-encoded-filename": encodeRFC3986URIComponent(itemFilename)
          // $FlowIgnore(cannot-resolve-name)
          ,
          "data-encoded-content": encodeRFC3986URIComponent(projectContent)
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: "reviewProject todo itemIcon"
        }, /*#__PURE__*/React__default["default"].createElement("i", {
          id: `${item.ID}I`,
          className: "fa-regular fa-circle-play"
        })), /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemContent sectionItem"
        }, folderNamePart, /*#__PURE__*/React__default["default"].createElement("a", {
          className: "noteTitle sectionItem",
          onClick: () => onClickDashboardItem(dataObjToPassToOnClick)
        }, /*#__PURE__*/React__default["default"].createElement("i", {
          className: "fa-regular fa-file-lines pad-right"
        }), noteTitle), /*#__PURE__*/React__default["default"].createElement("a", {
          className: "dialogTrigger"
          // $FlowIgnore(cannot-resolve-name)
          ,
          onClick: () => showProjectControlDialog(dataObjectToPassToControlDialog)
        }, /*#__PURE__*/React__default["default"].createElement("i", {
          className: "fa-light fa-edit pad-left"
        }))));
      }
      // -------------------------------------------------------
      else if (itemType === 'congrats') {
        // Display congratulatory message
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemRow",
          id: item.ID,
          "data-section-type": sectionType,
          "data-encoded-filename": "",
          "data-encoded-content": ""
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: "itemIcon checked"
        }, /*#__PURE__*/React__default["default"].createElement("i", {
          id: item.ID,
          className: "fa-regular fa-circle-check"
        })), /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemContent sectionItem"
        }, /*#__PURE__*/React__default["default"].createElement("a", {
          className: "content"
        }, /*#__PURE__*/React__default["default"].createElement("i", null, "Nothing to do: take a break ", /*#__PURE__*/React__default["default"].createElement("i", {
          className: "fa-regular fa-mug"
        })))));
      }
      // -------------------------------------------------------
      else if (itemType === 'filterIndicator') {
        // Display filter indicator
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemRow",
          id: item.ID,
          "data-section-type": sectionType,
          "data-encoded-filename": "",
          "data-encoded-content": ""
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: "itemIcon checked"
        }, /*#__PURE__*/React__default["default"].createElement("i", {
          id: item.ID,
          className: "fa-light fa-plus"
        })), /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemContent sectionItem"
        }, /*#__PURE__*/React__default["default"].createElement("a", {
          className: "content"
        }, /*#__PURE__*/React__default["default"].createElement("i", null, item.para.content))));
      }
      // -------------------------------------------------------
      else {
        // Display every other type of item
        if (!item.para) {
          console.log(`Info: No para passed with item ${thisSection.sectionType}/${thisSection.ID}`);
        }
        // compute the things we need later
        // const para: TParagraphForDashboard = item.para
        const divClassName = itemType === 'open' ? 'sectionItemTodo todo' : itemType === 'checklist' ? 'sectionItemChecklist todo' : itemType === 'congrats' ? 'checked' : '';
        const iconClassName = itemType === 'open' ? 'todo fa-regular fa-circle' : itemType === 'checklist' ? 'todo fa-regular fa-square' : itemType === 'congrats' ? 'fa-regular fa-circle-check' : '';
        const dataObjectToPassToControlDialog = {
          OS: 'macOS',
          // TODO: NotePlan.environment.platform,
          itemID: item.ID,
          sectionType: thisSection.sectionType,
          reschedOrMove: 'move',
          // TODO: reschedOrMove,
          itemType: 'task',
          noteType: item.noteType
        };
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemRow",
          id: item.ID,
          "data-section-type": sectionType
          // $FlowIgnore(cannot-resolve-name)
          ,
          "data-encoded-filename": encodeRFC3986URIComponent(item.para?.filename)
          // $FlowIgnore(cannot-resolve-name)
          ,
          "data-encoded-content": encodeRFC3986URIComponent(item.para?.content)
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: `${divClassName} itemIcon`
        }, /*#__PURE__*/React__default["default"].createElement("i", {
          id: `${item.ID}I`,
          className: `${iconClassName}`
        })), /*#__PURE__*/React__default["default"].createElement("div", {
          className: "sectionItemContent sectionItem"
        }, /*#__PURE__*/React__default["default"].createElement(ItemContent, {
          item: item
        }), config.includeTaskContext ? /*#__PURE__*/React__default["default"].createElement(ItemNoteLink, {
          item: item,
          thisSection: thisSection
        }) : null, /*#__PURE__*/React__default["default"].createElement("a", {
          className: "dialogTrigger"
          // $FlowIgnore(cannot-resolve-name)
          ,
          onClick: () => showItemControlDialog(dataObjectToPassToControlDialog)
        }, /*#__PURE__*/React__default["default"].createElement("i", {
          className: "fa-light fa-edit pad-left"
        }))));
      }
    } catch (error) {
      console.error(`ItemRow âï¸ERRORâï¸ ${error.message}`);
    }
  }

  /**
   * Wrap string with href onClick event to show note in editor,
   * using item.filename param.
   * @param {SectionItem} item's details
   * @param {string} noteTitle
   * @returns {string} output
   */
  function makeNoteTitleWithOpenActionFromFilename(item, noteTitle) {
    try {
      // console.log(`makeNoteTitleWithOpenActionFromFilename: - making notelink with ${item.filename}, ${noteTitle}`)
      // Pass request back to plugin, as a single object
      return `<a class="noteTitle sectionItem" onClick="onClickDashboardItem({itemID: '${item.ID}', type: 'showNoteInEditorFromFilename', encodedFilename: '${encodeURIComponent(item.itemFilename)}', encodedContent: ''})"><i class="fa-regular fa-file-lines pad-right"></i> ${noteTitle}</a>`;
    } catch (error) {
      console.error(`ItemRow::makeNoteTitleWithOpenActionFromFilename: âï¸ERRORâï¸  ${error.message} for input '${noteTitle}'`);
      return '(error)';
    }
  }

  //--------------------------------------------------------------------------
  /**
   * A grid layout for items within a section.
   */
  function ItemGrid(inputObj) {
    const {
      items,
      thisSection
    } = inputObj;
    useAppContext();
    console.log(`ItemGrid for section ${thisSection.sectionType}/${thisSection.ID}: ${items.length} items`);

    // // FIXME:
    // console.log('- reactSettings.filterPriorityItems = ' + String(reactSettings.filterPriorityItems))

    // const visibleItems = items?.map((item, index) => (
    //   !reactSettings.filterPriorityItems || item.para?.priority || 0 > 0
    //     ? <ItemRow key={index} item={item} thisSection={thisSection} />
    //     : null)) ?? []
    // const filteredOut = items.length - visibleItems.length
    // console.log(`- selected ${visibleItems.length} visible items, with ${String(filteredOut)} filtered out`)

    const visibleItems = items?.map((item, index) => /*#__PURE__*/React__default["default"].createElement(ItemRow, {
      key: index,
      item: item,
      thisSection: thisSection
    })) ?? [];

    // // TODO: equivalent of:
    // if (filteredOut > 0) {
    //   items.push({
    //     ID: `${thisSection.ID}-Filter`,
    //     itemType: 'filterIndicator', // TEST:
    //     itemFilename: '',
    //     noteType: 'Notes', // TEST:
    //     para: {
    //       content: `There are also ${filteredOut} lower-priority items currently hidden`,
    //       filename: '',
    //       type: '' // FIXME:
    //     }
    //   })
    // }

    return (
      /*#__PURE__*/
      // FIXME: find a way to include this <!--- Section ${String(sectionNumber)}: ${section.name} Items Grid --->`
      React__default["default"].createElement("div", {
        className: "sectionItemsGrid",
        id: `${thisSection.ID}-Section`
      }, visibleItems)
    );
  }

  //--------------------------------------------------------------------------
  /**
   * Represents a section within the dashboard, like Today, Yesterday, Projects, etc.
   */
  function Section(inputObj) {
    try {
      const {
        section
      } = inputObj;
      const items = section.sectionItems;
      const {
        pluginData
      } = useAppContext();
      const config = pluginData.settings;
      // clo(config)

      if (!section || !section.ID) {
        throw new Error(`âSection doesn't exist.`);
      } else if (!section.sectionItems || section.sectionItems.length === 0) {
        if (section.ID !== 0) {
          console.log(`Section: ${section.ID} / ${section.sectionType} doesn't have any sectionItems, so not displaying.`);
          return;
        } else {
          // As there are no items in first section, then add a congratulatory message
          console.log(`Section 0 doesn't have any sectionItems, so display congrats message`);
          items.push({
            ID: '0-Congrats',
            type: 'congrats',
            content: `Nothing to do: take a break <i class="fa-regular fa-mug"></i>`,
            // earlier tried fa-party-horn
            rawContent: ``,
            filename: ''
          });
        }
      } else {
        console.log(`Section: ${section.ID} / ${section.sectionType} with ${section.sectionItems.length} items`);
      }

      // Produce set of actionButtons, if present
      const buttons = section.actionButtons?.map((item, index) => /*#__PURE__*/React__default["default"].createElement(CommandButton, {
        key: index,
        button: item
      })) ?? [];

      // Filter down by priority (if desired)
      const filterPriorityItems = config?.filterPriorityItems ?? true;
      let maxPrioritySeen = 0;
      for (const i of items) {
        if (i.para?.priority && i.para.priority > maxPrioritySeen) {
          maxPrioritySeen = i.para.priority;
        }
      }
      console.log(`- config.filterPriorityItems = ${String(filterPriorityItems)}, maxPrioritySeen=${String(maxPrioritySeen)}`);
      const filteredItems = filterPriorityItems ? items.filter(f => (f.para?.priority ?? 0) >= maxPrioritySeen) : items.slice();
      const priorityFilteringHappening = items.length > filteredItems.length;
      console.log(`- After filter, ${String(filteredItems.length)} from ${String(items.length)} items (${String(priorityFilteringHappening)})`);

      // Now apply limit (if desired)
      const limit = config?.maxTasksToShowInSection ?? 20;
      const itemsToShow = filteredItems.slice(0, limit);
      // Caclculate how many are not shown: not as simple as 'items.length - itemsToShow.length'
      // because there can be a pre-filter in Overdue generation, given by section.totalCount
      const filteredOut = section.totalCount ? section.totalCount - itemsToShow.length : items.length - itemsToShow.length;
      const limitApplied = section.totalCount > itemsToShow.length;
      console.log(`- selected ${itemsToShow.length} visible items, with ${String(filteredOut)} filtered out (and potentially using maxTasksToShowInSection ${String(limit)})`);

      // Send an extra line if we've applied filtering/limit
      if (filteredOut > 0) {
        itemsToShow.push({
          ID: `${section.ID}-Filter`,
          itemType: 'filterIndicator',
          itemFilename: '',
          noteType: 'Notes',
          para: {
            content: `There are also ${filteredOut} ${priorityFilteringHappening ? 'lower-priority' : ''} items currently hidden`,
            filename: '',
            type: 'text' // for want of something else
          }
        });
      }

      // Insert items count
      let descriptionToUse = section.description;
      if (descriptionToUse.includes('{count}')) {
        if (limitApplied) {
          descriptionToUse = descriptionToUse.replace('{count}', `<span id='section${section.ID}Count'}>first ${String(itemsToShow.length)}</span>`);
        } else {
          descriptionToUse = descriptionToUse.replace('{count}', `<span id='section${section.ID}Count'}>${String(itemsToShow.length)}</span>`);
        }
      }
      if (descriptionToUse.includes('{totalCount}')) {
        descriptionToUse = descriptionToUse.replace('{totalCount}', `<span id='section${section.ID}TotalCount'}>${String(filteredOut)}</span>`);
      }
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "section"
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "sectionInfo"
      }, /*#__PURE__*/React__default["default"].createElement("span", {
        className: `${section.sectionTitleClass} sectionName`
      }, /*#__PURE__*/React__default["default"].createElement("i", {
        className: `sectionIcon ${section.FAIconClass}`
      }), section.name), ' ', /*#__PURE__*/React__default["default"].createElement("span", {
        className: "sectionDescription",
        dangerouslySetInnerHTML: {
          __html: descriptionToUse
        }
      }), buttons), /*#__PURE__*/React__default["default"].createElement(ItemGrid, {
        thisSection: inputObj.section,
        items: itemsToShow
      }));
    } catch (error) {
      console.log(`âï¸ERRORâï¸: ${error.message}`);
    }
  }

  // import { useAppContext } from './AppContext.jsx'

  /**
   * Dashboard component aggregating data and layout for the dashboard.
   */
  function Dashboard({
    pluginData
  }) {
    //   const { sendActionToPlugin, sendToPlugin, dispatch, pluginData }  = useAppContext()
    const {
      sections,
      lastUpdated
    } = pluginData;
    const dashboardContainerStyle = {
      maxWidth: '100vw',
      width: '100vw'
    };
    return /*#__PURE__*/React__default["default"].createElement("div", {
      style: dashboardContainerStyle
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "dashboard"
    }, /*#__PURE__*/React__default["default"].createElement(Header, {
      lastUpdated: lastUpdated
    }), sections.map((section, index) => /*#__PURE__*/React__default["default"].createElement(Section, {
      key: index,
      section: section
    }))), /*#__PURE__*/React__default["default"].createElement("dialog", {
      id: "itemControlDialog",
      className: "itemControlDialog",
      "aria-labelledby": "Actions Dialog",
      "aria-describedby": "Actions that can be taken on items"
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "dialogTitle"
    }, "From ", /*#__PURE__*/React__default["default"].createElement("i", {
      className: "pad-left pad-right fa-regular fa-file-lines"
    }), /*#__PURE__*/React__default["default"].createElement("b", null, /*#__PURE__*/React__default["default"].createElement("span", {
      id: "dialogItemNote"
    }, "?"))), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "dialogBody"
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "buttonGrid",
      id: "itemDialogButtons"
    }, /*#__PURE__*/React__default["default"].createElement("div", null, "For"), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "dialogDescription"
    }, /*#__PURE__*/React__default["default"].createElement("input", {
      type: "text",
      id: "dialogItemContent",
      className: "fullTextInput"
    }), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "updateItemContentButton",
      "data-control-str": "update"
    }, "Update")), /*#__PURE__*/React__default["default"].createElement("div", null, "Move to"), /*#__PURE__*/React__default["default"].createElement("div", {
      id: "itemControlDialogMoveControls"
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "t"
    }, "today"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+1d"
    }, "+1d"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+1b"
    }, "+1b"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+2d"
    }, "+2d"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+0w"
    }, "this week"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+1w"
    }, "+1w"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+2w"
    }, "+2w"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+0m"
    }, "this month"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "+0q"
    }, "this quarter")), /*#__PURE__*/React__default["default"].createElement("div", null, "Other controls"), /*#__PURE__*/React__default["default"].createElement("div", {
      id: "itemControlDialogOtherControls"
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "cancel"
    }, "Cancel"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "movetonote"
    }, "Move to ", /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-regular fa-file-lines"
    })), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "priup"
    }, /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-regular fa-arrow-up"
    }), " Priority"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "pridown"
    }, /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-regular fa-arrow-down"
    }), " Priority"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "tog"
    }, "Toggle Type"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "ct"
    }, "Complete Then"), /*#__PURE__*/React__default["default"].createElement("button", {
      className: "PCButton",
      "data-control-str": "unsched"
    }, "Unschedule")), /*#__PURE__*/React__default["default"].createElement("div", null), /*#__PURE__*/React__default["default"].createElement("div", null, /*#__PURE__*/React__default["default"].createElement("form", null, /*#__PURE__*/React__default["default"].createElement("button", {
      id: "closeButton",
      className: "mainButton"
    }, "Close")))))), /*#__PURE__*/React__default["default"].createElement("dialog", {
      id: "projectControlDialog",
      className: "projectControlDialog",
      "aria-labelledby": "Actions Dialog",
      "aria-describedby": "Actions that can be taken on projects"
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "dialogTitle"
    }, "For ", /*#__PURE__*/React__default["default"].createElement("i", {
      className: "pad-left pad-right fa-regular fa-file-lines"
    }), /*#__PURE__*/React__default["default"].createElement("b", null, /*#__PURE__*/React__default["default"].createElement("span", {
      id: "dialogProjectNote"
    }, "?"))), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "dialogBody"
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "buttonGrid",
      id: "projectDialogButtons"
    }, /*#__PURE__*/React__default["default"].createElement("div", null, "Project Reviews"), /*#__PURE__*/React__default["default"].createElement("div", {
      id: "projectControlDialogProjectControls"
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      "data-control-str": "finish"
    }, /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-regular fa-calendar-check"
    }), " Finish Review"), /*#__PURE__*/React__default["default"].createElement("button", {
      "data-control-str": "nr+1w"
    }, /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-solid fa-forward"
    }), " Skip 1w"), /*#__PURE__*/React__default["default"].createElement("button", {
      "data-control-str": "nr+2w"
    }, /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-solid fa-forward"
    }), " Skip 2w"), /*#__PURE__*/React__default["default"].createElement("button", {
      "data-control-str": "nr+1m"
    }, /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-solid fa-forward"
    }), " Skip 1m"), /*#__PURE__*/React__default["default"].createElement("button", {
      "data-control-str": "nr+1q"
    }, /*#__PURE__*/React__default["default"].createElement("i", {
      className: "fa-solid fa-forward"
    }), " Skip 1q")), /*#__PURE__*/React__default["default"].createElement("div", null), /*#__PURE__*/React__default["default"].createElement("div", null, /*#__PURE__*/React__default["default"].createElement("form", null, /*#__PURE__*/React__default["default"].createElement("button", {
      id: "closeButton",
      className: "mainButton"
    }, "Close")))))));
  }

  /****************************************************************************************************************************
   *                             WEBVIEW COMPONENT
   * This is your top-level React component. All other React components should be imported and included below
   ****************************************************************************************************************************/

  /****************************************************************************************************************************
   *                             CONSOLE LOGGING
   ****************************************************************************************************************************/
  // color this component's output differently in the console
  const consoleStyle = 'background: #222; color: #bada55'; //lime green
  const logDebug = (msg, ...args) => console.log(`${window.webkit ? '' : '%c'}${msg}`, consoleStyle, ...args);

  /**
   * Root element for the Plugin's React Tree
   * @param {any} data
   * @param {Function} dispatch - function to send data back to the Root Component and plugin
   */
  function WebView({
    data,
    dispatch
  }) {
    /****************************************************************************************************************************
     *                             HOOKS
     ****************************************************************************************************************************/

    // GENERALLY SPEAKING YOU DO NOT WANT TO USE STATE HOOKS IN THE WEBVIEW COMPONENT
    // because the plugin may need to know what changes were made so when it updates data, it will be consistent
    // otherwise when the plugin updates data, it will overwrite any changes made locally in the Webview
    // instead of using hooks here, save updates to data using:
    // dispatch('UPDATE_DATA', {...data,changesToData})
    // this will save the data at the Root React Component level, which will give the plugin access to this data also
    // sending this dispatch will re-render the Webview component with the new data

    /****************************************************************************************************************************
     *                             VARIABLES
     ****************************************************************************************************************************/

    // destructure all the startup data we expect from the plugin
    const {
      pluginData,
      debug
    } = data;
    if (!pluginData) throw new Error('WebView: pluginData must be called with an object');
    // logDebug(`Webview received pluginData:\n${JSON.stringify(pluginData, null, 2)}`)

    /****************************************************************************************************************************
     *                             HANDLERS
     ****************************************************************************************************************************/

    /****************************************************************************************************************************
     *                             EFFECTS
     ****************************************************************************************************************************/

    /**
     * When the data changes, console.log it so we know and scroll the window
     * Fires after components draw
     */
    React.useEffect(() => {
      // logDebug(`Webview: useEffect: data changed. data: ${JSON.stringify(data)}`)
      logDebug(`Webview: useEffect: data changed.`);
      if (data?.passThroughVars?.lastWindowScrollTop !== undefined && data.passThroughVars.lastWindowScrollTop !== window.scrollY) {
        debug && logDebug(`Webview: useEffect: data changed. Scrolling to ${String(data.lastWindowScrollTop)}`);
        window.scrollTo(0, data.passThroughVars.lastWindowScrollTop);
      }
    }, [data]);

    /**
     * Add the passthrough variables to the data object that will roundtrip to the plugin and come back in the data object
     * Because any data change coming from the plugin will force a React re-render, we can use this to store data that we want to persist
     * (e.g. lastWindowScrollTop)
     * @param {*} data
     * @returns
     */
    const addPassthroughVars = data => {
      const newData = {
        ...data
      };
      if (!newData.passThroughVars) newData.passThroughVars = {};
      newData.passThroughVars.lastWindowScrollTop = window.scrollY;
      return newData;
    };

    /**
     * Convenience function to send an action to the plugin and saving any passthrough data first in the Root data store
     * This is useful if you want to save data that you want to persist when the plugin sends data back to the Webview
     * For instance, saving where the scroll position was so that when data changes and the Webview re-renders, it can scroll back to where it was
     * @param {string} command
     * @param {any} dataToSend
     */
    const sendActionToPlugin = (command, dataToSend) => {
      const newData = addPassthroughVars(data); // save scroll position and other data in data object at root level
      dispatch('UPDATE_DATA', newData); // save the data at the Root React Component level, which will give the plugin access to this data also
      sendToPlugin([command, dataToSend]); // send action to plugin
    };

    /**
     * Send data back to the plugin to update the data in the plugin
     * This could cause a refresh of the Webview if the plugin sends back new data, so we want to save any passthrough data first
     * In that case, don't call this directly, use sendActionToPlugin() instead
     * @param {[command:string,data:any,additionalDetails:string]} param0
     */
    const sendToPlugin = ([command, data, additionalDetails = '']) => {
      if (!command) throw new Error('sendToPlugin: command must be called with a string');
      logDebug(`Webview: sendToPlugin: ${JSON.stringify(command)} ${additionalDetails}`, command, data, additionalDetails);
      if (!data) throw new Error('sendToPlugin: data must be called with an object');
      dispatch('SEND_TO_PLUGIN', [command, data], `WebView: sendToPlugin: ${String(command)} ${additionalDetails}`);
    };

    /**
     * Updates the pluginData with the provided new data (must be the whole pluginData object)
     *
     * @param {Object} newData - The new data to update the plugin with,
     * @param {string} messageForLog - An optional message to log with the update
     * @throws {Error} Throws an error if newData is not provided or if it does not have more keys than the current pluginData.
     * @return {void}
     */
    const updatePluginData = (newData, messageForLog) => {
      if (!newData) throw new Error('updatePluginData: newData must be called with an object');
      if (Object.keys(newData).length < Object.keys(pluginData).length) {
        throw new Error('updatePluginData: newData must be called with an object that has more keys than the current pluginData. You must send a full pluginData object');
      }
      const newFullData = {
        ...data,
        pluginData: newData
      };
      dispatch('UPDATE_DATA', newFullData, messageForLog); // save the data at the Root React Component level, which will give the plugin access to this data also
    };

    if (!pluginData.reactSettings) pluginData.reactSettings = {};

    /****************************************************************************************************************************
     *                             RENDER
     ****************************************************************************************************************************/

    return /*#__PURE__*/React__default["default"].createElement(AppProvider, {
      sendActionToPlugin: sendActionToPlugin,
      sendToPlugin: sendToPlugin,
      dispatch: dispatch,
      pluginData: pluginData,
      updatePluginData: updatePluginData
    }, /*#__PURE__*/React__default["default"].createElement(Dashboard, {
      pluginData: pluginData
    }));
  }

  exports.WebView = WebView;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, react);
Object.assign(typeof(globalThis) == "undefined" ? this : globalThis, WebViewBundle)
