var exports = (function (exports) {
  'use strict'

  async function chooseOption(title, options, defaultValue) {
    const { index } = await CommandBar.showOptions(
      options.map((option) => option.label),
      title,
    )
    return options[index]?.value ?? defaultValue
  }
  async function showMessage(title, okLabel = 'OK') {
    await CommandBar.showOptions([okLabel], title)
  }
  async function getInput(title, okLabel = 'OK') {
    return await CommandBar.showInput(title, okLabel)
  }

  var parser$1 = (function () {
    /*
     * Generated by PEG.js 0.8.0.
     *
     * http://pegjs.majda.cz/
     */
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child
      }

      ctor.prototype = parent.prototype
      child.prototype = new ctor()
    }

    function SyntaxError(message, expected, found, offset, line, column) {
      this.message = message
      this.expected = expected
      this.found = found
      this.offset = offset
      this.line = line
      this.column = column
      this.name = 'SyntaxError'
    }

    peg$subclass(SyntaxError, Error)

    function parse(input) {
      var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleFunctions = {
          start: peg$parsestart,
        },
        peg$startRuleFunction = peg$parsestart,
        peg$c1 = function () {
          return nodes
        },
        peg$c2 = peg$FAILED,
        peg$c3 = '#',
        peg$c4 = {
          type: 'literal',
          value: '#',
          description: '"#"',
        },
        peg$c5 = void 0,
        peg$c6 = {
          type: 'any',
          description: 'any character',
        },
        peg$c7 = '[',
        peg$c8 = {
          type: 'literal',
          value: '[',
          description: '"["',
        },
        peg$c9 = ']',
        peg$c10 = {
          type: 'literal',
          value: ']',
          description: '"]"',
        },
        peg$c11 = function (name) {
          addNode(node('ObjectPath', name, line, column))
        },
        peg$c12 = function (name) {
          addNode(node('ArrayPath', name, line, column))
        },
        peg$c13 = function (parts, name) {
          return parts.concat(name)
        },
        peg$c14 = function (name) {
          return [name]
        },
        peg$c15 = function (name) {
          return name
        },
        peg$c16 = '.',
        peg$c17 = {
          type: 'literal',
          value: '.',
          description: '"."',
        },
        peg$c18 = '=',
        peg$c19 = {
          type: 'literal',
          value: '=',
          description: '"="',
        },
        peg$c20 = function (key, value) {
          addNode(node('Assign', value, line, column, key))
        },
        peg$c21 = function (chars) {
          return chars.join('')
        },
        peg$c22 = function (node) {
          return node.value
        },
        peg$c23 = '"""',
        peg$c24 = {
          type: 'literal',
          value: '"""',
          description: '"\\"\\"\\""',
        },
        peg$c25 = null,
        peg$c26 = function (chars) {
          return node('String', chars.join(''), line, column)
        },
        peg$c27 = '"',
        peg$c28 = {
          type: 'literal',
          value: '"',
          description: '"\\""',
        },
        peg$c29 = "'''",
        peg$c30 = {
          type: 'literal',
          value: "'''",
          description: "\"'''\"",
        },
        peg$c31 = "'",
        peg$c32 = {
          type: 'literal',
          value: "'",
          description: '"\'"',
        },
        peg$c33 = function (char) {
          return char
        },
        peg$c34 = function (char) {
          return char
        },
        peg$c35 = '\\',
        peg$c36 = {
          type: 'literal',
          value: '\\',
          description: '"\\\\"',
        },
        peg$c37 = function () {
          return ''
        },
        peg$c38 = 'e',
        peg$c39 = {
          type: 'literal',
          value: 'e',
          description: '"e"',
        },
        peg$c40 = 'E',
        peg$c41 = {
          type: 'literal',
          value: 'E',
          description: '"E"',
        },
        peg$c42 = function (left, right) {
          return node('Float', parseFloat(left + 'e' + right), line, column)
        },
        peg$c43 = function (text) {
          return node('Float', parseFloat(text), line, column)
        },
        peg$c44 = '+',
        peg$c45 = {
          type: 'literal',
          value: '+',
          description: '"+"',
        },
        peg$c46 = function (digits) {
          return digits.join('')
        },
        peg$c47 = '-',
        peg$c48 = {
          type: 'literal',
          value: '-',
          description: '"-"',
        },
        peg$c49 = function (digits) {
          return '-' + digits.join('')
        },
        peg$c50 = function (text) {
          return node('Integer', parseInt(text, 10), line, column)
        },
        peg$c51 = 'true',
        peg$c52 = {
          type: 'literal',
          value: 'true',
          description: '"true"',
        },
        peg$c53 = function () {
          return node('Boolean', true, line, column)
        },
        peg$c54 = 'false',
        peg$c55 = {
          type: 'literal',
          value: 'false',
          description: '"false"',
        },
        peg$c56 = function () {
          return node('Boolean', false, line, column)
        },
        peg$c57 = function () {
          return node('Array', [], line, column)
        },
        peg$c58 = function (value) {
          return node('Array', value ? [value] : [], line, column)
        },
        peg$c59 = function (values) {
          return node('Array', values, line, column)
        },
        peg$c60 = function (values, value) {
          return node('Array', values.concat(value), line, column)
        },
        peg$c61 = function (value) {
          return value
        },
        peg$c62 = ',',
        peg$c63 = {
          type: 'literal',
          value: ',',
          description: '","',
        },
        peg$c64 = '{',
        peg$c65 = {
          type: 'literal',
          value: '{',
          description: '"{"',
        },
        peg$c66 = '}',
        peg$c67 = {
          type: 'literal',
          value: '}',
          description: '"}"',
        },
        peg$c68 = function (values) {
          return node('InlineTable', values, line, column)
        },
        peg$c69 = function (key, value) {
          return node('InlineTableValue', value, line, column, key)
        },
        peg$c70 = function (digits) {
          return '.' + digits
        },
        peg$c71 = function (date) {
          return date.join('')
        },
        peg$c72 = ':',
        peg$c73 = {
          type: 'literal',
          value: ':',
          description: '":"',
        },
        peg$c74 = function (time) {
          return time.join('')
        },
        peg$c75 = 'T',
        peg$c76 = {
          type: 'literal',
          value: 'T',
          description: '"T"',
        },
        peg$c77 = 'Z',
        peg$c78 = {
          type: 'literal',
          value: 'Z',
          description: '"Z"',
        },
        peg$c79 = function (date, time) {
          return node('Date', new Date(date + 'T' + time + 'Z'), line, column)
        },
        peg$c80 = function (date, time) {
          return node('Date', new Date(date + 'T' + time), line, column)
        },
        peg$c81 = /^[ \t]/,
        peg$c82 = {
          type: 'class',
          value: '[ \\t]',
          description: '[ \\t]',
        },
        peg$c83 = '\n',
        peg$c84 = {
          type: 'literal',
          value: '\n',
          description: '"\\n"',
        },
        peg$c85 = '\r',
        peg$c86 = {
          type: 'literal',
          value: '\r',
          description: '"\\r"',
        },
        peg$c87 = /^[0-9a-f]/i,
        peg$c88 = {
          type: 'class',
          value: '[0-9a-f]i',
          description: '[0-9a-f]i',
        },
        peg$c89 = /^[0-9]/,
        peg$c90 = {
          type: 'class',
          value: '[0-9]',
          description: '[0-9]',
        },
        peg$c91 = '_',
        peg$c92 = {
          type: 'literal',
          value: '_',
          description: '"_"',
        },
        peg$c93 = function () {
          return ''
        },
        peg$c94 = /^[A-Za-z0-9_\-]/,
        peg$c95 = {
          type: 'class',
          value: '[A-Za-z0-9_\\-]',
          description: '[A-Za-z0-9_\\-]',
        },
        peg$c96 = function (d) {
          return d.join('')
        },
        peg$c97 = '\\"',
        peg$c98 = {
          type: 'literal',
          value: '\\"',
          description: '"\\\\\\""',
        },
        peg$c99 = function () {
          return '"'
        },
        peg$c100 = '\\\\',
        peg$c101 = {
          type: 'literal',
          value: '\\\\',
          description: '"\\\\\\\\"',
        },
        peg$c102 = function () {
          return '\\'
        },
        peg$c103 = '\\b',
        peg$c104 = {
          type: 'literal',
          value: '\\b',
          description: '"\\\\b"',
        },
        peg$c105 = function () {
          return '\b'
        },
        peg$c106 = '\\t',
        peg$c107 = {
          type: 'literal',
          value: '\\t',
          description: '"\\\\t"',
        },
        peg$c108 = function () {
          return '\t'
        },
        peg$c109 = '\\n',
        peg$c110 = {
          type: 'literal',
          value: '\\n',
          description: '"\\\\n"',
        },
        peg$c111 = function () {
          return '\n'
        },
        peg$c112 = '\\f',
        peg$c113 = {
          type: 'literal',
          value: '\\f',
          description: '"\\\\f"',
        },
        peg$c114 = function () {
          return '\f'
        },
        peg$c115 = '\\r',
        peg$c116 = {
          type: 'literal',
          value: '\\r',
          description: '"\\\\r"',
        },
        peg$c117 = function () {
          return '\r'
        },
        peg$c118 = '\\U',
        peg$c119 = {
          type: 'literal',
          value: '\\U',
          description: '"\\\\U"',
        },
        peg$c120 = function (digits) {
          return convertCodePoint(digits.join(''))
        },
        peg$c121 = '\\u',
        peg$c122 = {
          type: 'literal',
          value: '\\u',
          description: '"\\\\u"',
        },
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = {
          line: 1,
          column: 1,
          seenCR: false,
        },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$cache = {},
        peg$result

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".',
          )
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule]
      }

      function line() {
        return peg$computePosDetails(peg$reportedPos).line
      }

      function column() {
        return peg$computePosDetails(peg$reportedPos).column
      }

      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch

          for (p = startPos; p < endPos; p++) {
            ch = input.charAt(p)

            if (ch === '\n') {
              if (!details.seenCR) {
                details.line++
              }

              details.column = 1
              details.seenCR = false
            } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
              details.line++
              details.column = 1
              details.seenCR = true
            } else {
              details.column++
              details.seenCR = false
            }
          }
        }

        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0
            peg$cachedPosDetails = {
              line: 1,
              column: 1,
              seenCR: false,
            }
          }

          advance(peg$cachedPosDetails, peg$cachedPos, pos)
          peg$cachedPos = pos
        }

        return peg$cachedPosDetails
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos
          peg$maxFailExpected = []
        }

        peg$maxFailExpected.push(expected)
      }

      function peg$buildException(message, expected, pos) {
        function cleanupExpected(expected) {
          var i = 1
          expected.sort(function (a, b) {
            if (a.description < b.description) {
              return -1
            } else if (a.description > b.description) {
              return 1
            } else {
              return 0
            }
          })

          while (i < expected.length) {
            if (expected[i - 1] === expected[i]) {
              expected.splice(i, 1)
            } else {
              i++
            }
          }
        }

        function buildMessage(expected, found) {
          function stringEscape(s) {
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase()
            }

            return s
              .replace(/\\/g, '\\\\')
              .replace(/"/g, '\\"')
              .replace(/\x08/g, '\\b')
              .replace(/\t/g, '\\t')
              .replace(/\n/g, '\\n')
              .replace(/\f/g, '\\f')
              .replace(/\r/g, '\\r')
              .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
                return '\\x0' + hex(ch)
              })
              .replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
                return '\\x' + hex(ch)
              })
              .replace(/[\u0180-\u0FFF]/g, function (ch) {
                return '\\u0' + hex(ch)
              })
              .replace(/[\u1080-\uFFFF]/g, function (ch) {
                return '\\u' + hex(ch)
              })
          }

          var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i

          for (i = 0; i < expected.length; i++) {
            expectedDescs[i] = expected[i].description
          }

          expectedDesc =
            expected.length > 1
              ? expectedDescs.slice(0, -1).join(', ') +
                ' or ' +
                expectedDescs[expected.length - 1]
              : expectedDescs[0]
          foundDesc = found ? '"' + stringEscape(found) + '"' : 'end of input'
          return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.'
        }

        var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null

        if (expected !== null) {
          cleanupExpected(expected)
        }

        return new SyntaxError(
          message !== null ? message : buildMessage(expected, found),
          expected,
          found,
          pos,
          posDetails.line,
          posDetails.column,
        )
      }

      function peg$parsestart() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 0,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseline()

        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parseline()
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c1()
        }

        s0 = s1
        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseline() {
        var s0, s1, s2, s3, s4, s5, s6
        var key = peg$currPos * 49 + 1,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseS()

        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parseS()
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpression()

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parseS()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parseS()
            }

            if (s3 !== peg$FAILED) {
              s4 = []
              s5 = peg$parsecomment()

              while (s5 !== peg$FAILED) {
                s4.push(s5)
                s5 = peg$parsecomment()
              }

              if (s4 !== peg$FAILED) {
                s5 = []
                s6 = peg$parseNL()

                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6)
                    s6 = peg$parseNL()
                  }
                } else {
                  s5 = peg$c2
                }

                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF()
                }

                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5]
                  s0 = s1
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = []
          s2 = peg$parseS()

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2)
              s2 = peg$parseS()
            }
          } else {
            s1 = peg$c2
          }

          if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parseNL()

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parseNL()
              }
            } else {
              s2 = peg$c2
            }

            if (s2 === peg$FAILED) {
              s2 = peg$parseEOF()
            }

            if (s2 !== peg$FAILED) {
              s1 = [s1, s2]
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }

          if (s0 === peg$FAILED) {
            s0 = peg$parseNL()
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseexpression() {
        var s0
        var key = peg$currPos * 49 + 2,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$parsecomment()

        if (s0 === peg$FAILED) {
          s0 = peg$parsepath()

          if (s0 === peg$FAILED) {
            s0 = peg$parsetablearray()

            if (s0 === peg$FAILED) {
              s0 = peg$parseassignment()
            }
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsecomment() {
        var s0, s1, s2, s3, s4, s5
        var key = peg$currPos * 49 + 3,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c3
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c4)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$currPos
          s4 = peg$currPos
          peg$silentFails++
          s5 = peg$parseNL()

          if (s5 === peg$FAILED) {
            s5 = peg$parseEOF()
          }

          peg$silentFails--

          if (s5 === peg$FAILED) {
            s4 = peg$c5
          } else {
            peg$currPos = s4
            s4 = peg$c2
          }

          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos)
              peg$currPos++
            } else {
              s5 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c6)
              }
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5]
              s3 = s4
            } else {
              peg$currPos = s3
              s3 = peg$c2
            }
          } else {
            peg$currPos = s3
            s3 = peg$c2
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$currPos
            s4 = peg$currPos
            peg$silentFails++
            s5 = peg$parseNL()

            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF()
            }

            peg$silentFails--

            if (s5 === peg$FAILED) {
              s4 = peg$c5
            } else {
              peg$currPos = s4
              s4 = peg$c2
            }

            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos)
                peg$currPos++
              } else {
                s5 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c6)
                }
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5]
                s3 = s4
              } else {
                peg$currPos = s3
                s3 = peg$c2
              }
            } else {
              peg$currPos = s3
              s3 = peg$c2
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = [s1, s2]
            s0 = s1
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsepath() {
        var s0, s1, s2, s3, s4, s5
        var key = peg$currPos * 49 + 4,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c8)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$parseS()

          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$parseS()
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parsetable_key()

            if (s3 !== peg$FAILED) {
              s4 = []
              s5 = peg$parseS()

              while (s5 !== peg$FAILED) {
                s4.push(s5)
                s5 = peg$parseS()
              }

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c9
                  peg$currPos++
                } else {
                  s5 = peg$FAILED

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10)
                  }
                }

                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0
                  s1 = peg$c11(s3)
                  s0 = s1
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsetablearray() {
        var s0, s1, s2, s3, s4, s5, s6, s7
        var key = peg$currPos * 49 + 5,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c8)
          }
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c7
            peg$currPos++
          } else {
            s2 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c8)
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parseS()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parseS()
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parsetable_key()

              if (s4 !== peg$FAILED) {
                s5 = []
                s6 = peg$parseS()

                while (s6 !== peg$FAILED) {
                  s5.push(s6)
                  s6 = peg$parseS()
                }

                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s6 = peg$c9
                    peg$currPos++
                  } else {
                    s6 = peg$FAILED

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10)
                    }
                  }

                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s7 = peg$c9
                      peg$currPos++
                    } else {
                      s7 = peg$FAILED

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10)
                      }
                    }

                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0
                      s1 = peg$c12(s4)
                      s0 = s1
                    } else {
                      peg$currPos = s0
                      s0 = peg$c2
                    }
                  } else {
                    peg$currPos = s0
                    s0 = peg$c2
                  }
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsetable_key() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 6,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parsedot_ended_table_key_part()

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parsedot_ended_table_key_part()
          }
        } else {
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parsetable_key_part()

          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c13(s1, s2)
            s0 = s1
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = peg$parsetable_key_part()

          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c14(s1)
          }

          s0 = s1
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsetable_key_part() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 7,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseS()

        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parseS()
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey()

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parseS()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parseS()
            }

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c15(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = []
          s2 = peg$parseS()

          while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parseS()
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key()

            if (s2 !== peg$FAILED) {
              s3 = []
              s4 = peg$parseS()

              while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$parseS()
              }

              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c15(s2)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsedot_ended_table_key_part() {
        var s0, s1, s2, s3, s4, s5, s6
        var key = peg$currPos * 49 + 8,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseS()

        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parseS()
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey()

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parseS()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parseS()
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16
                peg$currPos++
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c17)
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = []
                s6 = peg$parseS()

                while (s6 !== peg$FAILED) {
                  s5.push(s6)
                  s6 = peg$parseS()
                }

                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0
                  s1 = peg$c15(s2)
                  s0 = s1
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = []
          s2 = peg$parseS()

          while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parseS()
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key()

            if (s2 !== peg$FAILED) {
              s3 = []
              s4 = peg$parseS()

              while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$parseS()
              }

              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16
                  peg$currPos++
                } else {
                  s4 = peg$FAILED

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17)
                  }
                }

                if (s4 !== peg$FAILED) {
                  s5 = []
                  s6 = peg$parseS()

                  while (s6 !== peg$FAILED) {
                    s5.push(s6)
                    s6 = peg$parseS()
                  }

                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0
                    s1 = peg$c15(s2)
                    s0 = s1
                  } else {
                    peg$currPos = s0
                    s0 = peg$c2
                  }
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseassignment() {
        var s0, s1, s2, s3, s4, s5
        var key = peg$currPos * 49 + 9,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$parsekey()

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$parseS()

          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$parseS()
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c18
              peg$currPos++
            } else {
              s3 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c19)
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = []
              s5 = peg$parseS()

              while (s5 !== peg$FAILED) {
                s4.push(s5)
                s5 = peg$parseS()
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parsevalue()

                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0
                  s1 = peg$c20(s1, s5)
                  s0 = s1
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = peg$parsequoted_key()

          if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parseS()

            while (s3 !== peg$FAILED) {
              s2.push(s3)
              s3 = peg$parseS()
            }

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18
                peg$currPos++
              } else {
                s3 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c19)
                }
              }

              if (s3 !== peg$FAILED) {
                s4 = []
                s5 = peg$parseS()

                while (s5 !== peg$FAILED) {
                  s4.push(s5)
                  s5 = peg$parseS()
                }

                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue()

                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0
                    s1 = peg$c20(s1, s5)
                    s0 = s1
                  } else {
                    peg$currPos = s0
                    s0 = peg$c2
                  }
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsekey() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 10,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseASCII_BASIC()

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parseASCII_BASIC()
          }
        } else {
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c21(s1)
        }

        s0 = s1
        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsequoted_key() {
        var s0, s1
        var key = peg$currPos * 49 + 11,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$parsedouble_quoted_single_line_string()

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c22(s1)
        }

        s0 = s1

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = peg$parsesingle_quoted_single_line_string()

          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c22(s1)
          }

          s0 = s1
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsevalue() {
        var s0
        var key = peg$currPos * 49 + 12,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$parsestring()

        if (s0 === peg$FAILED) {
          s0 = peg$parsedatetime()

          if (s0 === peg$FAILED) {
            s0 = peg$parsefloat()

            if (s0 === peg$FAILED) {
              s0 = peg$parseinteger()

              if (s0 === peg$FAILED) {
                s0 = peg$parseboolean()

                if (s0 === peg$FAILED) {
                  s0 = peg$parsearray()

                  if (s0 === peg$FAILED) {
                    s0 = peg$parseinline_table()
                  }
                }
              }
            }
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsestring() {
        var s0
        var key = peg$currPos * 49 + 13,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$parsedouble_quoted_multiline_string()

        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_quoted_single_line_string()

          if (s0 === peg$FAILED) {
            s0 = peg$parsesingle_quoted_multiline_string()

            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_single_line_string()
            }
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsedouble_quoted_multiline_string() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 14,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.substr(peg$currPos, 3) === peg$c23) {
          s1 = peg$c23
          peg$currPos += 3
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c24)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL()

          if (s2 === peg$FAILED) {
            s2 = peg$c25
          }

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parsemultiline_string_char()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parsemultiline_string_char()
            }

            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s4 = peg$c23
                peg$currPos += 3
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c24)
                }
              }

              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c26(s3)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsedouble_quoted_single_line_string() {
        var s0, s1, s2, s3
        var key = peg$currPos * 49 + 15,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c27
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c28)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$parsestring_char()

          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$parsestring_char()
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c27
              peg$currPos++
            } else {
              s3 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c28)
              }
            }

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c26(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsesingle_quoted_multiline_string() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 16,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.substr(peg$currPos, 3) === peg$c29) {
          s1 = peg$c29
          peg$currPos += 3
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c30)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL()

          if (s2 === peg$FAILED) {
            s2 = peg$c25
          }

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parsemultiline_literal_char()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parsemultiline_literal_char()
            }

            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c29) {
                s4 = peg$c29
                peg$currPos += 3
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c30)
                }
              }

              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c26(s3)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsesingle_quoted_single_line_string() {
        var s0, s1, s2, s3
        var key = peg$currPos * 49 + 17,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c31
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c32)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$parseliteral_char()

          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$parseliteral_char()
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c31
              peg$currPos++
            } else {
              s3 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c32)
              }
            }

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c26(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsestring_char() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 18,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$parseESCAPED()

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = peg$currPos
          peg$silentFails++

          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c27
            peg$currPos++
          } else {
            s2 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c28)
            }
          }

          peg$silentFails--

          if (s2 === peg$FAILED) {
            s1 = peg$c5
          } else {
            peg$currPos = s1
            s1 = peg$c2
          }

          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos)
              peg$currPos++
            } else {
              s2 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c6)
              }
            }

            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c33(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseliteral_char() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 19,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$currPos
        peg$silentFails++

        if (input.charCodeAt(peg$currPos) === 39) {
          s2 = peg$c31
          peg$currPos++
        } else {
          s2 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c32)
          }
        }

        peg$silentFails--

        if (s2 === peg$FAILED) {
          s1 = peg$c5
        } else {
          peg$currPos = s1
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos)
            peg$currPos++
          } else {
            s2 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c6)
            }
          }

          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c33(s2)
            s0 = s1
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsemultiline_string_char() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 20,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$parseESCAPED()

        if (s0 === peg$FAILED) {
          s0 = peg$parsemultiline_string_delim()

          if (s0 === peg$FAILED) {
            s0 = peg$currPos
            s1 = peg$currPos
            peg$silentFails++

            if (input.substr(peg$currPos, 3) === peg$c23) {
              s2 = peg$c23
              peg$currPos += 3
            } else {
              s2 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c24)
              }
            }

            peg$silentFails--

            if (s2 === peg$FAILED) {
              s1 = peg$c5
            } else {
              peg$currPos = s1
              s1 = peg$c2
            }

            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos)
                peg$currPos++
              } else {
                s2 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c6)
                }
              }

              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c34(s2)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsemultiline_string_delim() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 21,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c35
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c36)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL()

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parseNLS()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parseNLS()
            }

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c37()
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsemultiline_literal_char() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 22,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$currPos
        peg$silentFails++

        if (input.substr(peg$currPos, 3) === peg$c29) {
          s2 = peg$c29
          peg$currPos += 3
        } else {
          s2 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c30)
          }
        }

        peg$silentFails--

        if (s2 === peg$FAILED) {
          s1 = peg$c5
        } else {
          peg$currPos = s1
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos)
            peg$currPos++
          } else {
            s2 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c6)
            }
          }

          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c33(s2)
            s0 = s1
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsefloat() {
        var s0, s1, s2, s3
        var key = peg$currPos * 49 + 23,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$parsefloat_text()

        if (s1 === peg$FAILED) {
          s1 = peg$parseinteger_text()
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 101) {
            s2 = peg$c38
            peg$currPos++
          } else {
            s2 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c39)
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 69) {
              s2 = peg$c40
              peg$currPos++
            } else {
              s2 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c41)
              }
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parseinteger_text()

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c42(s1, s3)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = peg$parsefloat_text()

          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c43(s1)
          }

          s0 = s1
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsefloat_text() {
        var s0, s1, s2, s3, s4, s5
        var key = peg$currPos * 49 + 24,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c45)
          }
        }

        if (s1 === peg$FAILED) {
          s1 = peg$c25
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos
          s3 = peg$parseDIGITS()

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16
              peg$currPos++
            } else {
              s4 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c17)
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGITS()

              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5]
                s2 = s3
              } else {
                peg$currPos = s2
                s2 = peg$c2
              }
            } else {
              peg$currPos = s2
              s2 = peg$c2
            }
          } else {
            peg$currPos = s2
            s2 = peg$c2
          }

          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c46(s2)
            s0 = s1
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47
            peg$currPos++
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c48)
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$currPos
            s3 = peg$parseDIGITS()

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16
                peg$currPos++
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c17)
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS()

                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5]
                  s2 = s3
                } else {
                  peg$currPos = s2
                  s2 = peg$c2
                }
              } else {
                peg$currPos = s2
                s2 = peg$c2
              }
            } else {
              peg$currPos = s2
              s2 = peg$c2
            }

            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c49(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseinteger() {
        var s0, s1
        var key = peg$currPos * 49 + 25,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$parseinteger_text()

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c50(s1)
        }

        s0 = s1
        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseinteger_text() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 26,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c45)
          }
        }

        if (s1 === peg$FAILED) {
          s1 = peg$c25
        }

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$parseDIGIT_OR_UNDER()

          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3)
              s3 = peg$parseDIGIT_OR_UNDER()
            }
          } else {
            s2 = peg$c2
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos
            peg$silentFails++

            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16
              peg$currPos++
            } else {
              s4 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c17)
              }
            }

            peg$silentFails--

            if (s4 === peg$FAILED) {
              s3 = peg$c5
            } else {
              peg$currPos = s3
              s3 = peg$c2
            }

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c46(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47
            peg$currPos++
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c48)
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parseDIGIT_OR_UNDER()

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parseDIGIT_OR_UNDER()
              }
            } else {
              s2 = peg$c2
            }

            if (s2 !== peg$FAILED) {
              s3 = peg$currPos
              peg$silentFails++

              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16
                peg$currPos++
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c17)
                }
              }

              peg$silentFails--

              if (s4 === peg$FAILED) {
                s3 = peg$c5
              } else {
                peg$currPos = s3
                s3 = peg$c2
              }

              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c49(s2)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseboolean() {
        var s0, s1
        var key = peg$currPos * 49 + 27,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.substr(peg$currPos, 4) === peg$c51) {
          s1 = peg$c51
          peg$currPos += 4
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c52)
          }
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c53()
        }

        s0 = s1

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.substr(peg$currPos, 5) === peg$c54) {
            s1 = peg$c54
            peg$currPos += 5
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c55)
            }
          }

          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c56()
          }

          s0 = s1
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsearray() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 28,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c8)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$parsearray_sep()

          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$parsearray_sep()
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c9
              peg$currPos++
            } else {
              s3 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c10)
              }
            }

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c57()
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7
            peg$currPos++
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c8)
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parsearray_value()

            if (s2 === peg$FAILED) {
              s2 = peg$c25
            }

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9
                peg$currPos++
              } else {
                s3 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10)
                }
              }

              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c58(s2)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos

            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7
              peg$currPos++
            } else {
              s1 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c8)
              }
            }

            if (s1 !== peg$FAILED) {
              s2 = []
              s3 = peg$parsearray_value_list()

              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3)
                  s3 = peg$parsearray_value_list()
                }
              } else {
                s2 = peg$c2
              }

              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9
                  peg$currPos++
                } else {
                  s3 = peg$FAILED

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10)
                  }
                }

                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0
                  s1 = peg$c59(s2)
                  s0 = s1
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7
                peg$currPos++
              } else {
                s1 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c8)
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = []
                s3 = peg$parsearray_value_list()

                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3)
                    s3 = peg$parsearray_value_list()
                  }
                } else {
                  s2 = peg$c2
                }

                if (s2 !== peg$FAILED) {
                  s3 = peg$parsearray_value()

                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s4 = peg$c9
                      peg$currPos++
                    } else {
                      s4 = peg$FAILED

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10)
                      }
                    }

                    if (s4 !== peg$FAILED) {
                      peg$reportedPos = s0
                      s1 = peg$c60(s2, s3)
                      s0 = s1
                    } else {
                      peg$currPos = s0
                      s0 = peg$c2
                    }
                  } else {
                    peg$currPos = s0
                    s0 = peg$c2
                  }
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            }
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsearray_value() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 29,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parsearray_sep()

        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parsearray_sep()
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue()

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parsearray_sep()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parsearray_sep()
            }

            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c61(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsearray_value_list() {
        var s0, s1, s2, s3, s4, s5, s6
        var key = peg$currPos * 49 + 30,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parsearray_sep()

        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parsearray_sep()
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue()

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parsearray_sep()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parsearray_sep()
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c62
                peg$currPos++
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c63)
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = []
                s6 = peg$parsearray_sep()

                while (s6 !== peg$FAILED) {
                  s5.push(s6)
                  s6 = peg$parsearray_sep()
                }

                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0
                  s1 = peg$c61(s2)
                  s0 = s1
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsearray_sep() {
        var s0
        var key = peg$currPos * 49 + 31,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$parseS()

        if (s0 === peg$FAILED) {
          s0 = peg$parseNL()

          if (s0 === peg$FAILED) {
            s0 = peg$parsecomment()
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseinline_table() {
        var s0, s1, s2, s3, s4, s5
        var key = peg$currPos * 49 + 32,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c64
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c65)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = []
          s3 = peg$parseS()

          while (s3 !== peg$FAILED) {
            s2.push(s3)
            s3 = peg$parseS()
          }

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parseinline_table_assignment()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parseinline_table_assignment()
            }

            if (s3 !== peg$FAILED) {
              s4 = []
              s5 = peg$parseS()

              while (s5 !== peg$FAILED) {
                s4.push(s5)
                s5 = peg$parseS()
              }

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s5 = peg$c66
                  peg$currPos++
                } else {
                  s5 = peg$FAILED

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c67)
                  }
                }

                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0
                  s1 = peg$c68(s3)
                  s0 = s1
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseinline_table_assignment() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10
        var key = peg$currPos * 49 + 33,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseS()

        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parseS()
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey()

          if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parseS()

            while (s4 !== peg$FAILED) {
              s3.push(s4)
              s4 = peg$parseS()
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s4 = peg$c18
                peg$currPos++
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c19)
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = []
                s6 = peg$parseS()

                while (s6 !== peg$FAILED) {
                  s5.push(s6)
                  s6 = peg$parseS()
                }

                if (s5 !== peg$FAILED) {
                  s6 = peg$parsevalue()

                  if (s6 !== peg$FAILED) {
                    s7 = []
                    s8 = peg$parseS()

                    while (s8 !== peg$FAILED) {
                      s7.push(s8)
                      s8 = peg$parseS()
                    }

                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s8 = peg$c62
                        peg$currPos++
                      } else {
                        s8 = peg$FAILED

                        if (peg$silentFails === 0) {
                          peg$fail(peg$c63)
                        }
                      }

                      if (s8 !== peg$FAILED) {
                        s9 = []
                        s10 = peg$parseS()

                        while (s10 !== peg$FAILED) {
                          s9.push(s10)
                          s10 = peg$parseS()
                        }

                        if (s9 !== peg$FAILED) {
                          peg$reportedPos = s0
                          s1 = peg$c69(s2, s6)
                          s0 = s1
                        } else {
                          peg$currPos = s0
                          s0 = peg$c2
                        }
                      } else {
                        peg$currPos = s0
                        s0 = peg$c2
                      }
                    } else {
                      peg$currPos = s0
                      s0 = peg$c2
                    }
                  } else {
                    peg$currPos = s0
                    s0 = peg$c2
                  }
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = []
          s2 = peg$parseS()

          while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parseS()
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey()

            if (s2 !== peg$FAILED) {
              s3 = []
              s4 = peg$parseS()

              while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$parseS()
              }

              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18
                  peg$currPos++
                } else {
                  s4 = peg$FAILED

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19)
                  }
                }

                if (s4 !== peg$FAILED) {
                  s5 = []
                  s6 = peg$parseS()

                  while (s6 !== peg$FAILED) {
                    s5.push(s6)
                    s6 = peg$parseS()
                  }

                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue()

                    if (s6 !== peg$FAILED) {
                      peg$reportedPos = s0
                      s1 = peg$c69(s2, s6)
                      s0 = s1
                    } else {
                      peg$currPos = s0
                      s0 = peg$c2
                    }
                  } else {
                    peg$currPos = s0
                    s0 = peg$c2
                  }
                } else {
                  peg$currPos = s0
                  s0 = peg$c2
                }
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsesecfragment() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 34,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c16
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c17)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseDIGITS()

          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c70(s2)
            s0 = s1
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsedate() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11
        var key = peg$currPos * 49 + 35,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$currPos
        s2 = peg$parseDIGIT_OR_UNDER()

        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER()

          if (s3 !== peg$FAILED) {
            s4 = peg$parseDIGIT_OR_UNDER()

            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER()

              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s6 = peg$c47
                  peg$currPos++
                } else {
                  s6 = peg$FAILED

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c48)
                  }
                }

                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDIGIT_OR_UNDER()

                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER()

                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 45) {
                        s9 = peg$c47
                        peg$currPos++
                      } else {
                        s9 = peg$FAILED

                        if (peg$silentFails === 0) {
                          peg$fail(peg$c48)
                        }
                      }

                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseDIGIT_OR_UNDER()

                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseDIGIT_OR_UNDER()

                          if (s11 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11]
                            s1 = s2
                          } else {
                            peg$currPos = s1
                            s1 = peg$c2
                          }
                        } else {
                          peg$currPos = s1
                          s1 = peg$c2
                        }
                      } else {
                        peg$currPos = s1
                        s1 = peg$c2
                      }
                    } else {
                      peg$currPos = s1
                      s1 = peg$c2
                    }
                  } else {
                    peg$currPos = s1
                    s1 = peg$c2
                  }
                } else {
                  peg$currPos = s1
                  s1 = peg$c2
                }
              } else {
                peg$currPos = s1
                s1 = peg$c2
              }
            } else {
              peg$currPos = s1
              s1 = peg$c2
            }
          } else {
            peg$currPos = s1
            s1 = peg$c2
          }
        } else {
          peg$currPos = s1
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c71(s1)
        }

        s0 = s1
        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsetime() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10
        var key = peg$currPos * 49 + 36,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$currPos
        s2 = peg$parseDIGIT_OR_UNDER()

        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER()

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72
              peg$currPos++
            } else {
              s4 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c73)
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER()

              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER()

                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72
                    peg$currPos++
                  } else {
                    s7 = peg$FAILED

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73)
                    }
                  }

                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER()

                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER()

                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment()

                        if (s10 === peg$FAILED) {
                          s10 = peg$c25
                        }

                        if (s10 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10]
                          s1 = s2
                        } else {
                          peg$currPos = s1
                          s1 = peg$c2
                        }
                      } else {
                        peg$currPos = s1
                        s1 = peg$c2
                      }
                    } else {
                      peg$currPos = s1
                      s1 = peg$c2
                    }
                  } else {
                    peg$currPos = s1
                    s1 = peg$c2
                  }
                } else {
                  peg$currPos = s1
                  s1 = peg$c2
                }
              } else {
                peg$currPos = s1
                s1 = peg$c2
              }
            } else {
              peg$currPos = s1
              s1 = peg$c2
            }
          } else {
            peg$currPos = s1
            s1 = peg$c2
          }
        } else {
          peg$currPos = s1
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c74(s1)
        }

        s0 = s1
        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsetime_with_offset() {
        var s0,
          s1,
          s2,
          s3,
          s4,
          s5,
          s6,
          s7,
          s8,
          s9,
          s10,
          s11,
          s12,
          s13,
          s14,
          s15,
          s16
        var key = peg$currPos * 49 + 37,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$currPos
        s2 = peg$parseDIGIT_OR_UNDER()

        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER()

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72
              peg$currPos++
            } else {
              s4 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c73)
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER()

              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER()

                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72
                    peg$currPos++
                  } else {
                    s7 = peg$FAILED

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73)
                    }
                  }

                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER()

                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER()

                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment()

                        if (s10 === peg$FAILED) {
                          s10 = peg$c25
                        }

                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s11 = peg$c47
                            peg$currPos++
                          } else {
                            s11 = peg$FAILED

                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48)
                            }
                          }

                          if (s11 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 43) {
                              s11 = peg$c44
                              peg$currPos++
                            } else {
                              s11 = peg$FAILED

                              if (peg$silentFails === 0) {
                                peg$fail(peg$c45)
                              }
                            }
                          }

                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseDIGIT_OR_UNDER()

                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseDIGIT_OR_UNDER()

                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 58) {
                                  s14 = peg$c72
                                  peg$currPos++
                                } else {
                                  s14 = peg$FAILED

                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c73)
                                  }
                                }

                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parseDIGIT_OR_UNDER()

                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parseDIGIT_OR_UNDER()

                                    if (s16 !== peg$FAILED) {
                                      s2 = [
                                        s2,
                                        s3,
                                        s4,
                                        s5,
                                        s6,
                                        s7,
                                        s8,
                                        s9,
                                        s10,
                                        s11,
                                        s12,
                                        s13,
                                        s14,
                                        s15,
                                        s16,
                                      ]
                                      s1 = s2
                                    } else {
                                      peg$currPos = s1
                                      s1 = peg$c2
                                    }
                                  } else {
                                    peg$currPos = s1
                                    s1 = peg$c2
                                  }
                                } else {
                                  peg$currPos = s1
                                  s1 = peg$c2
                                }
                              } else {
                                peg$currPos = s1
                                s1 = peg$c2
                              }
                            } else {
                              peg$currPos = s1
                              s1 = peg$c2
                            }
                          } else {
                            peg$currPos = s1
                            s1 = peg$c2
                          }
                        } else {
                          peg$currPos = s1
                          s1 = peg$c2
                        }
                      } else {
                        peg$currPos = s1
                        s1 = peg$c2
                      }
                    } else {
                      peg$currPos = s1
                      s1 = peg$c2
                    }
                  } else {
                    peg$currPos = s1
                    s1 = peg$c2
                  }
                } else {
                  peg$currPos = s1
                  s1 = peg$c2
                }
              } else {
                peg$currPos = s1
                s1 = peg$c2
              }
            } else {
              peg$currPos = s1
              s1 = peg$c2
            }
          } else {
            peg$currPos = s1
            s1 = peg$c2
          }
        } else {
          peg$currPos = s1
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c74(s1)
        }

        s0 = s1
        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parsedatetime() {
        var s0, s1, s2, s3, s4
        var key = peg$currPos * 49 + 38,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = peg$parsedate()

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 84) {
            s2 = peg$c75
            peg$currPos++
          } else {
            s2 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c76)
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parsetime()

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 90) {
                s4 = peg$c77
                peg$currPos++
              } else {
                s4 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c78)
                }
              }

              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c79(s1, s3)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = peg$parsedate()

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75
              peg$currPos++
            } else {
              s2 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c76)
              }
            }

            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime_with_offset()

              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c80(s1, s3)
                s0 = s1
              } else {
                peg$currPos = s0
                s0 = peg$c2
              }
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseS() {
        var s0
        var key = peg$currPos * 49 + 39,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        if (peg$c81.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s0 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c82)
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseNL() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 40,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c83
          peg$currPos++
        } else {
          s0 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c84)
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c85
            peg$currPos++
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c86)
            }
          }

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s2 = peg$c83
              peg$currPos++
            } else {
              s2 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c84)
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = [s1, s2]
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseNLS() {
        var s0
        var key = peg$currPos * 49 + 41,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$parseNL()

        if (s0 === peg$FAILED) {
          s0 = peg$parseS()
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseEOF() {
        var s0, s1
        var key = peg$currPos * 49 + 42,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        peg$silentFails++

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c6)
          }
        }

        peg$silentFails--

        if (s1 === peg$FAILED) {
          s0 = peg$c5
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseHEX() {
        var s0
        var key = peg$currPos * 49 + 43,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        if (peg$c87.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s0 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c88)
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseDIGIT_OR_UNDER() {
        var s0, s1
        var key = peg$currPos * 49 + 44,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        if (peg$c89.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s0 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c90)
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.charCodeAt(peg$currPos) === 95) {
            s1 = peg$c91
            peg$currPos++
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c92)
            }
          }

          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c93()
          }

          s0 = s1
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseASCII_BASIC() {
        var s0
        var key = peg$currPos * 49 + 45,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        if (peg$c94.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s0 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c95)
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseDIGITS() {
        var s0, s1, s2
        var key = peg$currPos * 49 + 46,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseDIGIT_OR_UNDER()

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parseDIGIT_OR_UNDER()
          }
        } else {
          s1 = peg$c2
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c96(s1)
        }

        s0 = s1
        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseESCAPED() {
        var s0, s1
        var key = peg$currPos * 49 + 47,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.substr(peg$currPos, 2) === peg$c97) {
          s1 = peg$c97
          peg$currPos += 2
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c98)
          }
        }

        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0
          s1 = peg$c99()
        }

        s0 = s1

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.substr(peg$currPos, 2) === peg$c100) {
            s1 = peg$c100
            peg$currPos += 2
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c101)
            }
          }

          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c102()
          }

          s0 = s1

          if (s0 === peg$FAILED) {
            s0 = peg$currPos

            if (input.substr(peg$currPos, 2) === peg$c103) {
              s1 = peg$c103
              peg$currPos += 2
            } else {
              s1 = peg$FAILED

              if (peg$silentFails === 0) {
                peg$fail(peg$c104)
              }
            }

            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c105()
            }

            s0 = s1

            if (s0 === peg$FAILED) {
              s0 = peg$currPos

              if (input.substr(peg$currPos, 2) === peg$c106) {
                s1 = peg$c106
                peg$currPos += 2
              } else {
                s1 = peg$FAILED

                if (peg$silentFails === 0) {
                  peg$fail(peg$c107)
                }
              }

              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0
                s1 = peg$c108()
              }

              s0 = s1

              if (s0 === peg$FAILED) {
                s0 = peg$currPos

                if (input.substr(peg$currPos, 2) === peg$c109) {
                  s1 = peg$c109
                  peg$currPos += 2
                } else {
                  s1 = peg$FAILED

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c110)
                  }
                }

                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0
                  s1 = peg$c111()
                }

                s0 = s1

                if (s0 === peg$FAILED) {
                  s0 = peg$currPos

                  if (input.substr(peg$currPos, 2) === peg$c112) {
                    s1 = peg$c112
                    peg$currPos += 2
                  } else {
                    s1 = peg$FAILED

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c113)
                    }
                  }

                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0
                    s1 = peg$c114()
                  }

                  s0 = s1

                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos

                    if (input.substr(peg$currPos, 2) === peg$c115) {
                      s1 = peg$c115
                      peg$currPos += 2
                    } else {
                      s1 = peg$FAILED

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c116)
                      }
                    }

                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0
                      s1 = peg$c117()
                    }

                    s0 = s1

                    if (s0 === peg$FAILED) {
                      s0 = peg$parseESCAPED_UNICODE()
                    }
                  }
                }
              }
            }
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      function peg$parseESCAPED_UNICODE() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10
        var key = peg$currPos * 49 + 48,
          cached = peg$cache[key]

        if (cached) {
          peg$currPos = cached.nextPos
          return cached.result
        }

        s0 = peg$currPos

        if (input.substr(peg$currPos, 2) === peg$c118) {
          s1 = peg$c118
          peg$currPos += 2
        } else {
          s1 = peg$FAILED

          if (peg$silentFails === 0) {
            peg$fail(peg$c119)
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos
          s3 = peg$parseHEX()

          if (s3 !== peg$FAILED) {
            s4 = peg$parseHEX()

            if (s4 !== peg$FAILED) {
              s5 = peg$parseHEX()

              if (s5 !== peg$FAILED) {
                s6 = peg$parseHEX()

                if (s6 !== peg$FAILED) {
                  s7 = peg$parseHEX()

                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseHEX()

                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseHEX()

                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseHEX()

                        if (s10 !== peg$FAILED) {
                          s3 = [s3, s4, s5, s6, s7, s8, s9, s10]
                          s2 = s3
                        } else {
                          peg$currPos = s2
                          s2 = peg$c2
                        }
                      } else {
                        peg$currPos = s2
                        s2 = peg$c2
                      }
                    } else {
                      peg$currPos = s2
                      s2 = peg$c2
                    }
                  } else {
                    peg$currPos = s2
                    s2 = peg$c2
                  }
                } else {
                  peg$currPos = s2
                  s2 = peg$c2
                }
              } else {
                peg$currPos = s2
                s2 = peg$c2
              }
            } else {
              peg$currPos = s2
              s2 = peg$c2
            }
          } else {
            peg$currPos = s2
            s2 = peg$c2
          }

          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0
            s1 = peg$c120(s2)
            s0 = s1
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        } else {
          peg$currPos = s0
          s0 = peg$c2
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos

          if (input.substr(peg$currPos, 2) === peg$c121) {
            s1 = peg$c121
            peg$currPos += 2
          } else {
            s1 = peg$FAILED

            if (peg$silentFails === 0) {
              peg$fail(peg$c122)
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$currPos
            s3 = peg$parseHEX()

            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX()

              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX()

                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX()

                  if (s6 !== peg$FAILED) {
                    s3 = [s3, s4, s5, s6]
                    s2 = s3
                  } else {
                    peg$currPos = s2
                    s2 = peg$c2
                  }
                } else {
                  peg$currPos = s2
                  s2 = peg$c2
                }
              } else {
                peg$currPos = s2
                s2 = peg$c2
              }
            } else {
              peg$currPos = s2
              s2 = peg$c2
            }

            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0
              s1 = peg$c120(s2)
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$c2
            }
          } else {
            peg$currPos = s0
            s0 = peg$c2
          }
        }

        peg$cache[key] = {
          nextPos: peg$currPos,
          result: s0,
        }
        return s0
      }

      var nodes = []

      function genError(err, line, col) {
        var ex = new Error(err)
        ex.line = line
        ex.column = col
        throw ex
      }

      function addNode(node) {
        nodes.push(node)
      }

      function node(type, value, line, column, key) {
        var obj = {
          type: type,
          value: value,
          line: line(),
          column: column(),
        }
        if (key) obj.key = key
        return obj
      }

      function convertCodePoint(str, line, col) {
        var num = parseInt('0x' + str)

        if (
          !isFinite(num) ||
          Math.floor(num) != num ||
          num < 0 ||
          num > 0x10ffff ||
          (num > 0xd7ff && num < 0xe000)
        ) {
          genError('Invalid Unicode escape code: ' + str, line, col)
        } else {
          return fromCodePoint(num)
        }
      }

      function fromCodePoint() {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length

        if (!length) {
          return ''
        }

        var result = ''

        while (++index < length) {
          var codePoint = Number(arguments[index])

          if (codePoint <= 0xffff) {
            // BMP code point
            codeUnits.push(codePoint)
          } else {
            // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xd800
            lowSurrogate = (codePoint % 0x400) + 0xdc00
            codeUnits.push(highSurrogate, lowSurrogate)
          }

          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
            result += String.fromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }

        return result
      }

      peg$result = peg$startRuleFunction()

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({
            type: 'end',
            description: 'end of input',
          })
        }

        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos)
      }
    }

    return {
      SyntaxError: SyntaxError,
      parse: parse,
    }
  })()

  function compile(nodes) {
    var assignedPaths = []
    var valueAssignments = []
    var currentPath = ''
    var data = Object.create(null)
    var context = data
    return reduce(nodes)

    function reduce(nodes) {
      var node

      for (var i = 0; i < nodes.length; i++) {
        node = nodes[i]

        switch (node.type) {
          case 'Assign':
            assign(node)
            break

          case 'ObjectPath':
            setPath(node)
            break

          case 'ArrayPath':
            addTableArray(node)
            break
        }
      }

      return data
    }

    function genError(err, line, col) {
      var ex = new Error(err)
      ex.line = line
      ex.column = col
      throw ex
    }

    function assign(node) {
      var key = node.key
      var value = node.value
      var line = node.line
      var column = node.column
      var fullPath

      if (currentPath) {
        fullPath = currentPath + '.' + key
      } else {
        fullPath = key
      }

      if (typeof context[key] !== 'undefined') {
        genError(
          "Cannot redefine existing key '" + fullPath + "'.",
          line,
          column,
        )
      }

      context[key] = reduceValueNode(value)

      if (!pathAssigned(fullPath)) {
        assignedPaths.push(fullPath)
        valueAssignments.push(fullPath)
      }
    }

    function pathAssigned(path) {
      return assignedPaths.indexOf(path) !== -1
    }

    function reduceValueNode(node) {
      if (node.type === 'Array') {
        return reduceArrayWithTypeChecking(node.value)
      } else if (node.type === 'InlineTable') {
        return reduceInlineTableNode(node.value)
      } else {
        return node.value
      }
    }

    function reduceInlineTableNode(values) {
      var obj = Object.create(null)

      for (var i = 0; i < values.length; i++) {
        var val = values[i]

        if (val.value.type === 'InlineTable') {
          obj[val.key] = reduceInlineTableNode(val.value.value)
        } else if (val.type === 'InlineTableValue') {
          obj[val.key] = reduceValueNode(val.value)
        }
      }

      return obj
    }

    function setPath(node) {
      var path = node.value
      var quotedPath = path.map(quoteDottedString).join('.')
      var line = node.line
      var column = node.column

      if (pathAssigned(quotedPath)) {
        genError("Cannot redefine existing key '" + path + "'.", line, column)
      }

      assignedPaths.push(quotedPath)
      context = deepRef(data, path, Object.create(null), line, column)
      currentPath = path
    }

    function addTableArray(node) {
      var path = node.value
      var quotedPath = path.map(quoteDottedString).join('.')
      var line = node.line
      var column = node.column

      if (!pathAssigned(quotedPath)) {
        assignedPaths.push(quotedPath)
      }

      assignedPaths = assignedPaths.filter(function (p) {
        return p.indexOf(quotedPath) !== 0
      })
      assignedPaths.push(quotedPath)
      context = deepRef(data, path, [], line, column)
      currentPath = quotedPath

      if (context instanceof Array) {
        var newObj = Object.create(null)
        context.push(newObj)
        context = newObj
      } else {
        genError("Cannot redefine existing key '" + path + "'.", line, column)
      }
    } // Given a path 'a.b.c', create (as necessary) `start.a`,
    // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.
    // If `a` or `b` are arrays and have items in them, the last item in the
    // array is used as the context for the next sub-path.

    function deepRef(start, keys, value, line, column) {
      var traversed = []
      var traversedPath = ''
      keys.join('.')
      var ctx = start

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i]
        traversed.push(key)
        traversedPath = traversed.join('.')

        if (typeof ctx[key] === 'undefined') {
          if (i === keys.length - 1) {
            ctx[key] = value
          } else {
            ctx[key] = Object.create(null)
          }
        } else if (
          i !== keys.length - 1 &&
          valueAssignments.indexOf(traversedPath) > -1
        ) {
          // already a non-object value at key, can't be used as part of a new path
          genError(
            "Cannot redefine existing key '" + traversedPath + "'.",
            line,
            column,
          )
        }

        ctx = ctx[key]

        if (ctx instanceof Array && ctx.length && i < keys.length - 1) {
          ctx = ctx[ctx.length - 1]
        }
      }

      return ctx
    }

    function reduceArrayWithTypeChecking(array) {
      // Ensure that all items in the array are of the same type
      var firstType = null

      for (var i = 0; i < array.length; i++) {
        var node = array[i]

        if (firstType === null) {
          firstType = node.type
        } else {
          if (node.type !== firstType) {
            genError(
              'Cannot add value of type ' +
                node.type +
                ' to array of type ' +
                firstType +
                '.',
              node.line,
              node.column,
            )
          }
        }
      } // Recursively reduce array of nodes into array of the nodes' values

      return array.map(reduceValueNode)
    }

    function quoteDottedString(str) {
      if (str.indexOf('.') > -1) {
        return '"' + str + '"'
      } else {
        return str
      }
    }
  }

  var compiler$1 = {
    compile: compile,
  }

  var parser = parser$1

  var compiler = compiler$1

  var toml = {
    parse: function (input) {
      var nodes = parser.parse(input.toString())
      return compiler.compile(nodes)
    },
  }

  // This is a generated file. Do not edit.
  var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/
  var ID_Start =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/
  var ID_Continue =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  var unicode = {
    Space_Separator: Space_Separator,
    ID_Start: ID_Start,
    ID_Continue: ID_Continue,
  }
  var util = {
    isSpaceSeparator(c) {
      return typeof c === 'string' && unicode.Space_Separator.test(c)
    },

    isIdStartChar(c) {
      return (
        typeof c === 'string' &&
        ((c >= 'a' && c <= 'z') ||
          (c >= 'A' && c <= 'Z') ||
          c === '$' ||
          c === '_' ||
          unicode.ID_Start.test(c))
      )
    },

    isIdContinueChar(c) {
      return (
        typeof c === 'string' &&
        ((c >= 'a' && c <= 'z') ||
          (c >= 'A' && c <= 'Z') ||
          (c >= '0' && c <= '9') ||
          c === '$' ||
          c === '_' ||
          c === '\u200C' ||
          c === '\u200D' ||
          unicode.ID_Continue.test(c))
      )
    },

    isDigit(c) {
      return typeof c === 'string' && /[0-9]/.test(c)
    },

    isHexDigit(c) {
      return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
    },
  }
  let source
  let parseState
  let stack
  let pos
  let line
  let column
  let token
  let key
  let root

  var parse$2 = function parse(text, reviver) {
    source = String(text)
    parseState = 'start'
    stack = []
    pos = 0
    line = 1
    column = 0
    token = undefined
    key = undefined
    root = undefined

    do {
      token = lex() // This code is unreachable.
      // if (!parseStates[parseState]) {
      //     throw invalidParseState()
      // }

      parseStates[parseState]()
    } while (token.type !== 'eof')

    if (typeof reviver === 'function') {
      return internalize(
        {
          '': root,
        },
        '',
        reviver,
      )
    }

    return root
  }

  function internalize(holder, name, reviver) {
    const value = holder[name]

    if (value != null && typeof value === 'object') {
      for (const key in value) {
        const replacement = internalize(value, key, reviver)

        if (replacement === undefined) {
          delete value[key]
        } else {
          value[key] = replacement
        }
      }
    }

    return reviver.call(holder, name, value)
  }

  let lexState
  let buffer
  let doubleQuote
  let sign
  let c

  function lex() {
    lexState = 'default'
    buffer = ''
    doubleQuote = false
    sign = 1

    for (;;) {
      c = peek() // This code is unreachable.
      // if (!lexStates[lexState]) {
      //     throw invalidLexState(lexState)
      // }

      const token = lexStates[lexState]()

      if (token) {
        return token
      }
    }
  }

  function peek() {
    if (source[pos]) {
      return String.fromCodePoint(source.codePointAt(pos))
    }
  }

  function read() {
    const c = peek()

    if (c === '\n') {
      line++
      column = 0
    } else if (c) {
      column += c.length
    } else {
      column++
    }

    if (c) {
      pos += c.length
    }

    return c
  }

  const lexStates = {
    default() {
      switch (c) {
        case '\t':
        case '\v':
        case '\f':
        case ' ':
        case '\u00A0':
        case '\uFEFF':
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
          read()
          return

        case '/':
          read()
          lexState = 'comment'
          return

        case undefined:
          read()
          return newToken('eof')
      }

      if (util.isSpaceSeparator(c)) {
        read()
        return
      } // This code is unreachable.
      // if (!lexStates[parseState]) {
      //     throw invalidLexState(parseState)
      // }

      return lexStates[parseState]()
    },

    comment() {
      switch (c) {
        case '*':
          read()
          lexState = 'multiLineComment'
          return

        case '/':
          read()
          lexState = 'singleLineComment'
          return
      }

      throw invalidChar(read())
    },

    multiLineComment() {
      switch (c) {
        case '*':
          read()
          lexState = 'multiLineCommentAsterisk'
          return

        case undefined:
          throw invalidChar(read())
      }

      read()
    },

    multiLineCommentAsterisk() {
      switch (c) {
        case '*':
          read()
          return

        case '/':
          read()
          lexState = 'default'
          return

        case undefined:
          throw invalidChar(read())
      }

      read()
      lexState = 'multiLineComment'
    },

    singleLineComment() {
      switch (c) {
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
          read()
          lexState = 'default'
          return

        case undefined:
          read()
          return newToken('eof')
      }

      read()
    },

    value() {
      switch (c) {
        case '{':
        case '[':
          return newToken('punctuator', read())

        case 'n':
          read()
          literal('ull')
          return newToken('null', null)

        case 't':
          read()
          literal('rue')
          return newToken('boolean', true)

        case 'f':
          read()
          literal('alse')
          return newToken('boolean', false)

        case '-':
        case '+':
          if (read() === '-') {
            sign = -1
          }

          lexState = 'sign'
          return

        case '.':
          buffer = read()
          lexState = 'decimalPointLeading'
          return

        case '0':
          buffer = read()
          lexState = 'zero'
          return

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          buffer = read()
          lexState = 'decimalInteger'
          return

        case 'I':
          read()
          literal('nfinity')
          return newToken('numeric', Infinity)

        case 'N':
          read()
          literal('aN')
          return newToken('numeric', NaN)

        case '"':
        case "'":
          doubleQuote = read() === '"'
          buffer = ''
          lexState = 'string'
          return
      }

      throw invalidChar(read())
    },

    identifierNameStartEscape() {
      if (c !== 'u') {
        throw invalidChar(read())
      }

      read()
      const u = unicodeEscape()

      switch (u) {
        case '$':
        case '_':
          break

        default:
          if (!util.isIdStartChar(u)) {
            throw invalidIdentifier()
          }

          break
      }

      buffer += u
      lexState = 'identifierName'
    },

    identifierName() {
      switch (c) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
          buffer += read()
          return

        case '\\':
          read()
          lexState = 'identifierNameEscape'
          return
      }

      if (util.isIdContinueChar(c)) {
        buffer += read()
        return
      }

      return newToken('identifier', buffer)
    },

    identifierNameEscape() {
      if (c !== 'u') {
        throw invalidChar(read())
      }

      read()
      const u = unicodeEscape()

      switch (u) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
          break

        default:
          if (!util.isIdContinueChar(u)) {
            throw invalidIdentifier()
          }

          break
      }

      buffer += u
      lexState = 'identifierName'
    },

    sign() {
      switch (c) {
        case '.':
          buffer = read()
          lexState = 'decimalPointLeading'
          return

        case '0':
          buffer = read()
          lexState = 'zero'
          return

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          buffer = read()
          lexState = 'decimalInteger'
          return

        case 'I':
          read()
          literal('nfinity')
          return newToken('numeric', sign * Infinity)

        case 'N':
          read()
          literal('aN')
          return newToken('numeric', NaN)
      }

      throw invalidChar(read())
    },

    zero() {
      switch (c) {
        case '.':
          buffer += read()
          lexState = 'decimalPoint'
          return

        case 'e':
        case 'E':
          buffer += read()
          lexState = 'decimalExponent'
          return

        case 'x':
        case 'X':
          buffer += read()
          lexState = 'hexadecimal'
          return
      }

      return newToken('numeric', sign * 0)
    },

    decimalInteger() {
      switch (c) {
        case '.':
          buffer += read()
          lexState = 'decimalPoint'
          return

        case 'e':
        case 'E':
          buffer += read()
          lexState = 'decimalExponent'
          return
      }

      if (util.isDigit(c)) {
        buffer += read()
        return
      }

      return newToken('numeric', sign * Number(buffer))
    },

    decimalPointLeading() {
      if (util.isDigit(c)) {
        buffer += read()
        lexState = 'decimalFraction'
        return
      }

      throw invalidChar(read())
    },

    decimalPoint() {
      switch (c) {
        case 'e':
        case 'E':
          buffer += read()
          lexState = 'decimalExponent'
          return
      }

      if (util.isDigit(c)) {
        buffer += read()
        lexState = 'decimalFraction'
        return
      }

      return newToken('numeric', sign * Number(buffer))
    },

    decimalFraction() {
      switch (c) {
        case 'e':
        case 'E':
          buffer += read()
          lexState = 'decimalExponent'
          return
      }

      if (util.isDigit(c)) {
        buffer += read()
        return
      }

      return newToken('numeric', sign * Number(buffer))
    },

    decimalExponent() {
      switch (c) {
        case '+':
        case '-':
          buffer += read()
          lexState = 'decimalExponentSign'
          return
      }

      if (util.isDigit(c)) {
        buffer += read()
        lexState = 'decimalExponentInteger'
        return
      }

      throw invalidChar(read())
    },

    decimalExponentSign() {
      if (util.isDigit(c)) {
        buffer += read()
        lexState = 'decimalExponentInteger'
        return
      }

      throw invalidChar(read())
    },

    decimalExponentInteger() {
      if (util.isDigit(c)) {
        buffer += read()
        return
      }

      return newToken('numeric', sign * Number(buffer))
    },

    hexadecimal() {
      if (util.isHexDigit(c)) {
        buffer += read()
        lexState = 'hexadecimalInteger'
        return
      }

      throw invalidChar(read())
    },

    hexadecimalInteger() {
      if (util.isHexDigit(c)) {
        buffer += read()
        return
      }

      return newToken('numeric', sign * Number(buffer))
    },

    string() {
      switch (c) {
        case '\\':
          read()
          buffer += escape()
          return

        case '"':
          if (doubleQuote) {
            read()
            return newToken('string', buffer)
          }

          buffer += read()
          return

        case "'":
          if (!doubleQuote) {
            read()
            return newToken('string', buffer)
          }

          buffer += read()
          return

        case '\n':
        case '\r':
          throw invalidChar(read())

        case '\u2028':
        case '\u2029':
          separatorChar(c)
          break

        case undefined:
          throw invalidChar(read())
      }

      buffer += read()
    },

    start() {
      switch (c) {
        case '{':
        case '[':
          return newToken('punctuator', read())
        // This code is unreachable since the default lexState handles eof.
        // case undefined:
        //     return newToken('eof')
      }

      lexState = 'value'
    },

    beforePropertyName() {
      switch (c) {
        case '$':
        case '_':
          buffer = read()
          lexState = 'identifierName'
          return

        case '\\':
          read()
          lexState = 'identifierNameStartEscape'
          return

        case '}':
          return newToken('punctuator', read())

        case '"':
        case "'":
          doubleQuote = read() === '"'
          lexState = 'string'
          return
      }

      if (util.isIdStartChar(c)) {
        buffer += read()
        lexState = 'identifierName'
        return
      }

      throw invalidChar(read())
    },

    afterPropertyName() {
      if (c === ':') {
        return newToken('punctuator', read())
      }

      throw invalidChar(read())
    },

    beforePropertyValue() {
      lexState = 'value'
    },

    afterPropertyValue() {
      switch (c) {
        case ',':
        case '}':
          return newToken('punctuator', read())
      }

      throw invalidChar(read())
    },

    beforeArrayValue() {
      if (c === ']') {
        return newToken('punctuator', read())
      }

      lexState = 'value'
    },

    afterArrayValue() {
      switch (c) {
        case ',':
        case ']':
          return newToken('punctuator', read())
      }

      throw invalidChar(read())
    },

    end() {
      // This code is unreachable since it's handled by the default lexState.
      // if (c === undefined) {
      //     read()
      //     return newToken('eof')
      // }
      throw invalidChar(read())
    },
  }

  function newToken(type, value) {
    return {
      type,
      value,
      line,
      column,
    }
  }

  function literal(s) {
    for (const c of s) {
      const p = peek()

      if (p !== c) {
        throw invalidChar(read())
      }

      read()
    }
  }

  function escape() {
    const c = peek()

    switch (c) {
      case 'b':
        read()
        return '\b'

      case 'f':
        read()
        return '\f'

      case 'n':
        read()
        return '\n'

      case 'r':
        read()
        return '\r'

      case 't':
        read()
        return '\t'

      case 'v':
        read()
        return '\v'

      case '0':
        read()

        if (util.isDigit(peek())) {
          throw invalidChar(read())
        }

        return '\0'

      case 'x':
        read()
        return hexEscape()

      case 'u':
        read()
        return unicodeEscape()

      case '\n':
      case '\u2028':
      case '\u2029':
        read()
        return ''

      case '\r':
        read()

        if (peek() === '\n') {
          read()
        }

        return ''

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        throw invalidChar(read())

      case undefined:
        throw invalidChar(read())
    }

    return read()
  }

  function hexEscape() {
    let buffer = ''
    let c = peek()

    if (!util.isHexDigit(c)) {
      throw invalidChar(read())
    }

    buffer += read()
    c = peek()

    if (!util.isHexDigit(c)) {
      throw invalidChar(read())
    }

    buffer += read()
    return String.fromCodePoint(parseInt(buffer, 16))
  }

  function unicodeEscape() {
    let buffer = ''
    let count = 4

    while (count-- > 0) {
      const c = peek()

      if (!util.isHexDigit(c)) {
        throw invalidChar(read())
      }

      buffer += read()
    }

    return String.fromCodePoint(parseInt(buffer, 16))
  }

  const parseStates = {
    start() {
      if (token.type === 'eof') {
        throw invalidEOF()
      }

      push()
    },

    beforePropertyName() {
      switch (token.type) {
        case 'identifier':
        case 'string':
          key = token.value
          parseState = 'afterPropertyName'
          return

        case 'punctuator':
          // This code is unreachable since it's handled by the lexState.
          // if (token.value !== '}') {
          //     throw invalidToken()
          // }
          pop()
          return

        case 'eof':
          throw invalidEOF()
      } // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()
    },

    afterPropertyName() {
      // This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'punctuator' || token.value !== ':') {
      //     throw invalidToken()
      // }
      if (token.type === 'eof') {
        throw invalidEOF()
      }

      parseState = 'beforePropertyValue'
    },

    beforePropertyValue() {
      if (token.type === 'eof') {
        throw invalidEOF()
      }

      push()
    },

    beforeArrayValue() {
      if (token.type === 'eof') {
        throw invalidEOF()
      }

      if (token.type === 'punctuator' && token.value === ']') {
        pop()
        return
      }

      push()
    },

    afterPropertyValue() {
      // This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'punctuator') {
      //     throw invalidToken()
      // }
      if (token.type === 'eof') {
        throw invalidEOF()
      }

      switch (token.value) {
        case ',':
          parseState = 'beforePropertyName'
          return

        case '}':
          pop()
      } // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()
    },

    afterArrayValue() {
      // This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'punctuator') {
      //     throw invalidToken()
      // }
      if (token.type === 'eof') {
        throw invalidEOF()
      }

      switch (token.value) {
        case ',':
          parseState = 'beforeArrayValue'
          return

        case ']':
          pop()
      } // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()
    },

    end() {
      // This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'eof') {
      //     throw invalidToken()
      // }
    },
  }

  function push() {
    let value

    switch (token.type) {
      case 'punctuator':
        switch (token.value) {
          case '{':
            value = {}
            break

          case '[':
            value = []
            break
        }

        break

      case 'null':
      case 'boolean':
      case 'numeric':
      case 'string':
        value = token.value
        break
      // This code is unreachable.
      // default:
      //     throw invalidToken()
    }

    if (root === undefined) {
      root = value
    } else {
      const parent = stack[stack.length - 1]

      if (Array.isArray(parent)) {
        parent.push(value)
      } else {
        parent[key] = value
      }
    }

    if (value !== null && typeof value === 'object') {
      stack.push(value)

      if (Array.isArray(value)) {
        parseState = 'beforeArrayValue'
      } else {
        parseState = 'beforePropertyName'
      }
    } else {
      const current = stack[stack.length - 1]

      if (current == null) {
        parseState = 'end'
      } else if (Array.isArray(current)) {
        parseState = 'afterArrayValue'
      } else {
        parseState = 'afterPropertyValue'
      }
    }
  }

  function pop() {
    stack.pop()
    const current = stack[stack.length - 1]

    if (current == null) {
      parseState = 'end'
    } else if (Array.isArray(current)) {
      parseState = 'afterArrayValue'
    } else {
      parseState = 'afterPropertyValue'
    }
  } // This code is unreachable.
  // function invalidParseState () {
  //     return new Error(`JSON5: invalid parse state '${parseState}'`)
  // }
  // This code is unreachable.
  // function invalidLexState (state) {
  //     return new Error(`JSON5: invalid lex state '${state}'`)
  // }

  function invalidChar(c) {
    if (c === undefined) {
      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
    }

    return syntaxError(
      `JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`,
    )
  }

  function invalidEOF() {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
  } // This code is unreachable.
  // function invalidToken () {
  //     if (token.type === 'eof') {
  //         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
  //     }
  //     const c = String.fromCodePoint(token.value.codePointAt(0))
  //     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
  // }

  function invalidIdentifier() {
    column -= 5
    return syntaxError(
      `JSON5: invalid identifier character at ${line}:${column}`,
    )
  }

  function separatorChar(c) {
    console.warn(
      `JSON5: '${formatChar(
        c,
      )}' in strings is not valid ECMAScript; consider escaping`,
    )
  }

  function formatChar(c) {
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      '\\': '\\\\',
      '\b': '\\b',
      '\f': '\\f',
      '\n': '\\n',
      '\r': '\\r',
      '\t': '\\t',
      '\v': '\\v',
      '\0': '\\0',
      '\u2028': '\\u2028',
      '\u2029': '\\u2029',
    }

    if (replacements[c]) {
      return replacements[c]
    }

    if (c < ' ') {
      const hexString = c.charCodeAt(0).toString(16)
      return '\\x' + ('00' + hexString).substring(hexString.length)
    }

    return c
  }

  function syntaxError(message) {
    const err = new SyntaxError(message)
    err.lineNumber = line
    err.columnNumber = column
    return err
  }

  var stringify$2 = function stringify(value, replacer, space) {
    const stack = []
    let indent = ''
    let propertyList
    let replacerFunc
    let gap = ''
    let quote

    if (
      replacer != null &&
      typeof replacer === 'object' &&
      !Array.isArray(replacer)
    ) {
      space = replacer.space
      quote = replacer.quote
      replacer = replacer.replacer
    }

    if (typeof replacer === 'function') {
      replacerFunc = replacer
    } else if (Array.isArray(replacer)) {
      propertyList = []

      for (const v of replacer) {
        let item

        if (typeof v === 'string') {
          item = v
        } else if (
          typeof v === 'number' ||
          v instanceof String ||
          v instanceof Number
        ) {
          item = String(v)
        }

        if (item !== undefined && propertyList.indexOf(item) < 0) {
          propertyList.push(item)
        }
      }
    }

    if (space instanceof Number) {
      space = Number(space)
    } else if (space instanceof String) {
      space = String(space)
    }

    if (typeof space === 'number') {
      if (space > 0) {
        space = Math.min(10, Math.floor(space))
        gap = '          '.substr(0, space)
      }
    } else if (typeof space === 'string') {
      gap = space.substr(0, 10)
    }

    return serializeProperty('', {
      '': value,
    })

    function serializeProperty(key, holder) {
      let value = holder[key]

      if (value != null) {
        if (typeof value.toJSON5 === 'function') {
          value = value.toJSON5(key)
        } else if (typeof value.toJSON === 'function') {
          value = value.toJSON(key)
        }
      }

      if (replacerFunc) {
        value = replacerFunc.call(holder, key, value)
      }

      if (value instanceof Number) {
        value = Number(value)
      } else if (value instanceof String) {
        value = String(value)
      } else if (value instanceof Boolean) {
        value = value.valueOf()
      }

      switch (value) {
        case null:
          return 'null'

        case true:
          return 'true'

        case false:
          return 'false'
      }

      if (typeof value === 'string') {
        return quoteString(value)
      }

      if (typeof value === 'number') {
        return String(value)
      }

      if (typeof value === 'object') {
        return Array.isArray(value)
          ? serializeArray(value)
          : serializeObject(value)
      }

      return undefined
    }

    function quoteString(value) {
      const quotes = {
        "'": 0.1,
        '"': 0.2,
      }
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029',
      }
      let product = ''

      for (let i = 0; i < value.length; i++) {
        const c = value[i]

        switch (c) {
          case "'":
          case '"':
            quotes[c]++
            product += c
            continue

          case '\0':
            if (util.isDigit(value[i + 1])) {
              product += '\\x00'
              continue
            }
        }

        if (replacements[c]) {
          product += replacements[c]
          continue
        }

        if (c < ' ') {
          let hexString = c.charCodeAt(0).toString(16)
          product += '\\x' + ('00' + hexString).substring(hexString.length)
          continue
        }

        product += c
      }

      const quoteChar =
        quote ||
        Object.keys(quotes).reduce((a, b) => (quotes[a] < quotes[b] ? a : b))
      product = product.replace(
        new RegExp(quoteChar, 'g'),
        replacements[quoteChar],
      )
      return quoteChar + product + quoteChar
    }

    function serializeObject(value) {
      if (stack.indexOf(value) >= 0) {
        throw TypeError('Converting circular structure to JSON5')
      }

      stack.push(value)
      let stepback = indent
      indent = indent + gap
      let keys = propertyList || Object.keys(value)
      let partial = []

      for (const key of keys) {
        const propertyString = serializeProperty(key, value)

        if (propertyString !== undefined) {
          let member = serializeKey(key) + ':'

          if (gap !== '') {
            member += ' '
          }

          member += propertyString
          partial.push(member)
        }
      }

      let final

      if (partial.length === 0) {
        final = '{}'
      } else {
        let properties

        if (gap === '') {
          properties = partial.join(',')
          final = '{' + properties + '}'
        } else {
          let separator = ',\n' + indent
          properties = partial.join(separator)
          final = '{\n' + indent + properties + ',\n' + stepback + '}'
        }
      }

      stack.pop()
      indent = stepback
      return final
    }

    function serializeKey(key) {
      if (key.length === 0) {
        return quoteString(key)
      }

      const firstChar = String.fromCodePoint(key.codePointAt(0))

      if (!util.isIdStartChar(firstChar)) {
        return quoteString(key)
      }

      for (let i = firstChar.length; i < key.length; i++) {
        if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
          return quoteString(key)
        }
      }

      return key
    }

    function serializeArray(value) {
      if (stack.indexOf(value) >= 0) {
        throw TypeError('Converting circular structure to JSON5')
      }

      stack.push(value)
      let stepback = indent
      indent = indent + gap
      let partial = []

      for (let i = 0; i < value.length; i++) {
        const propertyString = serializeProperty(String(i), value)
        partial.push(propertyString !== undefined ? propertyString : 'null')
      }

      let final

      if (partial.length === 0) {
        final = '[]'
      } else {
        if (gap === '') {
          let properties = partial.join(',')
          final = '[' + properties + ']'
        } else {
          let separator = ',\n' + indent
          let properties = partial.join(separator)
          final = '[\n' + indent + properties + ',\n' + stepback + ']'
        }
      }

      stack.pop()
      indent = stepback
      return final
    }
  }

  const JSON5 = {
    parse: parse$2,
    stringify: stringify$2,
  }
  var lib = JSON5

  var dist = {}

  var parseCst$1 = {}

  var PlainValueEc8e588e = {}

  const Char = {
    ANCHOR: '&',
    COMMENT: '#',
    TAG: '!',
    DIRECTIVES_END: '-',
    DOCUMENT_END: '.',
  }
  const Type = {
    ALIAS: 'ALIAS',
    BLANK_LINE: 'BLANK_LINE',
    BLOCK_FOLDED: 'BLOCK_FOLDED',
    BLOCK_LITERAL: 'BLOCK_LITERAL',
    COMMENT: 'COMMENT',
    DIRECTIVE: 'DIRECTIVE',
    DOCUMENT: 'DOCUMENT',
    FLOW_MAP: 'FLOW_MAP',
    FLOW_SEQ: 'FLOW_SEQ',
    MAP: 'MAP',
    MAP_KEY: 'MAP_KEY',
    MAP_VALUE: 'MAP_VALUE',
    PLAIN: 'PLAIN',
    QUOTE_DOUBLE: 'QUOTE_DOUBLE',
    QUOTE_SINGLE: 'QUOTE_SINGLE',
    SEQ: 'SEQ',
    SEQ_ITEM: 'SEQ_ITEM',
  }
  const defaultTagPrefix = 'tag:yaml.org,2002:'
  const defaultTags = {
    MAP: 'tag:yaml.org,2002:map',
    SEQ: 'tag:yaml.org,2002:seq',
    STR: 'tag:yaml.org,2002:str',
  }

  function findLineStarts(src) {
    const ls = [0]
    let offset = src.indexOf('\n')

    while (offset !== -1) {
      offset += 1
      ls.push(offset)
      offset = src.indexOf('\n', offset)
    }

    return ls
  }

  function getSrcInfo(cst) {
    let lineStarts, src

    if (typeof cst === 'string') {
      lineStarts = findLineStarts(cst)
      src = cst
    } else {
      if (Array.isArray(cst)) cst = cst[0]

      if (cst && cst.context) {
        if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src)
        lineStarts = cst.lineStarts
        src = cst.context.src
      }
    }

    return {
      lineStarts,
      src,
    }
  }
  /**
   * @typedef {Object} LinePos - One-indexed position in the source
   * @property {number} line
   * @property {number} col
   */

  /**
   * Determine the line/col position matching a character offset.
   *
   * Accepts a source string or a CST document as the second parameter. With
   * the latter, starting indices for lines are cached in the document as
   * `lineStarts: number[]`.
   *
   * Returns a one-indexed `{ line, col }` location if found, or
   * `undefined` otherwise.
   *
   * @param {number} offset
   * @param {string|Document|Document[]} cst
   * @returns {?LinePos}
   */

  function getLinePos(offset, cst) {
    if (typeof offset !== 'number' || offset < 0) return null
    const { lineStarts, src } = getSrcInfo(cst)
    if (!lineStarts || !src || offset > src.length) return null

    for (let i = 0; i < lineStarts.length; ++i) {
      const start = lineStarts[i]

      if (offset < start) {
        return {
          line: i,
          col: offset - lineStarts[i - 1] + 1,
        }
      }

      if (offset === start)
        return {
          line: i + 1,
          col: 1,
        }
    }

    const line = lineStarts.length
    return {
      line,
      col: offset - lineStarts[line - 1] + 1,
    }
  }
  /**
   * Get a specified line from the source.
   *
   * Accepts a source string or a CST document as the second parameter. With
   * the latter, starting indices for lines are cached in the document as
   * `lineStarts: number[]`.
   *
   * Returns the line as a string if found, or `null` otherwise.
   *
   * @param {number} line One-indexed line number
   * @param {string|Document|Document[]} cst
   * @returns {?string}
   */

  function getLine(line, cst) {
    const { lineStarts, src } = getSrcInfo(cst)
    if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null
    const start = lineStarts[line - 1]
    let end = lineStarts[line] // undefined for last line; that's ok for slice()

    while (end && end > start && src[end - 1] === '\n') --end

    return src.slice(start, end)
  }
  /**
   * Pretty-print the starting line from the source indicated by the range `pos`
   *
   * Trims output to `maxWidth` chars while keeping the starting column visible,
   * using `` at either end to indicate dropped characters.
   *
   * Returns a two-line string (or `null`) with `\n` as separator; the second line
   * will hold appropriately indented `^` marks indicating the column range.
   *
   * @param {Object} pos
   * @param {LinePos} pos.start
   * @param {LinePos} [pos.end]
   * @param {string|Document|Document[]*} cst
   * @param {number} [maxWidth=80]
   * @returns {?string}
   */

  function getPrettyContext({ start, end }, cst, maxWidth = 80) {
    let src = getLine(start.line, cst)
    if (!src) return null
    let { col } = start

    if (src.length > maxWidth) {
      if (col <= maxWidth - 10) {
        src = src.substr(0, maxWidth - 1) + ''
      } else {
        const halfWidth = Math.round(maxWidth / 2)
        if (src.length > col + halfWidth)
          src = src.substr(0, col + halfWidth - 1) + ''
        col -= src.length - maxWidth
        src = '' + src.substr(1 - maxWidth)
      }
    }

    let errLen = 1
    let errEnd = ''

    if (end) {
      if (
        end.line === start.line &&
        col + (end.col - start.col) <= maxWidth + 1
      ) {
        errLen = end.col - start.col
      } else {
        errLen = Math.min(src.length + 1, maxWidth) - col
        errEnd = ''
      }
    }

    const offset = col > 1 ? ' '.repeat(col - 1) : ''
    const err = '^'.repeat(errLen)
    return `${src}\n${offset}${err}${errEnd}`
  }

  class Range {
    static copy(orig) {
      return new Range(orig.start, orig.end)
    }

    constructor(start, end) {
      this.start = start
      this.end = end || start
    }

    isEmpty() {
      return (
        typeof this.start !== 'number' || !this.end || this.end <= this.start
      )
    }
    /**
     * Set `origStart` and `origEnd` to point to the original source range for
     * this node, which may differ due to dropped CR characters.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */

    setOrigRange(cr, offset) {
      const { start, end } = this

      if (cr.length === 0 || end <= cr[0]) {
        this.origStart = start
        this.origEnd = end
        return offset
      }

      let i = offset

      while (i < cr.length) {
        if (cr[i] > start) break
        else ++i
      }

      this.origStart = start + i
      const nextOffset = i

      while (i < cr.length) {
        // if end was at \n, it should now be at \r
        if (cr[i] >= end) break
        else ++i
      }

      this.origEnd = end + i
      return nextOffset
    }
  }
  /** Root class of all nodes */

  class Node$1 {
    static addStringTerminator(src, offset, str) {
      if (str[str.length - 1] === '\n') return str
      const next = Node$1.endOfWhiteSpace(src, offset)
      return next >= src.length || src[next] === '\n' ? str + '\n' : str
    } // ^(---|...)

    static atDocumentBoundary(src, offset, sep) {
      const ch0 = src[offset]
      if (!ch0) return true
      const prev = src[offset - 1]
      if (prev && prev !== '\n') return false

      if (sep) {
        if (ch0 !== sep) return false
      } else {
        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
          return false
      }

      const ch1 = src[offset + 1]
      const ch2 = src[offset + 2]
      if (ch1 !== ch0 || ch2 !== ch0) return false
      const ch3 = src[offset + 3]
      return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' '
    }

    static endOfIdentifier(src, offset) {
      let ch = src[offset]
      const isVerbatim = ch === '<'
      const notOk = isVerbatim
        ? ['\n', '\t', ' ', '>']
        : ['\n', '\t', ' ', '[', ']', '{', '}', ',']

      while (ch && notOk.indexOf(ch) === -1) ch = src[(offset += 1)]

      if (isVerbatim && ch === '>') offset += 1
      return offset
    }

    static endOfIndent(src, offset) {
      let ch = src[offset]

      while (ch === ' ') ch = src[(offset += 1)]

      return offset
    }

    static endOfLine(src, offset) {
      let ch = src[offset]

      while (ch && ch !== '\n') ch = src[(offset += 1)]

      return offset
    }

    static endOfWhiteSpace(src, offset) {
      let ch = src[offset]

      while (ch === '\t' || ch === ' ') ch = src[(offset += 1)]

      return offset
    }

    static startOfLine(src, offset) {
      let ch = src[offset - 1]
      if (ch === '\n') return offset

      while (ch && ch !== '\n') ch = src[(offset -= 1)]

      return offset + 1
    }
    /**
     * End of indentation, or null if the line's indent level is not more
     * than `indent`
     *
     * @param {string} src
     * @param {number} indent
     * @param {number} lineStart
     * @returns {?number}
     */

    static endOfBlockIndent(src, indent, lineStart) {
      const inEnd = Node$1.endOfIndent(src, lineStart)

      if (inEnd > lineStart + indent) {
        return inEnd
      } else {
        const wsEnd = Node$1.endOfWhiteSpace(src, inEnd)
        const ch = src[wsEnd]
        if (!ch || ch === '\n') return wsEnd
      }

      return null
    }

    static atBlank(src, offset, endAsBlank) {
      const ch = src[offset]
      return ch === '\n' || ch === '\t' || ch === ' ' || (endAsBlank && !ch)
    }

    static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
      if (!ch || indentDiff < 0) return false
      if (indentDiff > 0) return true
      return indicatorAsIndent && ch === '-'
    } // should be at line or string end, or at next non-whitespace char

    static normalizeOffset(src, offset) {
      const ch = src[offset]
      return !ch
        ? offset
        : ch !== '\n' && src[offset - 1] === '\n'
        ? offset - 1
        : Node$1.endOfWhiteSpace(src, offset)
    } // fold single newline into space, multiple newlines to N - 1 newlines
    // presumes src[offset] === '\n'

    static foldNewline(src, offset, indent) {
      let inCount = 0
      let error = false
      let fold = ''
      let ch = src[offset + 1]

      while (ch === ' ' || ch === '\t' || ch === '\n') {
        switch (ch) {
          case '\n':
            inCount = 0
            offset += 1
            fold += '\n'
            break

          case '\t':
            if (inCount <= indent) error = true
            offset = Node$1.endOfWhiteSpace(src, offset + 2) - 1
            break

          case ' ':
            inCount += 1
            offset += 1
            break
        }

        ch = src[offset + 1]
      }

      if (!fold) fold = ' '
      if (ch && inCount <= indent) error = true
      return {
        fold,
        offset,
        error,
      }
    }

    constructor(type, props, context) {
      Object.defineProperty(this, 'context', {
        value: context || null,
        writable: true,
      })
      this.error = null
      this.range = null
      this.valueRange = null
      this.props = props || []
      this.type = type
      this.value = null
    }

    getPropValue(idx, key, skipKey) {
      if (!this.context) return null
      const { src } = this.context
      const prop = this.props[idx]
      return prop && src[prop.start] === key
        ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end)
        : null
    }

    get anchor() {
      for (let i = 0; i < this.props.length; ++i) {
        const anchor = this.getPropValue(i, Char.ANCHOR, true)
        if (anchor != null) return anchor
      }

      return null
    }

    get comment() {
      const comments = []

      for (let i = 0; i < this.props.length; ++i) {
        const comment = this.getPropValue(i, Char.COMMENT, true)
        if (comment != null) comments.push(comment)
      }

      return comments.length > 0 ? comments.join('\n') : null
    }

    commentHasRequiredWhitespace(start) {
      const { src } = this.context
      if (this.header && start === this.header.end) return false
      if (!this.valueRange) return false
      const { end } = this.valueRange
      return start !== end || Node$1.atBlank(src, end - 1)
    }

    get hasComment() {
      if (this.context) {
        const { src } = this.context

        for (let i = 0; i < this.props.length; ++i) {
          if (src[this.props[i].start] === Char.COMMENT) return true
        }
      }

      return false
    }

    get hasProps() {
      if (this.context) {
        const { src } = this.context

        for (let i = 0; i < this.props.length; ++i) {
          if (src[this.props[i].start] !== Char.COMMENT) return true
        }
      }

      return false
    }

    get includesTrailingLines() {
      return false
    }

    get jsonLike() {
      const jsonLikeTypes = [
        Type.FLOW_MAP,
        Type.FLOW_SEQ,
        Type.QUOTE_DOUBLE,
        Type.QUOTE_SINGLE,
      ]
      return jsonLikeTypes.indexOf(this.type) !== -1
    }

    get rangeAsLinePos() {
      if (!this.range || !this.context) return undefined
      const start = getLinePos(this.range.start, this.context.root)
      if (!start) return undefined
      const end = getLinePos(this.range.end, this.context.root)
      return {
        start,
        end,
      }
    }

    get rawValue() {
      if (!this.valueRange || !this.context) return null
      const { start, end } = this.valueRange
      return this.context.src.slice(start, end)
    }

    get tag() {
      for (let i = 0; i < this.props.length; ++i) {
        const tag = this.getPropValue(i, Char.TAG, false)

        if (tag != null) {
          if (tag[1] === '<') {
            return {
              verbatim: tag.slice(2, -1),
            }
          } else {
            // eslint-disable-next-line no-unused-vars
            const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/)
            return {
              handle,
              suffix,
            }
          }
        }
      }

      return null
    }

    get valueRangeContainsNewline() {
      if (!this.valueRange || !this.context) return false
      const { start, end } = this.valueRange
      const { src } = this.context

      for (let i = start; i < end; ++i) {
        if (src[i] === '\n') return true
      }

      return false
    }

    parseComment(start) {
      const { src } = this.context

      if (src[start] === Char.COMMENT) {
        const end = Node$1.endOfLine(src, start + 1)
        const commentRange = new Range(start, end)
        this.props.push(commentRange)
        return end
      }

      return start
    }
    /**
     * Populates the `origStart` and `origEnd` values of all ranges for this
     * node. Extended by child classes to handle descendant nodes.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */

    setOrigRanges(cr, offset) {
      if (this.range) offset = this.range.setOrigRange(cr, offset)
      if (this.valueRange) this.valueRange.setOrigRange(cr, offset)
      this.props.forEach((prop) => prop.setOrigRange(cr, offset))
      return offset
    }

    toString() {
      const {
        context: { src },
        range,
        value,
      } = this
      if (value != null) return value
      const str = src.slice(range.start, range.end)
      return Node$1.addStringTerminator(src, range.end, str)
    }
  }

  class YAMLError extends Error {
    constructor(name, source, message) {
      if (!message || !(source instanceof Node$1))
        throw new Error(`Invalid arguments for new ${name}`)
      super()
      this.name = name
      this.message = message
      this.source = source
    }

    makePretty() {
      if (!this.source) return
      this.nodeType = this.source.type
      const cst = this.source.context && this.source.context.root

      if (typeof this.offset === 'number') {
        this.range = new Range(this.offset, this.offset + 1)
        const start = cst && getLinePos(this.offset, cst)

        if (start) {
          const end = {
            line: start.line,
            col: start.col + 1,
          }
          this.linePos = {
            start,
            end,
          }
        }

        delete this.offset
      } else {
        this.range = this.source.range
        this.linePos = this.source.rangeAsLinePos
      }

      if (this.linePos) {
        const { line, col } = this.linePos.start
        this.message += ` at line ${line}, column ${col}`
        const ctx = cst && getPrettyContext(this.linePos, cst)
        if (ctx) this.message += `:\n\n${ctx}\n`
      }

      delete this.source
    }
  }

  class YAMLReferenceError extends YAMLError {
    constructor(source, message) {
      super('YAMLReferenceError', source, message)
    }
  }

  class YAMLSemanticError extends YAMLError {
    constructor(source, message) {
      super('YAMLSemanticError', source, message)
    }
  }

  class YAMLSyntaxError extends YAMLError {
    constructor(source, message) {
      super('YAMLSyntaxError', source, message)
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(source, message) {
      super('YAMLWarning', source, message)
    }
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true,
      })
    } else {
      obj[key] = value
    }

    return obj
  }

  class PlainValue$6 extends Node$1 {
    static endOfLine(src, start, inFlow) {
      let ch = src[start]
      let offset = start

      while (ch && ch !== '\n') {
        if (
          inFlow &&
          (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')
        )
          break
        const next = src[offset + 1]
        if (
          ch === ':' &&
          (!next ||
            next === '\n' ||
            next === '\t' ||
            next === ' ' ||
            (inFlow && next === ','))
        )
          break
        if ((ch === ' ' || ch === '\t') && next === '#') break
        offset += 1
        ch = next
      }

      return offset
    }

    get strValue() {
      if (!this.valueRange || !this.context) return null
      let { start, end } = this.valueRange
      const { src } = this.context
      let ch = src[end - 1]

      while (start < end && (ch === '\n' || ch === '\t' || ch === ' '))
        ch = src[--end - 1]

      let str = ''

      for (let i = start; i < end; ++i) {
        const ch = src[i]

        if (ch === '\n') {
          const { fold, offset } = Node$1.foldNewline(src, i, -1)
          str += fold
          i = offset
        } else if (ch === ' ' || ch === '\t') {
          // trim trailing whitespace
          const wsStart = i
          let next = src[i + 1]

          while (i < end && (next === ' ' || next === '\t')) {
            i += 1
            next = src[i + 1]
          }

          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch
        } else {
          str += ch
        }
      }

      const ch0 = src[start]

      switch (ch0) {
        case '\t': {
          const msg = 'Plain value cannot start with a tab character'
          const errors = [new YAMLSemanticError(this, msg)]
          return {
            errors,
            str,
          }
        }

        case '@':
        case '`': {
          const msg = `Plain value cannot start with reserved character ${ch0}`
          const errors = [new YAMLSemanticError(this, msg)]
          return {
            errors,
            str,
          }
        }

        default:
          return str
      }
    }

    parseBlockValue(start) {
      const { indent, inFlow, src } = this.context
      let offset = start
      let valueEnd = start

      for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
        if (Node$1.atDocumentBoundary(src, offset + 1)) break
        const end = Node$1.endOfBlockIndent(src, indent, offset + 1)
        if (end === null || src[end] === '#') break

        if (src[end] === '\n') {
          offset = end
        } else {
          valueEnd = PlainValue$6.endOfLine(src, end, inFlow)
          offset = valueEnd
        }
      }

      if (this.valueRange.isEmpty()) this.valueRange.start = start
      this.valueRange.end = valueEnd
      return valueEnd
    }
    /**
     * Parses a plain value from the source
     *
     * Accepted forms are:
     * ```
     * #comment
     *
     * first line
     *
     * first line #comment
     *
     * first line
     * block
     * lines
     *
     * #comment
     * block
     * lines
     * ```
     * where block lines are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar, may be `\n`
     */

    parse(context, start) {
      this.context = context
      const { inFlow, src } = context
      let offset = start
      const ch = src[offset]

      if (ch && ch !== '#' && ch !== '\n') {
        offset = PlainValue$6.endOfLine(src, start, inFlow)
      }

      this.valueRange = new Range(start, offset)
      offset = Node$1.endOfWhiteSpace(src, offset)
      offset = this.parseComment(offset)

      if (!this.hasComment || this.valueRange.isEmpty()) {
        offset = this.parseBlockValue(offset)
      }

      return offset
    }
  }

  PlainValueEc8e588e.Char = Char
  PlainValueEc8e588e.Node = Node$1
  PlainValueEc8e588e.PlainValue = PlainValue$6
  PlainValueEc8e588e.Range = Range
  PlainValueEc8e588e.Type = Type
  PlainValueEc8e588e.YAMLError = YAMLError
  PlainValueEc8e588e.YAMLReferenceError = YAMLReferenceError
  PlainValueEc8e588e.YAMLSemanticError = YAMLSemanticError
  PlainValueEc8e588e.YAMLSyntaxError = YAMLSyntaxError
  PlainValueEc8e588e.YAMLWarning = YAMLWarning
  PlainValueEc8e588e._defineProperty = _defineProperty
  PlainValueEc8e588e.defaultTagPrefix = defaultTagPrefix
  PlainValueEc8e588e.defaultTags = defaultTags

  var PlainValue$5 = PlainValueEc8e588e

  class BlankLine extends PlainValue$5.Node {
    constructor() {
      super(PlainValue$5.Type.BLANK_LINE)
    }
    /* istanbul ignore next */

    get includesTrailingLines() {
      // This is never called from anywhere, but if it were,
      // this is the value it should return.
      return true
    }
    /**
     * Parses a blank line from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first \n character
     * @returns {number} - Index of the character after this
     */

    parse(context, start) {
      this.context = context
      this.range = new PlainValue$5.Range(start, start + 1)
      return start + 1
    }
  }

  class CollectionItem extends PlainValue$5.Node {
    constructor(type, props) {
      super(type, props)
      this.node = null
    }

    get includesTrailingLines() {
      return !!this.node && this.node.includesTrailingLines
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */

    parse(context, start) {
      this.context = context
      const { parseNode, src } = context
      let { atLineStart, lineStart } = context
      if (!atLineStart && this.type === PlainValue$5.Type.SEQ_ITEM)
        this.error = new PlainValue$5.YAMLSemanticError(
          this,
          'Sequence items must not have preceding content on the same line',
        )
      const indent = atLineStart ? start - lineStart : context.indent
      let offset = PlainValue$5.Node.endOfWhiteSpace(src, start + 1)
      let ch = src[offset]
      const inlineComment = ch === '#'
      const comments = []
      let blankLine = null

      while (ch === '\n' || ch === '#') {
        if (ch === '#') {
          const end = PlainValue$5.Node.endOfLine(src, offset + 1)
          comments.push(new PlainValue$5.Range(offset, end))
          offset = end
        } else {
          atLineStart = true
          lineStart = offset + 1
          const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src, lineStart)

          if (src[wsEnd] === '\n' && comments.length === 0) {
            blankLine = new BlankLine()
            lineStart = blankLine.parse(
              {
                src,
              },
              lineStart,
            )
          }

          offset = PlainValue$5.Node.endOfIndent(src, lineStart)
        }

        ch = src[offset]
      }

      if (
        PlainValue$5.Node.nextNodeIsIndented(
          ch,
          offset - (lineStart + indent),
          this.type !== PlainValue$5.Type.SEQ_ITEM,
        )
      ) {
        this.node = parseNode(
          {
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this,
          },
          offset,
        )
      } else if (ch && lineStart > start + 1) {
        offset = lineStart - 1
      }

      if (this.node) {
        if (blankLine) {
          // Only blank lines preceding non-empty nodes are captured. Note that
          // this means that collection item range start indices do not always
          // increase monotonically. -- eemeli/yaml#126
          const items = context.parent.items || context.parent.contents
          if (items) items.push(blankLine)
        }

        if (comments.length) Array.prototype.push.apply(this.props, comments)
        offset = this.node.range.end
      } else {
        if (inlineComment) {
          const c = comments[0]
          this.props.push(c)
          offset = c.end
        } else {
          offset = PlainValue$5.Node.endOfLine(src, start + 1)
        }
      }

      const end = this.node ? this.node.valueRange.end : offset
      this.valueRange = new PlainValue$5.Range(start, end)
      return offset
    }

    setOrigRanges(cr, offset) {
      offset = super.setOrigRanges(cr, offset)
      return this.node ? this.node.setOrigRanges(cr, offset) : offset
    }

    toString() {
      const {
        context: { src },
        node,
        range,
        value,
      } = this
      if (value != null) return value
      const str = node
        ? src.slice(range.start, node.range.start) + String(node)
        : src.slice(range.start, range.end)
      return PlainValue$5.Node.addStringTerminator(src, range.end, str)
    }
  }

  class Comment extends PlainValue$5.Node {
    constructor() {
      super(PlainValue$5.Type.COMMENT)
    }
    /**
     * Parses a comment line from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */

    parse(context, start) {
      this.context = context
      const offset = this.parseComment(start)
      this.range = new PlainValue$5.Range(start, offset)
      return offset
    }
  }

  function grabCollectionEndComments(node) {
    let cnode = node

    while (cnode instanceof CollectionItem) cnode = cnode.node

    if (!(cnode instanceof Collection$1)) return null
    const len = cnode.items.length
    let ci = -1

    for (let i = len - 1; i >= 0; --i) {
      const n = cnode.items[i]

      if (n.type === PlainValue$5.Type.COMMENT) {
        // Keep sufficiently indented comments with preceding node
        const { indent, lineStart } = n.context
        if (indent > 0 && n.range.start >= lineStart + indent) break
        ci = i
      } else if (n.type === PlainValue$5.Type.BLANK_LINE) ci = i
      else break
    }

    if (ci === -1) return null
    const ca = cnode.items.splice(ci, len - ci)
    const prevEnd = ca[0].range.start

    while (true) {
      cnode.range.end = prevEnd
      if (cnode.valueRange && cnode.valueRange.end > prevEnd)
        cnode.valueRange.end = prevEnd
      if (cnode === node) break
      cnode = cnode.context.parent
    }

    return ca
  }

  class Collection$1 extends PlainValue$5.Node {
    static nextContentHasIndent(src, offset, indent) {
      const lineStart = PlainValue$5.Node.endOfLine(src, offset) + 1
      offset = PlainValue$5.Node.endOfWhiteSpace(src, lineStart)
      const ch = src[offset]
      if (!ch) return false
      if (offset >= lineStart + indent) return true
      if (ch !== '#' && ch !== '\n') return false
      return Collection$1.nextContentHasIndent(src, offset, indent)
    }

    constructor(firstItem) {
      super(
        firstItem.type === PlainValue$5.Type.SEQ_ITEM
          ? PlainValue$5.Type.SEQ
          : PlainValue$5.Type.MAP,
      )

      for (let i = firstItem.props.length - 1; i >= 0; --i) {
        if (firstItem.props[i].start < firstItem.context.lineStart) {
          // props on previous line are assumed by the collection
          this.props = firstItem.props.slice(0, i + 1)
          firstItem.props = firstItem.props.slice(i + 1)
          const itemRange = firstItem.props[0] || firstItem.valueRange
          firstItem.range.start = itemRange.start
          break
        }
      }

      this.items = [firstItem]
      const ec = grabCollectionEndComments(firstItem)
      if (ec) Array.prototype.push.apply(this.items, ec)
    }

    get includesTrailingLines() {
      return this.items.length > 0
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */

    parse(context, start) {
      this.context = context
      const { parseNode, src } = context // It's easier to recalculate lineStart here rather than tracking down the
      // last context from which to read it -- eemeli/yaml#2

      let lineStart = PlainValue$5.Node.startOfLine(src, start)
      const firstItem = this.items[0] // First-item context needs to be correct for later comment handling
      // -- eemeli/yaml#17

      firstItem.context.parent = this
      this.valueRange = PlainValue$5.Range.copy(firstItem.valueRange)
      const indent = firstItem.range.start - firstItem.context.lineStart
      let offset = start
      offset = PlainValue$5.Node.normalizeOffset(src, offset)
      let ch = src[offset]
      let atLineStart =
        PlainValue$5.Node.endOfWhiteSpace(src, lineStart) === offset
      let prevIncludesTrailingLines = false

      while (ch) {
        while (ch === '\n' || ch === '#') {
          if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
            const blankLine = new BlankLine()
            offset = blankLine.parse(
              {
                src,
              },
              offset,
            )
            this.valueRange.end = offset

            if (offset >= src.length) {
              ch = null
              break
            }

            this.items.push(blankLine)
            offset -= 1 // blankLine.parse() consumes terminal newline
          } else if (ch === '#') {
            if (
              offset < lineStart + indent &&
              !Collection$1.nextContentHasIndent(src, offset, indent)
            ) {
              return offset
            }

            const comment = new Comment()
            offset = comment.parse(
              {
                indent,
                lineStart,
                src,
              },
              offset,
            )
            this.items.push(comment)
            this.valueRange.end = offset

            if (offset >= src.length) {
              ch = null
              break
            }
          }

          lineStart = offset + 1
          offset = PlainValue$5.Node.endOfIndent(src, lineStart)

          if (PlainValue$5.Node.atBlank(src, offset)) {
            const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src, offset)
            const next = src[wsEnd]

            if (!next || next === '\n' || next === '#') {
              offset = wsEnd
            }
          }

          ch = src[offset]
          atLineStart = true
        }

        if (!ch) {
          break
        }

        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
          if (offset < lineStart + indent) {
            if (lineStart > start) offset = lineStart
            break
          } else if (!this.error) {
            const msg = 'All collection items must start at the same column'
            this.error = new PlainValue$5.YAMLSyntaxError(this, msg)
          }
        }

        if (firstItem.type === PlainValue$5.Type.SEQ_ITEM) {
          if (ch !== '-') {
            if (lineStart > start) offset = lineStart
            break
          }
        } else if (ch === '-' && !this.error) {
          // map key may start with -, as long as it's followed by a non-whitespace char
          const next = src[offset + 1]

          if (!next || next === '\n' || next === '\t' || next === ' ') {
            const msg = 'A collection cannot be both a mapping and a sequence'
            this.error = new PlainValue$5.YAMLSyntaxError(this, msg)
          }
        }

        const node = parseNode(
          {
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this,
          },
          offset,
        )
        if (!node) return offset // at next document start

        this.items.push(node)
        this.valueRange.end = node.valueRange.end
        offset = PlainValue$5.Node.normalizeOffset(src, node.range.end)
        ch = src[offset]
        atLineStart = false
        prevIncludesTrailingLines = node.includesTrailingLines // Need to reset lineStart and atLineStart here if preceding node's range
        // has advanced to check the current line's indentation level
        // -- eemeli/yaml#10 & eemeli/yaml#38

        if (ch) {
          let ls = offset - 1
          let prev = src[ls]

          while (prev === ' ' || prev === '\t') prev = src[--ls]

          if (prev === '\n') {
            lineStart = ls + 1
            atLineStart = true
          }
        }

        const ec = grabCollectionEndComments(node)
        if (ec) Array.prototype.push.apply(this.items, ec)
      }

      return offset
    }

    setOrigRanges(cr, offset) {
      offset = super.setOrigRanges(cr, offset)
      this.items.forEach((node) => {
        offset = node.setOrigRanges(cr, offset)
      })
      return offset
    }

    toString() {
      const {
        context: { src },
        items,
        range,
        value,
      } = this
      if (value != null) return value
      let str = src.slice(range.start, items[0].range.start) + String(items[0])

      for (let i = 1; i < items.length; ++i) {
        const item = items[i]
        const { atLineStart, indent } = item.context
        if (atLineStart) for (let i = 0; i < indent; ++i) str += ' '
        str += String(item)
      }

      return PlainValue$5.Node.addStringTerminator(src, range.end, str)
    }
  }

  class Directive extends PlainValue$5.Node {
    constructor() {
      super(PlainValue$5.Type.DIRECTIVE)
      this.name = null
    }

    get parameters() {
      const raw = this.rawValue
      return raw ? raw.trim().split(/[ \t]+/) : []
    }

    parseName(start) {
      const { src } = this.context
      let offset = start
      let ch = src[offset]

      while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ')
        ch = src[(offset += 1)]

      this.name = src.slice(start, offset)
      return offset
    }

    parseParameters(start) {
      const { src } = this.context
      let offset = start
      let ch = src[offset]

      while (ch && ch !== '\n' && ch !== '#') ch = src[(offset += 1)]

      this.valueRange = new PlainValue$5.Range(start, offset)
      return offset
    }

    parse(context, start) {
      this.context = context
      let offset = this.parseName(start + 1)
      offset = this.parseParameters(offset)
      offset = this.parseComment(offset)
      this.range = new PlainValue$5.Range(start, offset)
      return offset
    }
  }

  class Document$3 extends PlainValue$5.Node {
    static startCommentOrEndBlankLine(src, start) {
      const offset = PlainValue$5.Node.endOfWhiteSpace(src, start)
      const ch = src[offset]
      return ch === '#' || ch === '\n' ? offset : start
    }

    constructor() {
      super(PlainValue$5.Type.DOCUMENT)
      this.directives = null
      this.contents = null
      this.directivesEndMarker = null
      this.documentEndMarker = null
    }

    parseDirectives(start) {
      const { src } = this.context
      this.directives = []
      let atLineStart = true
      let hasDirectives = false
      let offset = start

      while (
        !PlainValue$5.Node.atDocumentBoundary(
          src,
          offset,
          PlainValue$5.Char.DIRECTIVES_END,
        )
      ) {
        offset = Document$3.startCommentOrEndBlankLine(src, offset)

        switch (src[offset]) {
          case '\n':
            if (atLineStart) {
              const blankLine = new BlankLine()
              offset = blankLine.parse(
                {
                  src,
                },
                offset,
              )

              if (offset < src.length) {
                this.directives.push(blankLine)
              }
            } else {
              offset += 1
              atLineStart = true
            }

            break

          case '#':
            {
              const comment = new Comment()
              offset = comment.parse(
                {
                  src,
                },
                offset,
              )
              this.directives.push(comment)
              atLineStart = false
            }
            break

          case '%':
            {
              const directive = new Directive()
              offset = directive.parse(
                {
                  parent: this,
                  src,
                },
                offset,
              )
              this.directives.push(directive)
              hasDirectives = true
              atLineStart = false
            }
            break

          default:
            if (hasDirectives) {
              this.error = new PlainValue$5.YAMLSemanticError(
                this,
                'Missing directives-end indicator line',
              )
            } else if (this.directives.length > 0) {
              this.contents = this.directives
              this.directives = []
            }

            return offset
        }
      }

      if (src[offset]) {
        this.directivesEndMarker = new PlainValue$5.Range(offset, offset + 3)
        return offset + 3
      }

      if (hasDirectives) {
        this.error = new PlainValue$5.YAMLSemanticError(
          this,
          'Missing directives-end indicator line',
        )
      } else if (this.directives.length > 0) {
        this.contents = this.directives
        this.directives = []
      }

      return offset
    }

    parseContents(start) {
      const { parseNode, src } = this.context
      if (!this.contents) this.contents = []
      let lineStart = start

      while (src[lineStart - 1] === '-') lineStart -= 1

      let offset = PlainValue$5.Node.endOfWhiteSpace(src, start)
      let atLineStart = lineStart === start
      this.valueRange = new PlainValue$5.Range(offset)

      while (
        !PlainValue$5.Node.atDocumentBoundary(
          src,
          offset,
          PlainValue$5.Char.DOCUMENT_END,
        )
      ) {
        switch (src[offset]) {
          case '\n':
            if (atLineStart) {
              const blankLine = new BlankLine()
              offset = blankLine.parse(
                {
                  src,
                },
                offset,
              )

              if (offset < src.length) {
                this.contents.push(blankLine)
              }
            } else {
              offset += 1
              atLineStart = true
            }

            lineStart = offset
            break

          case '#':
            {
              const comment = new Comment()
              offset = comment.parse(
                {
                  src,
                },
                offset,
              )
              this.contents.push(comment)
              atLineStart = false
            }
            break

          default: {
            const iEnd = PlainValue$5.Node.endOfIndent(src, offset)
            const context = {
              atLineStart,
              indent: -1,
              inFlow: false,
              inCollection: false,
              lineStart,
              parent: this,
            }
            const node = parseNode(context, iEnd)
            if (!node) return (this.valueRange.end = iEnd) // at next document start

            this.contents.push(node)
            offset = node.range.end
            atLineStart = false
            const ec = grabCollectionEndComments(node)
            if (ec) Array.prototype.push.apply(this.contents, ec)
          }
        }

        offset = Document$3.startCommentOrEndBlankLine(src, offset)
      }

      this.valueRange.end = offset

      if (src[offset]) {
        this.documentEndMarker = new PlainValue$5.Range(offset, offset + 3)
        offset += 3

        if (src[offset]) {
          offset = PlainValue$5.Node.endOfWhiteSpace(src, offset)

          if (src[offset] === '#') {
            const comment = new Comment()
            offset = comment.parse(
              {
                src,
              },
              offset,
            )
            this.contents.push(comment)
          }

          switch (src[offset]) {
            case '\n':
              offset += 1
              break

            case undefined:
              break

            default:
              this.error = new PlainValue$5.YAMLSyntaxError(
                this,
                'Document end marker line cannot have a non-comment suffix',
              )
          }
        }
      }

      return offset
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */

    parse(context, start) {
      context.root = this
      this.context = context
      const { src } = context
      let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start // skip BOM

      offset = this.parseDirectives(offset)
      offset = this.parseContents(offset)
      return offset
    }

    setOrigRanges(cr, offset) {
      offset = super.setOrigRanges(cr, offset)
      this.directives.forEach((node) => {
        offset = node.setOrigRanges(cr, offset)
      })
      if (this.directivesEndMarker)
        offset = this.directivesEndMarker.setOrigRange(cr, offset)
      this.contents.forEach((node) => {
        offset = node.setOrigRanges(cr, offset)
      })
      if (this.documentEndMarker)
        offset = this.documentEndMarker.setOrigRange(cr, offset)
      return offset
    }

    toString() {
      const { contents, directives, value } = this
      if (value != null) return value
      let str = directives.join('')

      if (contents.length > 0) {
        if (
          directives.length > 0 ||
          contents[0].type === PlainValue$5.Type.COMMENT
        )
          str += '---\n'
        str += contents.join('')
      }

      if (str[str.length - 1] !== '\n') str += '\n'
      return str
    }
  }

  class Alias$1 extends PlainValue$5.Node {
    /**
     * Parses an *alias from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */
    parse(context, start) {
      this.context = context
      const { src } = context
      let offset = PlainValue$5.Node.endOfIdentifier(src, start + 1)
      this.valueRange = new PlainValue$5.Range(start + 1, offset)
      offset = PlainValue$5.Node.endOfWhiteSpace(src, offset)
      offset = this.parseComment(offset)
      return offset
    }
  }

  const Chomp = {
    CLIP: 'CLIP',
    KEEP: 'KEEP',
    STRIP: 'STRIP',
  }

  class BlockValue extends PlainValue$5.Node {
    constructor(type, props) {
      super(type, props)
      this.blockIndent = null
      this.chomping = Chomp.CLIP
      this.header = null
    }

    get includesTrailingLines() {
      return this.chomping === Chomp.KEEP
    }

    get strValue() {
      if (!this.valueRange || !this.context) return null
      let { start, end } = this.valueRange
      const { indent, src } = this.context
      if (this.valueRange.isEmpty()) return ''
      let lastNewLine = null
      let ch = src[end - 1]

      while (ch === '\n' || ch === '\t' || ch === ' ') {
        end -= 1

        if (end <= start) {
          if (this.chomping === Chomp.KEEP) break
          else return '' // probably never happens
        }

        if (ch === '\n') lastNewLine = end
        ch = src[end - 1]
      }

      let keepStart = end + 1

      if (lastNewLine) {
        if (this.chomping === Chomp.KEEP) {
          keepStart = lastNewLine
          end = this.valueRange.end
        } else {
          end = lastNewLine
        }
      }

      const bi = indent + this.blockIndent
      const folded = this.type === PlainValue$5.Type.BLOCK_FOLDED
      let atStart = true
      let str = ''
      let sep = ''
      let prevMoreIndented = false

      for (let i = start; i < end; ++i) {
        for (let j = 0; j < bi; ++j) {
          if (src[i] !== ' ') break
          i += 1
        }

        const ch = src[i]

        if (ch === '\n') {
          if (sep === '\n') str += '\n'
          else sep = '\n'
        } else {
          const lineEnd = PlainValue$5.Node.endOfLine(src, i)
          const line = src.slice(i, lineEnd)
          i = lineEnd

          if (folded && (ch === ' ' || ch === '\t') && i < keepStart) {
            if (sep === ' ') sep = '\n'
            else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n'
            str += sep + line //+ ((lineEnd < end && src[lineEnd]) || '')

            sep = (lineEnd < end && src[lineEnd]) || ''
            prevMoreIndented = true
          } else {
            str += sep + line
            sep = folded && i < keepStart ? ' ' : '\n'
            prevMoreIndented = false
          }

          if (atStart && line !== '') atStart = false
        }
      }

      return this.chomping === Chomp.STRIP ? str : str + '\n'
    }

    parseBlockHeader(start) {
      const { src } = this.context
      let offset = start + 1
      let bi = ''

      while (true) {
        const ch = src[offset]

        switch (ch) {
          case '-':
            this.chomping = Chomp.STRIP
            break

          case '+':
            this.chomping = Chomp.KEEP
            break

          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            bi += ch
            break

          default:
            this.blockIndent = Number(bi) || null
            this.header = new PlainValue$5.Range(start, offset)
            return offset
        }

        offset += 1
      }
    }

    parseBlockValue(start) {
      const { indent, src } = this.context
      const explicit = !!this.blockIndent
      let offset = start
      let valueEnd = start
      let minBlockIndent = 1

      for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
        offset += 1
        if (PlainValue$5.Node.atDocumentBoundary(src, offset)) break
        const end = PlainValue$5.Node.endOfBlockIndent(src, indent, offset) // should not include tab?

        if (end === null) break
        const ch = src[end]
        const lineIndent = end - (offset + indent)

        if (!this.blockIndent) {
          // no explicit block indent, none yet detected
          if (src[end] !== '\n') {
            // first line with non-whitespace content
            if (lineIndent < minBlockIndent) {
              const msg =
                'Block scalars with more-indented leading empty lines must use an explicit indentation indicator'
              this.error = new PlainValue$5.YAMLSemanticError(this, msg)
            }

            this.blockIndent = lineIndent
          } else if (lineIndent > minBlockIndent) {
            // empty line with more whitespace
            minBlockIndent = lineIndent
          }
        } else if (ch && ch !== '\n' && lineIndent < this.blockIndent) {
          if (src[end] === '#') break

          if (!this.error) {
            const src = explicit
              ? 'explicit indentation indicator'
              : 'first line'
            const msg = `Block scalars must not be less indented than their ${src}`
            this.error = new PlainValue$5.YAMLSemanticError(this, msg)
          }
        }

        if (src[end] === '\n') {
          offset = end
        } else {
          offset = valueEnd = PlainValue$5.Node.endOfLine(src, end)
        }
      }

      if (this.chomping !== Chomp.KEEP) {
        offset = src[valueEnd] ? valueEnd + 1 : valueEnd
      }

      this.valueRange = new PlainValue$5.Range(start + 1, offset)
      return offset
    }
    /**
     * Parses a block value from the source
     *
     * Accepted forms are:
     * ```
     * BS
     * block
     * lines
     *
     * BS #comment
     * block
     * lines
     * ```
     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
     * are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this block
     */

    parse(context, start) {
      this.context = context
      const { src } = context
      let offset = this.parseBlockHeader(start)
      offset = PlainValue$5.Node.endOfWhiteSpace(src, offset)
      offset = this.parseComment(offset)
      offset = this.parseBlockValue(offset)
      return offset
    }

    setOrigRanges(cr, offset) {
      offset = super.setOrigRanges(cr, offset)
      return this.header ? this.header.setOrigRange(cr, offset) : offset
    }
  }

  class FlowCollection extends PlainValue$5.Node {
    constructor(type, props) {
      super(type, props)
      this.items = null
    }

    prevNodeIsJsonLike(idx = this.items.length) {
      const node = this.items[idx - 1]
      return (
        !!node &&
        (node.jsonLike ||
          (node.type === PlainValue$5.Type.COMMENT &&
            this.prevNodeIsJsonLike(idx - 1)))
      )
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */

    parse(context, start) {
      this.context = context
      const { parseNode, src } = context
      let { indent, lineStart } = context
      let char = src[start] // { or [

      this.items = [
        {
          char,
          offset: start,
        },
      ]
      let offset = PlainValue$5.Node.endOfWhiteSpace(src, start + 1)
      char = src[offset]

      while (char && char !== ']' && char !== '}') {
        switch (char) {
          case '\n':
            {
              lineStart = offset + 1
              const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src, lineStart)

              if (src[wsEnd] === '\n') {
                const blankLine = new BlankLine()
                lineStart = blankLine.parse(
                  {
                    src,
                  },
                  lineStart,
                )
                this.items.push(blankLine)
              }

              offset = PlainValue$5.Node.endOfIndent(src, lineStart)

              if (offset <= lineStart + indent) {
                char = src[offset]

                if (
                  offset < lineStart + indent ||
                  (char !== ']' && char !== '}')
                ) {
                  const msg = 'Insufficient indentation in flow collection'
                  this.error = new PlainValue$5.YAMLSemanticError(this, msg)
                }
              }
            }
            break

          case ',':
            {
              this.items.push({
                char,
                offset,
              })
              offset += 1
            }
            break

          case '#':
            {
              const comment = new Comment()
              offset = comment.parse(
                {
                  src,
                },
                offset,
              )
              this.items.push(comment)
            }
            break

          case '?':
          case ':': {
            const next = src[offset + 1]

            if (
              next === '\n' ||
              next === '\t' ||
              next === ' ' ||
              next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
              (char === ':' && this.prevNodeIsJsonLike())
            ) {
              this.items.push({
                char,
                offset,
              })
              offset += 1
              break
            }
          }
          // fallthrough

          default: {
            const node = parseNode(
              {
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this,
              },
              offset,
            )

            if (!node) {
              // at next document start
              this.valueRange = new PlainValue$5.Range(start, offset)
              return offset
            }

            this.items.push(node)
            offset = PlainValue$5.Node.normalizeOffset(src, node.range.end)
          }
        }

        offset = PlainValue$5.Node.endOfWhiteSpace(src, offset)
        char = src[offset]
      }

      this.valueRange = new PlainValue$5.Range(start, offset + 1)

      if (char) {
        this.items.push({
          char,
          offset,
        })
        offset = PlainValue$5.Node.endOfWhiteSpace(src, offset + 1)
        offset = this.parseComment(offset)
      }

      return offset
    }

    setOrigRanges(cr, offset) {
      offset = super.setOrigRanges(cr, offset)
      this.items.forEach((node) => {
        if (node instanceof PlainValue$5.Node) {
          offset = node.setOrigRanges(cr, offset)
        } else if (cr.length === 0) {
          node.origOffset = node.offset
        } else {
          let i = offset

          while (i < cr.length) {
            if (cr[i] > node.offset) break
            else ++i
          }

          node.origOffset = node.offset + i
          offset = i
        }
      })
      return offset
    }

    toString() {
      const {
        context: { src },
        items,
        range,
        value,
      } = this
      if (value != null) return value
      const nodes = items.filter((item) => item instanceof PlainValue$5.Node)
      let str = ''
      let prevEnd = range.start
      nodes.forEach((node) => {
        const prefix = src.slice(prevEnd, node.range.start)
        prevEnd = node.range.end
        str += prefix + String(node)

        if (
          str[str.length - 1] === '\n' &&
          src[prevEnd - 1] !== '\n' &&
          src[prevEnd] === '\n'
        ) {
          // Comment range does not include the terminal newline, but its
          // stringified value does. Without this fix, newlines at comment ends
          // get duplicated.
          prevEnd += 1
        }
      })
      str += src.slice(prevEnd, range.end)
      return PlainValue$5.Node.addStringTerminator(src, range.end, str)
    }
  }

  class QuoteDouble extends PlainValue$5.Node {
    static endOfQuote(src, offset) {
      let ch = src[offset]

      while (ch && ch !== '"') {
        offset += ch === '\\' ? 2 : 1
        ch = src[offset]
      }

      return offset + 1
    }
    /**
     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
     */

    get strValue() {
      if (!this.valueRange || !this.context) return null
      const errors = []
      const { start, end } = this.valueRange
      const { indent, src } = this.context
      if (src[end - 1] !== '"')
        errors.push(
          new PlainValue$5.YAMLSyntaxError(this, 'Missing closing "quote'),
        ) // Using String#replace is too painful with escaped newlines preceded by
      // escaped backslashes; also, this should be faster.

      let str = ''

      for (let i = start + 1; i < end - 1; ++i) {
        const ch = src[i]

        if (ch === '\n') {
          if (PlainValue$5.Node.atDocumentBoundary(src, i + 1))
            errors.push(
              new PlainValue$5.YAMLSemanticError(
                this,
                'Document boundary indicators are not allowed within string values',
              ),
            )
          const { fold, offset, error } = PlainValue$5.Node.foldNewline(
            src,
            i,
            indent,
          )
          str += fold
          i = offset
          if (error)
            errors.push(
              new PlainValue$5.YAMLSemanticError(
                this,
                'Multi-line double-quoted string needs to be sufficiently indented',
              ),
            )
        } else if (ch === '\\') {
          i += 1

          switch (src[i]) {
            case '0':
              str += '\0'
              break
            // null character

            case 'a':
              str += '\x07'
              break
            // bell character

            case 'b':
              str += '\b'
              break
            // backspace

            case 'e':
              str += '\x1b'
              break
            // escape character

            case 'f':
              str += '\f'
              break
            // form feed

            case 'n':
              str += '\n'
              break
            // line feed

            case 'r':
              str += '\r'
              break
            // carriage return

            case 't':
              str += '\t'
              break
            // horizontal tab

            case 'v':
              str += '\v'
              break
            // vertical tab

            case 'N':
              str += '\u0085'
              break
            // Unicode next line

            case '_':
              str += '\u00a0'
              break
            // Unicode non-breaking space

            case 'L':
              str += '\u2028'
              break
            // Unicode line separator

            case 'P':
              str += '\u2029'
              break
            // Unicode paragraph separator

            case ' ':
              str += ' '
              break

            case '"':
              str += '"'
              break

            case '/':
              str += '/'
              break

            case '\\':
              str += '\\'
              break

            case '\t':
              str += '\t'
              break

            case 'x':
              str += this.parseCharCode(i + 1, 2, errors)
              i += 2
              break

            case 'u':
              str += this.parseCharCode(i + 1, 4, errors)
              i += 4
              break

            case 'U':
              str += this.parseCharCode(i + 1, 8, errors)
              i += 8
              break

            case '\n':
              // skip escaped newlines, but still trim the following line
              while (src[i + 1] === ' ' || src[i + 1] === '\t') i += 1

              break

            default:
              errors.push(
                new PlainValue$5.YAMLSyntaxError(
                  this,
                  `Invalid escape sequence ${src.substr(i - 1, 2)}`,
                ),
              )
              str += '\\' + src[i]
          }
        } else if (ch === ' ' || ch === '\t') {
          // trim trailing whitespace
          const wsStart = i
          let next = src[i + 1]

          while (next === ' ' || next === '\t') {
            i += 1
            next = src[i + 1]
          }

          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch
        } else {
          str += ch
        }
      }

      return errors.length > 0
        ? {
            errors,
            str,
          }
        : str
    }

    parseCharCode(offset, length, errors) {
      const { src } = this.context
      const cc = src.substr(offset, length)
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc)
      const code = ok ? parseInt(cc, 16) : NaN

      if (isNaN(code)) {
        errors.push(
          new PlainValue$5.YAMLSyntaxError(
            this,
            `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`,
          ),
        )
        return src.substr(offset - 2, length + 2)
      }

      return String.fromCodePoint(code)
    }
    /**
     * Parses a "double quoted" value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */

    parse(context, start) {
      this.context = context
      const { src } = context
      let offset = QuoteDouble.endOfQuote(src, start + 1)
      this.valueRange = new PlainValue$5.Range(start, offset)
      offset = PlainValue$5.Node.endOfWhiteSpace(src, offset)
      offset = this.parseComment(offset)
      return offset
    }
  }

  class QuoteSingle extends PlainValue$5.Node {
    static endOfQuote(src, offset) {
      let ch = src[offset]

      while (ch) {
        if (ch === "'") {
          if (src[offset + 1] !== "'") break
          ch = src[(offset += 2)]
        } else {
          ch = src[(offset += 1)]
        }
      }

      return offset + 1
    }
    /**
     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
     */

    get strValue() {
      if (!this.valueRange || !this.context) return null
      const errors = []
      const { start, end } = this.valueRange
      const { indent, src } = this.context
      if (src[end - 1] !== "'")
        errors.push(
          new PlainValue$5.YAMLSyntaxError(this, "Missing closing 'quote"),
        )
      let str = ''

      for (let i = start + 1; i < end - 1; ++i) {
        const ch = src[i]

        if (ch === '\n') {
          if (PlainValue$5.Node.atDocumentBoundary(src, i + 1))
            errors.push(
              new PlainValue$5.YAMLSemanticError(
                this,
                'Document boundary indicators are not allowed within string values',
              ),
            )
          const { fold, offset, error } = PlainValue$5.Node.foldNewline(
            src,
            i,
            indent,
          )
          str += fold
          i = offset
          if (error)
            errors.push(
              new PlainValue$5.YAMLSemanticError(
                this,
                'Multi-line single-quoted string needs to be sufficiently indented',
              ),
            )
        } else if (ch === "'") {
          str += ch
          i += 1
          if (src[i] !== "'")
            errors.push(
              new PlainValue$5.YAMLSyntaxError(
                this,
                'Unescaped single quote? This should not happen.',
              ),
            )
        } else if (ch === ' ' || ch === '\t') {
          // trim trailing whitespace
          const wsStart = i
          let next = src[i + 1]

          while (next === ' ' || next === '\t') {
            i += 1
            next = src[i + 1]
          }

          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch
        } else {
          str += ch
        }
      }

      return errors.length > 0
        ? {
            errors,
            str,
          }
        : str
    }
    /**
     * Parses a 'single quoted' value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */

    parse(context, start) {
      this.context = context
      const { src } = context
      let offset = QuoteSingle.endOfQuote(src, start + 1)
      this.valueRange = new PlainValue$5.Range(start, offset)
      offset = PlainValue$5.Node.endOfWhiteSpace(src, offset)
      offset = this.parseComment(offset)
      return offset
    }
  }

  function createNewNode(type, props) {
    switch (type) {
      case PlainValue$5.Type.ALIAS:
        return new Alias$1(type, props)

      case PlainValue$5.Type.BLOCK_FOLDED:
      case PlainValue$5.Type.BLOCK_LITERAL:
        return new BlockValue(type, props)

      case PlainValue$5.Type.FLOW_MAP:
      case PlainValue$5.Type.FLOW_SEQ:
        return new FlowCollection(type, props)

      case PlainValue$5.Type.MAP_KEY:
      case PlainValue$5.Type.MAP_VALUE:
      case PlainValue$5.Type.SEQ_ITEM:
        return new CollectionItem(type, props)

      case PlainValue$5.Type.COMMENT:
      case PlainValue$5.Type.PLAIN:
        return new PlainValue$5.PlainValue(type, props)

      case PlainValue$5.Type.QUOTE_DOUBLE:
        return new QuoteDouble(type, props)

      case PlainValue$5.Type.QUOTE_SINGLE:
        return new QuoteSingle(type, props)

      /* istanbul ignore next */

      default:
        return null
      // should never happen
    }
  }
  /**
   * @param {boolean} atLineStart - Node starts at beginning of line
   * @param {boolean} inFlow - true if currently in a flow context
   * @param {boolean} inCollection - true if currently in a collection context
   * @param {number} indent - Current level of indentation
   * @param {number} lineStart - Start of the current line
   * @param {Node} parent - The parent of the node
   * @param {string} src - Source of the YAML document
   */

  class ParseContext {
    static parseType(src, offset, inFlow) {
      switch (src[offset]) {
        case '*':
          return PlainValue$5.Type.ALIAS

        case '>':
          return PlainValue$5.Type.BLOCK_FOLDED

        case '|':
          return PlainValue$5.Type.BLOCK_LITERAL

        case '{':
          return PlainValue$5.Type.FLOW_MAP

        case '[':
          return PlainValue$5.Type.FLOW_SEQ

        case '?':
          return !inFlow && PlainValue$5.Node.atBlank(src, offset + 1, true)
            ? PlainValue$5.Type.MAP_KEY
            : PlainValue$5.Type.PLAIN

        case ':':
          return !inFlow && PlainValue$5.Node.atBlank(src, offset + 1, true)
            ? PlainValue$5.Type.MAP_VALUE
            : PlainValue$5.Type.PLAIN

        case '-':
          return !inFlow && PlainValue$5.Node.atBlank(src, offset + 1, true)
            ? PlainValue$5.Type.SEQ_ITEM
            : PlainValue$5.Type.PLAIN

        case '"':
          return PlainValue$5.Type.QUOTE_DOUBLE

        case "'":
          return PlainValue$5.Type.QUOTE_SINGLE

        default:
          return PlainValue$5.Type.PLAIN
      }
    }

    constructor(
      orig = {},
      { atLineStart, inCollection, inFlow, indent, lineStart, parent } = {},
    ) {
      PlainValue$5._defineProperty(this, 'parseNode', (overlay, start) => {
        if (PlainValue$5.Node.atDocumentBoundary(this.src, start)) return null
        const context = new ParseContext(this, overlay)
        const { props, type, valueStart } = context.parseProps(start)
        const node = createNewNode(type, props)
        let offset = node.parse(context, valueStart)
        node.range = new PlainValue$5.Range(start, offset)
        /* istanbul ignore if */

        if (offset <= start) {
          // This should never happen, but if it does, let's make sure to at least
          // step one character forward to avoid a busy loop.
          node.error = new Error(`Node#parse consumed no characters`)
          node.error.parseEnd = offset
          node.error.source = node
          node.range.end = start + 1
        }

        if (context.nodeStartsCollection(node)) {
          if (
            !node.error &&
            !context.atLineStart &&
            context.parent.type === PlainValue$5.Type.DOCUMENT
          ) {
            node.error = new PlainValue$5.YAMLSyntaxError(
              node,
              'Block collection must not have preceding content here (e.g. directives-end indicator)',
            )
          }

          const collection = new Collection$1(node)
          offset = collection.parse(new ParseContext(context), offset)
          collection.range = new PlainValue$5.Range(start, offset)
          return collection
        }

        return node
      })

      this.atLineStart =
        atLineStart != null ? atLineStart : orig.atLineStart || false
      this.inCollection =
        inCollection != null ? inCollection : orig.inCollection || false
      this.inFlow = inFlow != null ? inFlow : orig.inFlow || false
      this.indent = indent != null ? indent : orig.indent
      this.lineStart = lineStart != null ? lineStart : orig.lineStart
      this.parent = parent != null ? parent : orig.parent || {}
      this.root = orig.root
      this.src = orig.src
    }

    nodeStartsCollection(node) {
      const { inCollection, inFlow, src } = this
      if (inCollection || inFlow) return false
      if (node instanceof CollectionItem) return true // check for implicit key

      let offset = node.range.end
      if (src[offset] === '\n' || src[offset - 1] === '\n') return false
      offset = PlainValue$5.Node.endOfWhiteSpace(src, offset)
      return src[offset] === ':'
    } // Anchor and tag are before type, which determines the node implementation
    // class; hence this intermediate step.

    parseProps(offset) {
      const { inFlow, parent, src } = this
      const props = []
      let lineHasProps = false
      offset = this.atLineStart
        ? PlainValue$5.Node.endOfIndent(src, offset)
        : PlainValue$5.Node.endOfWhiteSpace(src, offset)
      let ch = src[offset]

      while (
        ch === PlainValue$5.Char.ANCHOR ||
        ch === PlainValue$5.Char.COMMENT ||
        ch === PlainValue$5.Char.TAG ||
        ch === '\n'
      ) {
        if (ch === '\n') {
          let inEnd = offset
          let lineStart

          do {
            lineStart = inEnd + 1
            inEnd = PlainValue$5.Node.endOfIndent(src, lineStart)
          } while (src[inEnd] === '\n')

          const indentDiff = inEnd - (lineStart + this.indent)
          const noIndicatorAsIndent =
            parent.type === PlainValue$5.Type.SEQ_ITEM &&
            parent.context.atLineStart
          if (
            src[inEnd] !== '#' &&
            !PlainValue$5.Node.nextNodeIsIndented(
              src[inEnd],
              indentDiff,
              !noIndicatorAsIndent,
            )
          )
            break
          this.atLineStart = true
          this.lineStart = lineStart
          lineHasProps = false
          offset = inEnd
        } else if (ch === PlainValue$5.Char.COMMENT) {
          const end = PlainValue$5.Node.endOfLine(src, offset + 1)
          props.push(new PlainValue$5.Range(offset, end))
          offset = end
        } else {
          let end = PlainValue$5.Node.endOfIdentifier(src, offset + 1)

          if (
            ch === PlainValue$5.Char.TAG &&
            src[end] === ',' &&
            /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(
              src.slice(offset + 1, end + 13),
            )
          ) {
            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
            // than an empty but 'foo.bar' private-tagged node in a flow collection
            // followed without whitespace by a plain string starting with a year
            // or date divided by something.
            end = PlainValue$5.Node.endOfIdentifier(src, end + 5)
          }

          props.push(new PlainValue$5.Range(offset, end))
          lineHasProps = true
          offset = PlainValue$5.Node.endOfWhiteSpace(src, end)
        }

        ch = src[offset]
      } // '- &a : b' has an anchor on an empty node

      if (
        lineHasProps &&
        ch === ':' &&
        PlainValue$5.Node.atBlank(src, offset + 1, true)
      )
        offset -= 1
      const type = ParseContext.parseType(src, offset, inFlow)
      return {
        props,
        type,
        valueStart: offset,
      }
    }
    /**
     * Parses a node from the source
     * @param {ParseContext} overlay
     * @param {number} start - Index of first non-whitespace character for the node
     * @returns {?Node} - null if at a document boundary
     */
  } // Published as 'yaml/parse-cst'

  function parse$1(src) {
    const cr = []

    if (src.indexOf('\r') !== -1) {
      src = src.replace(/\r\n?/g, (match, offset) => {
        if (match.length > 1) cr.push(offset)
        return '\n'
      })
    }

    const documents = []
    let offset = 0

    do {
      const doc = new Document$3()
      const context = new ParseContext({
        src,
      })
      offset = doc.parse(context, offset)
      documents.push(doc)
    } while (offset < src.length)

    documents.setOrigRanges = () => {
      if (cr.length === 0) return false

      for (let i = 1; i < cr.length; ++i) cr[i] -= i

      let crOffset = 0

      for (let i = 0; i < documents.length; ++i) {
        crOffset = documents[i].setOrigRanges(cr, crOffset)
      }

      cr.splice(0, cr.length)
      return true
    }

    documents.toString = () => documents.join('...\n')

    return documents
  }

  parseCst$1.parse = parse$1

  var Document9b4560a1 = {}

  var resolveSeqD03cb037 = {}

  var PlainValue$4 = PlainValueEc8e588e

  function addCommentBefore(str, indent, comment) {
    if (!comment) return str
    const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`)
    return `#${cc}\n${indent}${str}`
  }

  function addComment(str, indent, comment) {
    return !comment
      ? str
      : comment.indexOf('\n') === -1
      ? `${str} #${comment}`
      : `${str}\n` + comment.replace(/^/gm, `${indent || ''}#`)
  }

  class Node {}

  function toJSON(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJSON(v, String(i), ctx))

    if (value && typeof value.toJSON === 'function') {
      const anchor = ctx && ctx.anchors && ctx.anchors.get(value)
      if (anchor)
        ctx.onCreate = (res) => {
          anchor.res = res
          delete ctx.onCreate
        }
      const res = value.toJSON(arg, ctx)
      if (anchor && ctx.onCreate) ctx.onCreate(res)
      return res
    }

    if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value)
    return value
  }

  class Scalar extends Node {
    constructor(value) {
      super()
      this.value = value
    }

    toJSON(arg, ctx) {
      return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx)
    }

    toString() {
      return String(this.value)
    }
  }

  function collectionFromPath(schema, path, value) {
    let v = value

    for (let i = path.length - 1; i >= 0; --i) {
      const k = path[i]

      if (Number.isInteger(k) && k >= 0) {
        const a = []
        a[k] = v
        v = a
      } else {
        const o = {}
        Object.defineProperty(o, k, {
          value: v,
          writable: true,
          enumerable: true,
          configurable: true,
        })
        v = o
      }
    }

    return schema.createNode(v, false)
  } // null, undefined, or an empty non-string iterable (e.g. [])

  const isEmptyPath = (path) =>
    path == null ||
    (typeof path === 'object' && path[Symbol.iterator]().next().done)

  class Collection extends Node {
    constructor(schema) {
      super()

      PlainValue$4._defineProperty(this, 'items', [])

      this.schema = schema
    }

    addIn(path, value) {
      if (isEmptyPath(path)) this.add(value)
      else {
        const [key, ...rest] = path
        const node = this.get(key, true)
        if (node instanceof Collection) node.addIn(rest, value)
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value))
        else
          throw new Error(
            `Expected YAML collection at ${key}. Remaining path: ${rest}`,
          )
      }
    }

    deleteIn([key, ...rest]) {
      if (rest.length === 0) return this.delete(key)
      const node = this.get(key, true)
      if (node instanceof Collection) return node.deleteIn(rest)
      else
        throw new Error(
          `Expected YAML collection at ${key}. Remaining path: ${rest}`,
        )
    }

    getIn([key, ...rest], keepScalar) {
      const node = this.get(key, true)
      if (rest.length === 0)
        return !keepScalar && node instanceof Scalar ? node.value : node
      else
        return node instanceof Collection
          ? node.getIn(rest, keepScalar)
          : undefined
    }

    hasAllNullValues() {
      return this.items.every((node) => {
        if (!node || node.type !== 'PAIR') return false
        const n = node.value
        return (
          n == null ||
          (n instanceof Scalar &&
            n.value == null &&
            !n.commentBefore &&
            !n.comment &&
            !n.tag)
        )
      })
    }

    hasIn([key, ...rest]) {
      if (rest.length === 0) return this.has(key)
      const node = this.get(key, true)
      return node instanceof Collection ? node.hasIn(rest) : false
    }

    setIn([key, ...rest], value) {
      if (rest.length === 0) {
        this.set(key, value)
      } else {
        const node = this.get(key, true)
        if (node instanceof Collection) node.setIn(rest, value)
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value))
        else
          throw new Error(
            `Expected YAML collection at ${key}. Remaining path: ${rest}`,
          )
      }
    } // overridden in implementations

    /* istanbul ignore next */

    toJSON() {
      return null
    }

    toString(
      ctx,
      { blockItem, flowChars, isMap, itemIndent },
      onComment,
      onChompKeep,
    ) {
      const { indent, indentStep, stringify } = ctx
      const inFlow =
        this.type === PlainValue$4.Type.FLOW_MAP ||
        this.type === PlainValue$4.Type.FLOW_SEQ ||
        ctx.inFlow
      if (inFlow) itemIndent += indentStep
      const allNullValues = isMap && this.hasAllNullValues()
      ctx = Object.assign({}, ctx, {
        allNullValues,
        indent: itemIndent,
        inFlow,
        type: null,
      })
      let chompKeep = false
      let hasItemWithNewLine = false
      const nodes = this.items.reduce((nodes, item, i) => {
        let comment

        if (item) {
          if (!chompKeep && item.spaceBefore)
            nodes.push({
              type: 'comment',
              str: '',
            })
          if (item.commentBefore)
            item.commentBefore.match(/^.*$/gm).forEach((line) => {
              nodes.push({
                type: 'comment',
                str: `#${line}`,
              })
            })
          if (item.comment) comment = item.comment
          if (
            inFlow &&
            ((!chompKeep && item.spaceBefore) ||
              item.commentBefore ||
              item.comment ||
              (item.key && (item.key.commentBefore || item.key.comment)) ||
              (item.value && (item.value.commentBefore || item.value.comment)))
          )
            hasItemWithNewLine = true
        }

        chompKeep = false
        let str = stringify(
          item,
          ctx,
          () => (comment = null),
          () => (chompKeep = true),
        )
        if (inFlow && !hasItemWithNewLine && str.includes('\n'))
          hasItemWithNewLine = true
        if (inFlow && i < this.items.length - 1) str += ','
        str = addComment(str, itemIndent, comment)
        if (chompKeep && (comment || inFlow)) chompKeep = false
        nodes.push({
          type: 'item',
          str,
        })
        return nodes
      }, [])
      let str

      if (nodes.length === 0) {
        str = flowChars.start + flowChars.end
      } else if (inFlow) {
        const { start, end } = flowChars
        const strings = nodes.map((n) => n.str)

        if (
          hasItemWithNewLine ||
          strings.reduce((sum, str) => sum + str.length + 2, 2) >
            Collection.maxFlowStringSingleLineLength
        ) {
          str = start

          for (const s of strings) {
            str += s ? `\n${indentStep}${indent}${s}` : '\n'
          }

          str += `\n${indent}${end}`
        } else {
          str = `${start} ${strings.join(' ')} ${end}`
        }
      } else {
        const strings = nodes.map(blockItem)
        str = strings.shift()

        for (const s of strings) str += s ? `\n${indent}${s}` : '\n'
      }

      if (this.comment) {
        str += '\n' + this.comment.replace(/^/gm, `${indent}#`)
        if (onComment) onComment()
      } else if (chompKeep && onChompKeep) onChompKeep()

      return str
    }
  }

  PlainValue$4._defineProperty(Collection, 'maxFlowStringSingleLineLength', 60)

  function asItemIndex(key) {
    let idx = key instanceof Scalar ? key.value : key
    if (idx && typeof idx === 'string') idx = Number(idx)
    return Number.isInteger(idx) && idx >= 0 ? idx : null
  }

  class YAMLSeq extends Collection {
    add(value) {
      this.items.push(value)
    }

    delete(key) {
      const idx = asItemIndex(key)
      if (typeof idx !== 'number') return false
      const del = this.items.splice(idx, 1)
      return del.length > 0
    }

    get(key, keepScalar) {
      const idx = asItemIndex(key)
      if (typeof idx !== 'number') return undefined
      const it = this.items[idx]
      return !keepScalar && it instanceof Scalar ? it.value : it
    }

    has(key) {
      const idx = asItemIndex(key)
      return typeof idx === 'number' && idx < this.items.length
    }

    set(key, value) {
      const idx = asItemIndex(key)
      if (typeof idx !== 'number')
        throw new Error(`Expected a valid index, not ${key}.`)
      this.items[idx] = value
    }

    toJSON(_, ctx) {
      const seq = []
      if (ctx && ctx.onCreate) ctx.onCreate(seq)
      let i = 0

      for (const item of this.items) seq.push(toJSON(item, String(i++), ctx))

      return seq
    }

    toString(ctx, onComment, onChompKeep) {
      if (!ctx) return JSON.stringify(this)
      return super.toString(
        ctx,
        {
          blockItem: (n) => (n.type === 'comment' ? n.str : `- ${n.str}`),
          flowChars: {
            start: '[',
            end: ']',
          },
          isMap: false,
          itemIndent: (ctx.indent || '') + '  ',
        },
        onComment,
        onChompKeep,
      )
    }
  }

  const stringifyKey = (key, jsKey, ctx) => {
    if (jsKey === null) return ''
    if (typeof jsKey !== 'object') return String(jsKey)
    if (key instanceof Node && ctx && ctx.doc)
      return key.toString({
        anchors: Object.create(null),
        doc: ctx.doc,
        indent: '',
        indentStep: ctx.indentStep,
        inFlow: true,
        inStringifyKey: true,
        stringify: ctx.stringify,
      })
    return JSON.stringify(jsKey)
  }

  class Pair extends Node {
    constructor(key, value = null) {
      super()
      this.key = key
      this.value = value
      this.type = Pair.Type.PAIR
    }

    get commentBefore() {
      return this.key instanceof Node ? this.key.commentBefore : undefined
    }

    set commentBefore(cb) {
      if (this.key == null) this.key = new Scalar(null)
      if (this.key instanceof Node) this.key.commentBefore = cb
      else {
        const msg =
          'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.'
        throw new Error(msg)
      }
    }

    addToJSMap(ctx, map) {
      const key = toJSON(this.key, '', ctx)

      if (map instanceof Map) {
        const value = toJSON(this.value, key, ctx)
        map.set(key, value)
      } else if (map instanceof Set) {
        map.add(key)
      } else {
        const stringKey = stringifyKey(this.key, key, ctx)
        const value = toJSON(this.value, stringKey, ctx)
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value,
            writable: true,
            enumerable: true,
            configurable: true,
          })
        else map[stringKey] = value
      }

      return map
    }

    toJSON(_, ctx) {
      const pair = ctx && ctx.mapAsMap ? new Map() : {}
      return this.addToJSMap(ctx, pair)
    }

    toString(ctx, onComment, onChompKeep) {
      if (!ctx || !ctx.doc) return JSON.stringify(this)
      const { indent: indentSize, indentSeq, simpleKeys } = ctx.doc.options
      let { key, value } = this
      let keyComment = key instanceof Node && key.comment

      if (simpleKeys) {
        if (keyComment) {
          throw new Error('With simple keys, key nodes cannot have comments')
        }

        if (key instanceof Collection) {
          const msg =
            'With simple keys, collection cannot be used as a key value'
          throw new Error(msg)
        }
      }

      let explicitKey =
        !simpleKeys &&
        (!key ||
          keyComment ||
          (key instanceof Node
            ? key instanceof Collection ||
              key.type === PlainValue$4.Type.BLOCK_FOLDED ||
              key.type === PlainValue$4.Type.BLOCK_LITERAL
            : typeof key === 'object'))
      const { doc, indent, indentStep, stringify } = ctx
      ctx = Object.assign({}, ctx, {
        implicitKey: !explicitKey,
        indent: indent + indentStep,
      })
      let chompKeep = false
      let str = stringify(
        key,
        ctx,
        () => (keyComment = null),
        () => (chompKeep = true),
      )
      str = addComment(str, ctx.indent, keyComment)

      if (!explicitKey && str.length > 1024) {
        if (simpleKeys)
          throw new Error(
            'With simple keys, single line scalar must not span more than 1024 characters',
          )
        explicitKey = true
      }

      if (ctx.allNullValues && !simpleKeys) {
        if (this.comment) {
          str = addComment(str, ctx.indent, this.comment)
          if (onComment) onComment()
        } else if (chompKeep && !keyComment && onChompKeep) onChompKeep()

        return ctx.inFlow && !explicitKey ? str : `? ${str}`
      }

      str = explicitKey ? `? ${str}\n${indent}:` : `${str}:`

      if (this.comment) {
        // expected (but not strictly required) to be a single-line comment
        str = addComment(str, ctx.indent, this.comment)
        if (onComment) onComment()
      }

      let vcb = ''
      let valueComment = null

      if (value instanceof Node) {
        if (value.spaceBefore) vcb = '\n'

        if (value.commentBefore) {
          const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`)
          vcb += `\n${cs}`
        }

        valueComment = value.comment
      } else if (value && typeof value === 'object') {
        value = doc.schema.createNode(value, true)
      }

      ctx.implicitKey = false
      if (!explicitKey && !this.comment && value instanceof Scalar)
        ctx.indentAtStart = str.length + 1
      chompKeep = false

      if (
        !indentSeq &&
        indentSize >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        value instanceof YAMLSeq &&
        value.type !== PlainValue$4.Type.FLOW_SEQ &&
        !value.tag &&
        !doc.anchors.getName(value)
      ) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substr(2)
      }

      const valueStr = stringify(
        value,
        ctx,
        () => (valueComment = null),
        () => (chompKeep = true),
      )
      let ws = ' '

      if (vcb || this.comment) {
        ws = `${vcb}\n${ctx.indent}`
      } else if (!explicitKey && value instanceof Collection) {
        const flow = valueStr[0] === '[' || valueStr[0] === '{'
        if (!flow || valueStr.includes('\n')) ws = `\n${ctx.indent}`
      } else if (valueStr[0] === '\n') ws = ''

      if (chompKeep && !valueComment && onChompKeep) onChompKeep()
      return addComment(str + ws + valueStr, ctx.indent, valueComment)
    }
  }

  PlainValue$4._defineProperty(Pair, 'Type', {
    PAIR: 'PAIR',
    MERGE_PAIR: 'MERGE_PAIR',
  })

  const getAliasCount = (node, anchors) => {
    if (node instanceof Alias) {
      const anchor = anchors.get(node.source)
      return anchor.count * anchor.aliasCount
    } else if (node instanceof Collection) {
      let count = 0

      for (const item of node.items) {
        const c = getAliasCount(item, anchors)
        if (c > count) count = c
      }

      return count
    } else if (node instanceof Pair) {
      const kc = getAliasCount(node.key, anchors)
      const vc = getAliasCount(node.value, anchors)
      return Math.max(kc, vc)
    }

    return 1
  }

  class Alias extends Node {
    static stringify(
      { range, source },
      { anchors, doc, implicitKey, inStringifyKey },
    ) {
      let anchor = Object.keys(anchors).find((a) => anchors[a] === source)
      if (!anchor && inStringifyKey)
        anchor = doc.anchors.getName(source) || doc.anchors.newName()
      if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`
      const msg = doc.anchors.getName(source)
        ? 'Alias node must be after source node'
        : 'Source node not found for alias node'
      throw new Error(`${msg} [${range}]`)
    }

    constructor(source) {
      super()
      this.source = source
      this.type = PlainValue$4.Type.ALIAS
    }

    set tag(t) {
      throw new Error('Alias nodes cannot have tags')
    }

    toJSON(arg, ctx) {
      if (!ctx) return toJSON(this.source, arg, ctx)
      const { anchors, maxAliasCount } = ctx
      const anchor = anchors.get(this.source)
      /* istanbul ignore if */

      if (!anchor || anchor.res === undefined) {
        const msg = 'This should not happen: Alias anchor was not resolved?'
        if (this.cstNode)
          throw new PlainValue$4.YAMLReferenceError(this.cstNode, msg)
        else throw new ReferenceError(msg)
      }

      if (maxAliasCount >= 0) {
        anchor.count += 1
        if (anchor.aliasCount === 0)
          anchor.aliasCount = getAliasCount(this.source, anchors)

        if (anchor.count * anchor.aliasCount > maxAliasCount) {
          const msg =
            'Excessive alias count indicates a resource exhaustion attack'
          if (this.cstNode)
            throw new PlainValue$4.YAMLReferenceError(this.cstNode, msg)
          else throw new ReferenceError(msg)
        }
      }

      return anchor.res
    } // Only called when stringifying an alias mapping key while constructing
    // Object output.

    toString(ctx) {
      return Alias.stringify(this, ctx)
    }
  }

  PlainValue$4._defineProperty(Alias, 'default', true)

  function findPair(items, key) {
    const k = key instanceof Scalar ? key.value : key

    for (const it of items) {
      if (it instanceof Pair) {
        if (it.key === key || it.key === k) return it
        if (it.key && it.key.value === k) return it
      }
    }

    return undefined
  }

  class YAMLMap extends Collection {
    add(pair, overwrite) {
      if (!pair) pair = new Pair(pair)
      else if (!(pair instanceof Pair))
        pair = new Pair(pair.key || pair, pair.value)
      const prev = findPair(this.items, pair.key)
      const sortEntries = this.schema && this.schema.sortMapEntries

      if (prev) {
        if (overwrite) prev.value = pair.value
        else throw new Error(`Key ${pair.key} already set`)
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(pair, item) < 0)
        if (i === -1) this.items.push(pair)
        else this.items.splice(i, 0, pair)
      } else {
        this.items.push(pair)
      }
    }

    delete(key) {
      const it = findPair(this.items, key)
      if (!it) return false
      const del = this.items.splice(this.items.indexOf(it), 1)
      return del.length > 0
    }

    get(key, keepScalar) {
      const it = findPair(this.items, key)
      const node = it && it.value
      return !keepScalar && node instanceof Scalar ? node.value : node
    }

    has(key) {
      return !!findPair(this.items, key)
    }

    set(key, value) {
      this.add(new Pair(key, value), true)
    }
    /**
     * @param {*} arg ignored
     * @param {*} ctx Conversion context, originally set in Document#toJSON()
     * @param {Class} Type If set, forces the returned collection type
     * @returns {*} Instance of Type, Map, or Object
     */

    toJSON(_, ctx, Type) {
      const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {}
      if (ctx && ctx.onCreate) ctx.onCreate(map)

      for (const item of this.items) item.addToJSMap(ctx, map)

      return map
    }

    toString(ctx, onComment, onChompKeep) {
      if (!ctx) return JSON.stringify(this)

      for (const item of this.items) {
        if (!(item instanceof Pair))
          throw new Error(
            `Map items must all be pairs; found ${JSON.stringify(
              item,
            )} instead`,
          )
      }

      return super.toString(
        ctx,
        {
          blockItem: (n) => n.str,
          flowChars: {
            start: '{',
            end: '}',
          },
          isMap: true,
          itemIndent: ctx.indent || '',
        },
        onComment,
        onChompKeep,
      )
    }
  }

  const MERGE_KEY = '<<'

  class Merge extends Pair {
    constructor(pair) {
      if (pair instanceof Pair) {
        let seq = pair.value

        if (!(seq instanceof YAMLSeq)) {
          seq = new YAMLSeq()
          seq.items.push(pair.value)
          seq.range = pair.value.range
        }

        super(pair.key, seq)
        this.range = pair.range
      } else {
        super(new Scalar(MERGE_KEY), new YAMLSeq())
      }

      this.type = Pair.Type.MERGE_PAIR
    } // If the value associated with a merge key is a single mapping node, each of
    // its key/value pairs is inserted into the current mapping, unless the key
    // already exists in it. If the value associated with the merge key is a
    // sequence, then this sequence is expected to contain mapping nodes and each
    // of these nodes is merged in turn according to its order in the sequence.
    // Keys in mapping nodes earlier in the sequence override keys specified in
    // later mapping nodes. -- http://yaml.org/type/merge.html

    addToJSMap(ctx, map) {
      for (const { source } of this.value.items) {
        if (!(source instanceof YAMLMap))
          throw new Error('Merge sources must be maps')
        const srcMap = source.toJSON(null, ctx, Map)

        for (const [key, value] of srcMap) {
          if (map instanceof Map) {
            if (!map.has(key)) map.set(key, value)
          } else if (map instanceof Set) {
            map.add(key)
          } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
              value,
              writable: true,
              enumerable: true,
              configurable: true,
            })
          }
        }
      }

      return map
    }

    toString(ctx, onComment) {
      const seq = this.value
      if (seq.items.length > 1) return super.toString(ctx, onComment)
      this.value = seq.items[0]
      const str = super.toString(ctx, onComment)
      this.value = seq
      return str
    }
  }

  const binaryOptions = {
    defaultType: PlainValue$4.Type.BLOCK_LITERAL,
    lineWidth: 76,
  }
  const boolOptions = {
    trueStr: 'true',
    falseStr: 'false',
  }
  const intOptions = {
    asBigInt: false,
  }
  const nullOptions = {
    nullStr: 'null',
  }
  const strOptions = {
    defaultType: PlainValue$4.Type.PLAIN,
    doubleQuoted: {
      jsonEncoding: false,
      minMultiLineLength: 40,
    },
    fold: {
      lineWidth: 80,
      minContentWidth: 20,
    },
  }

  function resolveScalar(str, tags, scalarFallback) {
    for (const { format, test, resolve } of tags) {
      if (test) {
        const match = str.match(test)

        if (match) {
          let res = resolve.apply(null, match)
          if (!(res instanceof Scalar)) res = new Scalar(res)
          if (format) res.format = format
          return res
        }
      }
    }

    if (scalarFallback) str = scalarFallback(str)
    return new Scalar(str)
  }

  const FOLD_FLOW = 'flow'
  const FOLD_BLOCK = 'block'
  const FOLD_QUOTED = 'quoted' // presumes i+1 is at the start of a line
  // returns index of last newline in more-indented block

  const consumeMoreIndentedLines = (text, i) => {
    let ch = text[i + 1]

    while (ch === ' ' || ch === '\t') {
      do {
        ch = text[(i += 1)]
      } while (ch && ch !== '\n')

      ch = text[i + 1]
    }

    return i
  }
  /**
   * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
   * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
   * terminated with `\n` and started with `indent`.
   *
   * @param {string} text
   * @param {string} indent
   * @param {string} [mode='flow'] `'block'` prevents more-indented lines
   *   from being folded; `'quoted'` allows for `\` escapes, including escaped
   *   newlines
   * @param {Object} options
   * @param {number} [options.indentAtStart] Accounts for leading contents on
   *   the first line, defaulting to `indent.length`
   * @param {number} [options.lineWidth=80]
   * @param {number} [options.minContentWidth=20] Allow highly indented lines to
   *   stretch the line width or indent content from the start
   * @param {function} options.onFold Called once if the text is folded
   * @param {function} options.onFold Called once if any line of text exceeds
   *   lineWidth characters
   */

  function foldFlowLines(
    text,
    indent,
    mode,
    { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow },
  ) {
    if (!lineWidth || lineWidth < 0) return text
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length)
    if (text.length <= endStep) return text
    const folds = []
    const escapedFolds = {}
    let end = lineWidth - indent.length

    if (typeof indentAtStart === 'number') {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0)
      else end = lineWidth - indentAtStart
    }

    let split = undefined
    let prev = undefined
    let overflow = false
    let i = -1
    let escStart = -1
    let escEnd = -1

    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i)
      if (i !== -1) end = i + endStep
    }

    for (let ch; (ch = text[(i += 1)]); ) {
      if (mode === FOLD_QUOTED && ch === '\\') {
        escStart = i

        switch (text[i + 1]) {
          case 'x':
            i += 3
            break

          case 'u':
            i += 5
            break

          case 'U':
            i += 9
            break

          default:
            i += 1
        }

        escEnd = i
      }

      if (ch === '\n') {
        if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i)
        end = i + endStep
        split = undefined
      } else {
        if (
          ch === ' ' &&
          prev &&
          prev !== ' ' &&
          prev !== '\n' &&
          prev !== '\t'
        ) {
          // space surrounded by non-space can be replaced with newline + indent
          const next = text[i + 1]
          if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i
        }

        if (i >= end) {
          if (split) {
            folds.push(split)
            end = split + endStep
            split = undefined
          } else if (mode === FOLD_QUOTED) {
            // white-space collected at end may stretch past lineWidth
            while (prev === ' ' || prev === '\t') {
              prev = ch
              ch = text[(i += 1)]
              overflow = true
            } // Account for newline escape, but don't break preceding escape

            const j = i > escEnd + 1 ? i - 2 : escStart - 1 // Bail out if lineWidth & minContentWidth are shorter than an escape string

            if (escapedFolds[j]) return text
            folds.push(j)
            escapedFolds[j] = true
            end = j + endStep
            split = undefined
          } else {
            overflow = true
          }
        }
      }

      prev = ch
    }

    if (overflow && onOverflow) onOverflow()
    if (folds.length === 0) return text
    if (onFold) onFold()
    let res = text.slice(0, folds[0])

    for (let i = 0; i < folds.length; ++i) {
      const fold = folds[i]
      const end = folds[i + 1] || text.length
      if (fold === 0) res = `\n${indent}${text.slice(0, end)}`
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`
        res += `\n${indent}${text.slice(fold + 1, end)}`
      }
    }

    return res
  }

  const getFoldOptions = ({ indentAtStart }) =>
    indentAtStart
      ? Object.assign(
          {
            indentAtStart,
          },
          strOptions.fold,
        )
      : strOptions.fold // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
  // presume that's starting a new document.

  const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str)

  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0) return false
    const limit = lineWidth - indentLength
    const strLen = str.length
    if (strLen <= limit) return false

    for (let i = 0, start = 0; i < strLen; ++i) {
      if (str[i] === '\n') {
        if (i - start > limit) return true
        start = i + 1
        if (strLen - start <= limit) return false
      }
    }

    return true
  }

  function doubleQuotedString(value, ctx) {
    const { implicitKey } = ctx
    const { jsonEncoding, minMultiLineLength } = strOptions.doubleQuoted
    const json = JSON.stringify(value)
    if (jsonEncoding) return json
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '')
    let str = ''
    let start = 0

    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
      if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
        // space before newline needs to be escaped to not be folded
        str += json.slice(start, i) + '\\ '
        i += 1
        start = i
        ch = '\\'
      }

      if (ch === '\\')
        switch (json[i + 1]) {
          case 'u':
            {
              str += json.slice(start, i)
              const code = json.substr(i + 2, 4)

              switch (code) {
                case '0000':
                  str += '\\0'
                  break

                case '0007':
                  str += '\\a'
                  break

                case '000b':
                  str += '\\v'
                  break

                case '001b':
                  str += '\\e'
                  break

                case '0085':
                  str += '\\N'
                  break

                case '00a0':
                  str += '\\_'
                  break

                case '2028':
                  str += '\\L'
                  break

                case '2029':
                  str += '\\P'
                  break

                default:
                  if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2)
                  else str += json.substr(i, 6)
              }

              i += 5
              start = i + 1
            }
            break

          case 'n':
            if (
              implicitKey ||
              json[i + 2] === '"' ||
              json.length < minMultiLineLength
            ) {
              i += 1
            } else {
              // folding will eat first newline
              str += json.slice(start, i) + '\n\n'

              while (
                json[i + 2] === '\\' &&
                json[i + 3] === 'n' &&
                json[i + 4] !== '"'
              ) {
                str += '\n'
                i += 2
              }

              str += indent // space after newline needs to be escaped to not be folded

              if (json[i + 2] === ' ') str += '\\'
              i += 1
              start = i + 1
            }

            break

          default:
            i += 1
        }
    }

    str = start ? str + json.slice(start) : json
    return implicitKey
      ? str
      : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx))
  }

  function singleQuotedString(value, ctx) {
    if (ctx.implicitKey) {
      if (/\n/.test(value)) return doubleQuotedString(value, ctx)
    } else {
      // single quoted string can't have leading or trailing whitespace around newline
      if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx)
    }

    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '')
    const res =
      "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'"
    return ctx.implicitKey
      ? res
      : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx))
  }

  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
      return doubleQuotedString(value, ctx)
    }

    const indent =
      ctx.indent ||
      (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '')
    const indentSize = indent ? '2' : '1' // root is at -1

    const literal =
      type === PlainValue$4.Type.BLOCK_FOLDED
        ? false
        : type === PlainValue$4.Type.BLOCK_LITERAL
        ? true
        : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length)
    let header = literal ? '|' : '>'
    if (!value) return header + '\n'
    let wsStart = ''
    let wsEnd = ''
    value = value
      .replace(/[\n\t ]*$/, (ws) => {
        const n = ws.indexOf('\n')

        if (n === -1) {
          header += '-' // strip
        } else if (value === ws || n !== ws.length - 1) {
          header += '+' // keep

          if (onChompKeep) onChompKeep()
        }

        wsEnd = ws.replace(/\n$/, '')
        return ''
      })
      .replace(/^[\n ]*/, (ws) => {
        if (ws.indexOf(' ') !== -1) header += indentSize
        const m = ws.match(/ +$/)

        if (m) {
          wsStart = ws.slice(0, -m[0].length)
          return m[0]
        } else {
          wsStart = ws
          return ''
        }
      })
    if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`)
    if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`)

    if (comment) {
      header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ')
      if (onComment) onComment()
    }

    if (!value) return `${header}${indentSize}\n${indent}${wsEnd}`

    if (literal) {
      value = value.replace(/\n+/g, `$&${indent}`)
      return `${header}\n${indent}${wsStart}${value}${wsEnd}`
    }

    value = value
      .replace(/\n+/g, '\n$&')
      .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
      //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
      .replace(/\n+/g, `$&${indent}`)
    const body = foldFlowLines(
      `${wsStart}${value}${wsEnd}`,
      indent,
      FOLD_BLOCK,
      strOptions.fold,
    )
    return `${header}\n${indent}${body}`
  }

  function plainString(item, ctx, onComment, onChompKeep) {
    const { comment, type, value } = item
    const { actualString, implicitKey, indent, inFlow } = ctx

    if (
      (implicitKey && /[\n[\]{},]/.test(value)) ||
      (inFlow && /[[\]{},]/.test(value))
    ) {
      return doubleQuotedString(value, ctx)
    }

    if (
      !value ||
      /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(
        value,
      )
    ) {
      // not allowed:
      // - empty string, '-' or '?'
      // - start with an indicator character (except [?:-]) or /[?-] /
      // - '\n ', ': ' or ' \n' anywhere
      // - '#' not preceded by a non-space char
      // - end with ' ' or ':'
      return implicitKey || inFlow || value.indexOf('\n') === -1
        ? value.indexOf('"') !== -1 && value.indexOf("'") === -1
          ? singleQuotedString(value, ctx)
          : doubleQuotedString(value, ctx)
        : blockString(item, ctx, onComment, onChompKeep)
    }

    if (
      !implicitKey &&
      !inFlow &&
      type !== PlainValue$4.Type.PLAIN &&
      value.indexOf('\n') !== -1
    ) {
      // Where allowed & type not set explicitly, prefer block style for multiline strings
      return blockString(item, ctx, onComment, onChompKeep)
    }

    if (indent === '' && containsDocumentMarker(value)) {
      ctx.forceBlockIndent = true
      return blockString(item, ctx, onComment, onChompKeep)
    }

    const str = value.replace(/\n+/g, `$&\n${indent}`) // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.

    if (actualString) {
      const { tags } = ctx.doc.schema
      const resolved = resolveScalar(str, tags, tags.scalarFallback).value
      if (typeof resolved !== 'string') return doubleQuotedString(value, ctx)
    }

    const body = implicitKey
      ? str
      : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx))

    if (
      comment &&
      !inFlow &&
      (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)
    ) {
      if (onComment) onComment()
      return addCommentBefore(body, indent, comment)
    }

    return body
  }

  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { defaultType } = strOptions
    const { implicitKey, inFlow } = ctx
    let { type, value } = item

    if (typeof value !== 'string') {
      value = String(value)
      item = Object.assign({}, item, {
        value,
      })
    }

    const _stringify = (_type) => {
      switch (_type) {
        case PlainValue$4.Type.BLOCK_FOLDED:
        case PlainValue$4.Type.BLOCK_LITERAL:
          return blockString(item, ctx, onComment, onChompKeep)

        case PlainValue$4.Type.QUOTE_DOUBLE:
          return doubleQuotedString(value, ctx)

        case PlainValue$4.Type.QUOTE_SINGLE:
          return singleQuotedString(value, ctx)

        case PlainValue$4.Type.PLAIN:
          return plainString(item, ctx, onComment, onChompKeep)

        default:
          return null
      }
    }

    if (
      type !== PlainValue$4.Type.QUOTE_DOUBLE &&
      /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)
    ) {
      // force double quotes on control characters
      type = PlainValue$4.Type.QUOTE_DOUBLE
    } else if (
      (implicitKey || inFlow) &&
      (type === PlainValue$4.Type.BLOCK_FOLDED ||
        type === PlainValue$4.Type.BLOCK_LITERAL)
    ) {
      // should not happen; blocks are not valid inside flow containers
      type = PlainValue$4.Type.QUOTE_DOUBLE
    }

    let res = _stringify(type)

    if (res === null) {
      res = _stringify(defaultType)
      if (res === null)
        throw new Error(`Unsupported default string type ${defaultType}`)
    }

    return res
  }

  function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint') return String(value)
    if (!isFinite(value))
      return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf'
    let n = JSON.stringify(value)

    if (
      !format &&
      minFractionDigits &&
      (!tag || tag === 'tag:yaml.org,2002:float') &&
      /^\d/.test(n)
    ) {
      let i = n.indexOf('.')

      if (i < 0) {
        i = n.length
        n += '.'
      }

      let d = minFractionDigits - (n.length - i - 1)

      while (d-- > 0) n += '0'
    }

    return n
  }

  function checkFlowCollectionEnd(errors, cst) {
    let char, name

    switch (cst.type) {
      case PlainValue$4.Type.FLOW_MAP:
        char = '}'
        name = 'flow map'
        break

      case PlainValue$4.Type.FLOW_SEQ:
        char = ']'
        name = 'flow sequence'
        break

      default:
        errors.push(
          new PlainValue$4.YAMLSemanticError(cst, 'Not a flow collection!?'),
        )
        return
    }

    let lastItem

    for (let i = cst.items.length - 1; i >= 0; --i) {
      const item = cst.items[i]

      if (!item || item.type !== PlainValue$4.Type.COMMENT) {
        lastItem = item
        break
      }
    }

    if (lastItem && lastItem.char !== char) {
      const msg = `Expected ${name} to end with ${char}`
      let err

      if (typeof lastItem.offset === 'number') {
        err = new PlainValue$4.YAMLSemanticError(cst, msg)
        err.offset = lastItem.offset + 1
      } else {
        err = new PlainValue$4.YAMLSemanticError(lastItem, msg)
        if (lastItem.range && lastItem.range.end)
          err.offset = lastItem.range.end - lastItem.range.start
      }

      errors.push(err)
    }
  }

  function checkFlowCommentSpace(errors, comment) {
    const prev = comment.context.src[comment.range.start - 1]

    if (prev !== '\n' && prev !== '\t' && prev !== ' ') {
      const msg =
        'Comments must be separated from other tokens by white space characters'
      errors.push(new PlainValue$4.YAMLSemanticError(comment, msg))
    }
  }

  function getLongKeyError(source, key) {
    const sk = String(key)
    const k = sk.substr(0, 8) + '...' + sk.substr(-8)
    return new PlainValue$4.YAMLSemanticError(
      source,
      `The "${k}" key is too long`,
    )
  }

  function resolveComments(collection, comments) {
    for (const { afterKey, before, comment } of comments) {
      let item = collection.items[before]

      if (!item) {
        if (comment !== undefined) {
          if (collection.comment) collection.comment += '\n' + comment
          else collection.comment = comment
        }
      } else {
        if (afterKey && item.value) item = item.value

        if (comment === undefined) {
          if (afterKey || !item.commentBefore) item.spaceBefore = true
        } else {
          if (item.commentBefore) item.commentBefore += '\n' + comment
          else item.commentBefore = comment
        }
      }
    }
  } // on error, will return { str: string, errors: Error[] }

  function resolveString(doc, node) {
    const res = node.strValue
    if (!res) return ''
    if (typeof res === 'string') return res
    res.errors.forEach((error) => {
      if (!error.source) error.source = node
      doc.errors.push(error)
    })
    return res.str
  }

  function resolveTagHandle(doc, node) {
    const { handle, suffix } = node.tag
    let prefix = doc.tagPrefixes.find((p) => p.handle === handle)

    if (!prefix) {
      const dtp = doc.getDefaults().tagPrefixes
      if (dtp) prefix = dtp.find((p) => p.handle === handle)
      if (!prefix)
        throw new PlainValue$4.YAMLSemanticError(
          node,
          `The ${handle} tag handle is non-default and was not declared.`,
        )
    }

    if (!suffix)
      throw new PlainValue$4.YAMLSemanticError(
        node,
        `The ${handle} tag has no suffix.`,
      )

    if (handle === '!' && (doc.version || doc.options.version) === '1.0') {
      if (suffix[0] === '^') {
        doc.warnings.push(
          new PlainValue$4.YAMLWarning(
            node,
            'YAML 1.0 ^ tag expansion is not supported',
          ),
        )
        return suffix
      }

      if (/[:/]/.test(suffix)) {
        // word/foo -> tag:word.yaml.org,2002:foo
        const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i)
        return vocab
          ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}`
          : `tag:${suffix}`
      }
    }

    return prefix.prefix + decodeURIComponent(suffix)
  }

  function resolveTagName(doc, node) {
    const { tag, type } = node
    let nonSpecific = false

    if (tag) {
      const { handle, suffix, verbatim } = tag

      if (verbatim) {
        if (verbatim !== '!' && verbatim !== '!!') return verbatim
        const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`
        doc.errors.push(new PlainValue$4.YAMLSemanticError(node, msg))
      } else if (handle === '!' && !suffix) {
        nonSpecific = true
      } else {
        try {
          return resolveTagHandle(doc, node)
        } catch (error) {
          doc.errors.push(error)
        }
      }
    }

    switch (type) {
      case PlainValue$4.Type.BLOCK_FOLDED:
      case PlainValue$4.Type.BLOCK_LITERAL:
      case PlainValue$4.Type.QUOTE_DOUBLE:
      case PlainValue$4.Type.QUOTE_SINGLE:
        return PlainValue$4.defaultTags.STR

      case PlainValue$4.Type.FLOW_MAP:
      case PlainValue$4.Type.MAP:
        return PlainValue$4.defaultTags.MAP

      case PlainValue$4.Type.FLOW_SEQ:
      case PlainValue$4.Type.SEQ:
        return PlainValue$4.defaultTags.SEQ

      case PlainValue$4.Type.PLAIN:
        return nonSpecific ? PlainValue$4.defaultTags.STR : null

      default:
        return null
    }
  }

  function resolveByTagName(doc, node, tagName) {
    const { tags } = doc.schema
    const matchWithTest = []

    for (const tag of tags) {
      if (tag.tag === tagName) {
        if (tag.test) matchWithTest.push(tag)
        else {
          const res = tag.resolve(doc, node)
          return res instanceof Collection ? res : new Scalar(res)
        }
      }
    }

    const str = resolveString(doc, node)
    if (typeof str === 'string' && matchWithTest.length > 0)
      return resolveScalar(str, matchWithTest, tags.scalarFallback)
    return null
  }

  function getFallbackTagName({ type }) {
    switch (type) {
      case PlainValue$4.Type.FLOW_MAP:
      case PlainValue$4.Type.MAP:
        return PlainValue$4.defaultTags.MAP

      case PlainValue$4.Type.FLOW_SEQ:
      case PlainValue$4.Type.SEQ:
        return PlainValue$4.defaultTags.SEQ

      default:
        return PlainValue$4.defaultTags.STR
    }
  }

  function resolveTag(doc, node, tagName) {
    try {
      const res = resolveByTagName(doc, node, tagName)

      if (res) {
        if (tagName && node.tag) res.tag = tagName
        return res
      }
    } catch (error) {
      /* istanbul ignore if */
      if (!error.source) error.source = node
      doc.errors.push(error)
      return null
    }

    try {
      const fallback = getFallbackTagName(node)
      if (!fallback) throw new Error(`The tag ${tagName} is unavailable`)
      const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`
      doc.warnings.push(new PlainValue$4.YAMLWarning(node, msg))
      const res = resolveByTagName(doc, node, fallback)
      res.tag = tagName
      return res
    } catch (error) {
      const refError = new PlainValue$4.YAMLReferenceError(node, error.message)
      refError.stack = error.stack
      doc.errors.push(refError)
      return null
    }
  }

  const isCollectionItem = (node) => {
    if (!node) return false
    const { type } = node
    return (
      type === PlainValue$4.Type.MAP_KEY ||
      type === PlainValue$4.Type.MAP_VALUE ||
      type === PlainValue$4.Type.SEQ_ITEM
    )
  }

  function resolveNodeProps(errors, node) {
    const comments = {
      before: [],
      after: [],
    }
    let hasAnchor = false
    let hasTag = false
    const props = isCollectionItem(node.context.parent)
      ? node.context.parent.props.concat(node.props)
      : node.props

    for (const { start, end } of props) {
      switch (node.context.src[start]) {
        case PlainValue$4.Char.COMMENT: {
          if (!node.commentHasRequiredWhitespace(start)) {
            const msg =
              'Comments must be separated from other tokens by white space characters'
            errors.push(new PlainValue$4.YAMLSemanticError(node, msg))
          }

          const { header, valueRange } = node
          const cc =
            valueRange &&
            (start > valueRange.start || (header && start > header.start))
              ? comments.after
              : comments.before
          cc.push(node.context.src.slice(start + 1, end))
          break
        }
        // Actual anchor & tag resolution is handled by schema, here we just complain

        case PlainValue$4.Char.ANCHOR:
          if (hasAnchor) {
            const msg = 'A node can have at most one anchor'
            errors.push(new PlainValue$4.YAMLSemanticError(node, msg))
          }

          hasAnchor = true
          break

        case PlainValue$4.Char.TAG:
          if (hasTag) {
            const msg = 'A node can have at most one tag'
            errors.push(new PlainValue$4.YAMLSemanticError(node, msg))
          }

          hasTag = true
          break
      }
    }

    return {
      comments,
      hasAnchor,
      hasTag,
    }
  }

  function resolveNodeValue(doc, node) {
    const { anchors, errors, schema } = doc

    if (node.type === PlainValue$4.Type.ALIAS) {
      const name = node.rawValue
      const src = anchors.getNode(name)

      if (!src) {
        const msg = `Aliased anchor not found: ${name}`
        errors.push(new PlainValue$4.YAMLReferenceError(node, msg))
        return null
      } // Lazy resolution for circular references

      const res = new Alias(src)

      anchors._cstAliases.push(res)

      return res
    }

    const tagName = resolveTagName(doc, node)
    if (tagName) return resolveTag(doc, node, tagName)

    if (node.type !== PlainValue$4.Type.PLAIN) {
      const msg = `Failed to resolve ${node.type} node here`
      errors.push(new PlainValue$4.YAMLSyntaxError(node, msg))
      return null
    }

    try {
      const str = resolveString(doc, node)
      return resolveScalar(str, schema.tags, schema.tags.scalarFallback)
    } catch (error) {
      if (!error.source) error.source = node
      errors.push(error)
      return null
    }
  } // sets node.resolved on success

  function resolveNode(doc, node) {
    if (!node) return null
    if (node.error) doc.errors.push(node.error)
    const { comments, hasAnchor, hasTag } = resolveNodeProps(doc.errors, node)

    if (hasAnchor) {
      const { anchors } = doc
      const name = node.anchor
      const prev = anchors.getNode(name) // At this point, aliases for any preceding node with the same anchor
      // name have already been resolved, so it may safely be renamed.

      if (prev) anchors.map[anchors.newName(name)] = prev // During parsing, we need to store the CST node in anchors.map as
      // anchors need to be available during resolution to allow for
      // circular references.

      anchors.map[name] = node
    }

    if (node.type === PlainValue$4.Type.ALIAS && (hasAnchor || hasTag)) {
      const msg = 'An alias node must not specify any properties'
      doc.errors.push(new PlainValue$4.YAMLSemanticError(node, msg))
    }

    const res = resolveNodeValue(doc, node)

    if (res) {
      res.range = [node.range.start, node.range.end]
      if (doc.options.keepCstNodes) res.cstNode = node
      if (doc.options.keepNodeTypes) res.type = node.type
      const cb = comments.before.join('\n')

      if (cb) {
        res.commentBefore = res.commentBefore
          ? `${res.commentBefore}\n${cb}`
          : cb
      }

      const ca = comments.after.join('\n')
      if (ca) res.comment = res.comment ? `${res.comment}\n${ca}` : ca
    }

    return (node.resolved = res)
  }

  function resolveMap(doc, cst) {
    if (
      cst.type !== PlainValue$4.Type.MAP &&
      cst.type !== PlainValue$4.Type.FLOW_MAP
    ) {
      const msg = `A ${cst.type} node cannot be resolved as a mapping`
      doc.errors.push(new PlainValue$4.YAMLSyntaxError(cst, msg))
      return null
    }

    const { comments, items } =
      cst.type === PlainValue$4.Type.FLOW_MAP
        ? resolveFlowMapItems(doc, cst)
        : resolveBlockMapItems(doc, cst)
    const map = new YAMLMap()
    map.items = items
    resolveComments(map, comments)
    let hasCollectionKey = false

    for (let i = 0; i < items.length; ++i) {
      const { key: iKey } = items[i]
      if (iKey instanceof Collection) hasCollectionKey = true

      if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
        items[i] = new Merge(items[i])
        const sources = items[i].value.items
        let error = null
        sources.some((node) => {
          if (node instanceof Alias) {
            // During parsing, alias sources are CST nodes; to account for
            // circular references their resolved values can't be used here.
            const { type } = node.source
            if (
              type === PlainValue$4.Type.MAP ||
              type === PlainValue$4.Type.FLOW_MAP
            )
              return false
            return (error = 'Merge nodes aliases can only point to maps')
          }

          return (error = 'Merge nodes can only have Alias nodes as values')
        })
        if (error)
          doc.errors.push(new PlainValue$4.YAMLSemanticError(cst, error))
      } else {
        for (let j = i + 1; j < items.length; ++j) {
          const { key: jKey } = items[j]

          if (
            iKey === jKey ||
            (iKey &&
              jKey &&
              Object.prototype.hasOwnProperty.call(iKey, 'value') &&
              iKey.value === jKey.value)
          ) {
            const msg = `Map keys must be unique; "${iKey}" is repeated`
            doc.errors.push(new PlainValue$4.YAMLSemanticError(cst, msg))
            break
          }
        }
      }
    }

    if (hasCollectionKey && !doc.options.mapAsMap) {
      const warn =
        'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.'
      doc.warnings.push(new PlainValue$4.YAMLWarning(cst, warn))
    }

    cst.resolved = map
    return map
  }

  const valueHasPairComment = ({
    context: { lineStart, node, src },
    props,
  }) => {
    if (props.length === 0) return false
    const { start } = props[0]
    if (node && start > node.valueRange.start) return false
    if (src[start] !== PlainValue$4.Char.COMMENT) return false

    for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false

    return true
  }

  function resolvePairComment(item, pair) {
    if (!valueHasPairComment(item)) return
    const comment = item.getPropValue(0, PlainValue$4.Char.COMMENT, true)
    let found = false
    const cb = pair.value.commentBefore

    if (cb && cb.startsWith(comment)) {
      pair.value.commentBefore = cb.substr(comment.length + 1)
      found = true
    } else {
      const cc = pair.value.comment

      if (!item.node && cc && cc.startsWith(comment)) {
        pair.value.comment = cc.substr(comment.length + 1)
        found = true
      }
    }

    if (found) pair.comment = comment
  }

  function resolveBlockMapItems(doc, cst) {
    const comments = []
    const items = []
    let key = undefined
    let keyStart = null

    for (let i = 0; i < cst.items.length; ++i) {
      const item = cst.items[i]

      switch (item.type) {
        case PlainValue$4.Type.BLANK_LINE:
          comments.push({
            afterKey: !!key,
            before: items.length,
          })
          break

        case PlainValue$4.Type.COMMENT:
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment,
          })
          break

        case PlainValue$4.Type.MAP_KEY:
          if (key !== undefined) items.push(new Pair(key))
          if (item.error) doc.errors.push(item.error)
          key = resolveNode(doc, item.node)
          keyStart = null
          break

        case PlainValue$4.Type.MAP_VALUE:
          {
            if (key === undefined) key = null
            if (item.error) doc.errors.push(item.error)

            if (
              !item.context.atLineStart &&
              item.node &&
              item.node.type === PlainValue$4.Type.MAP &&
              !item.node.context.atLineStart
            ) {
              const msg = 'Nested mappings are not allowed in compact mappings'
              doc.errors.push(
                new PlainValue$4.YAMLSemanticError(item.node, msg),
              )
            }

            let valueNode = item.node

            if (!valueNode && item.props.length > 0) {
              // Comments on an empty mapping value need to be preserved, so we
              // need to construct a minimal empty node here to use instead of the
              // missing `item.node`. -- eemeli/yaml#19
              valueNode = new PlainValue$4.PlainValue(
                PlainValue$4.Type.PLAIN,
                [],
              )
              valueNode.context = {
                parent: item,
                src: item.context.src,
              }
              const pos = item.range.start + 1
              valueNode.range = {
                start: pos,
                end: pos,
              }
              valueNode.valueRange = {
                start: pos,
                end: pos,
              }

              if (typeof item.range.origStart === 'number') {
                const origPos = item.range.origStart + 1
                valueNode.range.origStart = valueNode.range.origEnd = origPos
                valueNode.valueRange.origStart = valueNode.valueRange.origEnd =
                  origPos
              }
            }

            const pair = new Pair(key, resolveNode(doc, valueNode))
            resolvePairComment(item, pair)
            items.push(pair)

            if (key && typeof keyStart === 'number') {
              if (item.range.start > keyStart + 1024)
                doc.errors.push(getLongKeyError(cst, key))
            }

            key = undefined
            keyStart = null
          }
          break

        default:
          if (key !== undefined) items.push(new Pair(key))
          key = resolveNode(doc, item)
          keyStart = item.range.start
          if (item.error) doc.errors.push(item.error)

          next: for (let j = i + 1; ; ++j) {
            const nextItem = cst.items[j]

            switch (nextItem && nextItem.type) {
              case PlainValue$4.Type.BLANK_LINE:
              case PlainValue$4.Type.COMMENT:
                continue next

              case PlainValue$4.Type.MAP_VALUE:
                break next

              default: {
                const msg =
                  'Implicit map keys need to be followed by map values'
                doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg))
                break next
              }
            }
          }

          if (item.valueRangeContainsNewline) {
            const msg = 'Implicit map keys need to be on a single line'
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg))
          }
      }
    }

    if (key !== undefined) items.push(new Pair(key))
    return {
      comments,
      items,
    }
  }

  function resolveFlowMapItems(doc, cst) {
    const comments = []
    const items = []
    let key = undefined
    let explicitKey = false
    let next = '{'

    for (let i = 0; i < cst.items.length; ++i) {
      const item = cst.items[i]

      if (typeof item.char === 'string') {
        const { char, offset } = item

        if (char === '?' && key === undefined && !explicitKey) {
          explicitKey = true
          next = ':'
          continue
        }

        if (char === ':') {
          if (key === undefined) key = null

          if (next === ':') {
            next = ','
            continue
          }
        } else {
          if (explicitKey) {
            if (key === undefined && char !== ',') key = null
            explicitKey = false
          }

          if (key !== undefined) {
            items.push(new Pair(key))
            key = undefined

            if (char === ',') {
              next = ':'
              continue
            }
          }
        }

        if (char === '}') {
          if (i === cst.items.length - 1) continue
        } else if (char === next) {
          next = ':'
          continue
        }

        const msg = `Flow map contains an unexpected ${char}`
        const err = new PlainValue$4.YAMLSyntaxError(cst, msg)
        err.offset = offset
        doc.errors.push(err)
      } else if (item.type === PlainValue$4.Type.BLANK_LINE) {
        comments.push({
          afterKey: !!key,
          before: items.length,
        })
      } else if (item.type === PlainValue$4.Type.COMMENT) {
        checkFlowCommentSpace(doc.errors, item)
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment,
        })
      } else if (key === undefined) {
        if (next === ',')
          doc.errors.push(
            new PlainValue$4.YAMLSemanticError(
              item,
              'Separator , missing in flow map',
            ),
          )
        key = resolveNode(doc, item)
      } else {
        if (next !== ',')
          doc.errors.push(
            new PlainValue$4.YAMLSemanticError(
              item,
              'Indicator : missing in flow map entry',
            ),
          )
        items.push(new Pair(key, resolveNode(doc, item)))
        key = undefined
        explicitKey = false
      }
    }

    checkFlowCollectionEnd(doc.errors, cst)
    if (key !== undefined) items.push(new Pair(key))
    return {
      comments,
      items,
    }
  }

  function resolveSeq$3(doc, cst) {
    if (
      cst.type !== PlainValue$4.Type.SEQ &&
      cst.type !== PlainValue$4.Type.FLOW_SEQ
    ) {
      const msg = `A ${cst.type} node cannot be resolved as a sequence`
      doc.errors.push(new PlainValue$4.YAMLSyntaxError(cst, msg))
      return null
    }

    const { comments, items } =
      cst.type === PlainValue$4.Type.FLOW_SEQ
        ? resolveFlowSeqItems(doc, cst)
        : resolveBlockSeqItems(doc, cst)
    const seq = new YAMLSeq()
    seq.items = items
    resolveComments(seq, comments)

    if (
      !doc.options.mapAsMap &&
      items.some((it) => it instanceof Pair && it.key instanceof Collection)
    ) {
      const warn =
        'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.'
      doc.warnings.push(new PlainValue$4.YAMLWarning(cst, warn))
    }

    cst.resolved = seq
    return seq
  }

  function resolveBlockSeqItems(doc, cst) {
    const comments = []
    const items = []

    for (let i = 0; i < cst.items.length; ++i) {
      const item = cst.items[i]

      switch (item.type) {
        case PlainValue$4.Type.BLANK_LINE:
          comments.push({
            before: items.length,
          })
          break

        case PlainValue$4.Type.COMMENT:
          comments.push({
            comment: item.comment,
            before: items.length,
          })
          break

        case PlainValue$4.Type.SEQ_ITEM:
          if (item.error) doc.errors.push(item.error)
          items.push(resolveNode(doc, item.node))

          if (item.hasProps) {
            const msg =
              'Sequence items cannot have tags or anchors before the - indicator'
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg))
          }

          break

        default:
          if (item.error) doc.errors.push(item.error)
          doc.errors.push(
            new PlainValue$4.YAMLSyntaxError(
              item,
              `Unexpected ${item.type} node in sequence`,
            ),
          )
      }
    }

    return {
      comments,
      items,
    }
  }

  function resolveFlowSeqItems(doc, cst) {
    const comments = []
    const items = []
    let explicitKey = false
    let key = undefined
    let keyStart = null
    let next = '['
    let prevItem = null

    for (let i = 0; i < cst.items.length; ++i) {
      const item = cst.items[i]

      if (typeof item.char === 'string') {
        const { char, offset } = item

        if (char !== ':' && (explicitKey || key !== undefined)) {
          if (explicitKey && key === undefined) key = next ? items.pop() : null
          items.push(new Pair(key))
          explicitKey = false
          key = undefined
          keyStart = null
        }

        if (char === next) {
          next = null
        } else if (!next && char === '?') {
          explicitKey = true
        } else if (next !== '[' && char === ':' && key === undefined) {
          if (next === ',') {
            key = items.pop()

            if (key instanceof Pair) {
              const msg = 'Chaining flow sequence pairs is invalid'
              const err = new PlainValue$4.YAMLSemanticError(cst, msg)
              err.offset = offset
              doc.errors.push(err)
            }

            if (!explicitKey && typeof keyStart === 'number') {
              const keyEnd = item.range ? item.range.start : item.offset
              if (keyEnd > keyStart + 1024)
                doc.errors.push(getLongKeyError(cst, key))
              const { src } = prevItem.context

              for (let i = keyStart; i < keyEnd; ++i)
                if (src[i] === '\n') {
                  const msg =
                    'Implicit keys of flow sequence pairs need to be on a single line'
                  doc.errors.push(
                    new PlainValue$4.YAMLSemanticError(prevItem, msg),
                  )
                  break
                }
            }
          } else {
            key = null
          }

          keyStart = null
          explicitKey = false
          next = null
        } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
          const msg = `Flow sequence contains an unexpected ${char}`
          const err = new PlainValue$4.YAMLSyntaxError(cst, msg)
          err.offset = offset
          doc.errors.push(err)
        }
      } else if (item.type === PlainValue$4.Type.BLANK_LINE) {
        comments.push({
          before: items.length,
        })
      } else if (item.type === PlainValue$4.Type.COMMENT) {
        checkFlowCommentSpace(doc.errors, item)
        comments.push({
          comment: item.comment,
          before: items.length,
        })
      } else {
        if (next) {
          const msg = `Expected a ${next} in flow sequence`
          doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg))
        }

        const value = resolveNode(doc, item)

        if (key === undefined) {
          items.push(value)
          prevItem = item
        } else {
          items.push(new Pair(key, value))
          key = undefined
        }

        keyStart = item.range.start
        next = ','
      }
    }

    checkFlowCollectionEnd(doc.errors, cst)
    if (key !== undefined) items.push(new Pair(key))
    return {
      comments,
      items,
    }
  }

  resolveSeqD03cb037.Alias = Alias
  resolveSeqD03cb037.Collection = Collection
  resolveSeqD03cb037.Merge = Merge
  resolveSeqD03cb037.Node = Node
  resolveSeqD03cb037.Pair = Pair
  resolveSeqD03cb037.Scalar = Scalar
  resolveSeqD03cb037.YAMLMap = YAMLMap
  resolveSeqD03cb037.YAMLSeq = YAMLSeq
  resolveSeqD03cb037.addComment = addComment
  resolveSeqD03cb037.binaryOptions = binaryOptions
  resolveSeqD03cb037.boolOptions = boolOptions
  resolveSeqD03cb037.findPair = findPair
  resolveSeqD03cb037.intOptions = intOptions
  resolveSeqD03cb037.isEmptyPath = isEmptyPath
  resolveSeqD03cb037.nullOptions = nullOptions
  resolveSeqD03cb037.resolveMap = resolveMap
  resolveSeqD03cb037.resolveNode = resolveNode
  resolveSeqD03cb037.resolveSeq = resolveSeq$3
  resolveSeqD03cb037.resolveString = resolveString
  resolveSeqD03cb037.strOptions = strOptions
  resolveSeqD03cb037.stringifyNumber = stringifyNumber
  resolveSeqD03cb037.stringifyString = stringifyString
  resolveSeqD03cb037.toJSON = toJSON

  var Schema88e323a7 = {}

  var warnings1000a372 = {}

  var PlainValue$3 = PlainValueEc8e588e

  var resolveSeq$2 = resolveSeqD03cb037
  /* global atob, btoa, Buffer */

  const binary = {
    identify: (value) => value instanceof Uint8Array,
    // Buffer inherits from Uint8Array
    default: false,
    tag: 'tag:yaml.org,2002:binary',

    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve: (doc, node) => {
      const src = resolveSeq$2.resolveString(doc, node)

      if (typeof Buffer === 'function') {
        return Buffer.from(src, 'base64')
      } else if (typeof atob === 'function') {
        // On IE 11, atob() can't handle newlines
        const str = atob(src.replace(/[\n\r]/g, ''))
        const buffer = new Uint8Array(str.length)

        for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i)

        return buffer
      } else {
        const msg =
          'This environment does not support reading binary tags; either Buffer or atob is required'
        doc.errors.push(new PlainValue$3.YAMLReferenceError(node, msg))
        return null
      }
    },
    options: resolveSeq$2.binaryOptions,
    stringify: ({ comment, type, value }, ctx, onComment, onChompKeep) => {
      let src

      if (typeof Buffer === 'function') {
        src =
          value instanceof Buffer
            ? value.toString('base64')
            : Buffer.from(value.buffer).toString('base64')
      } else if (typeof btoa === 'function') {
        let s = ''

        for (let i = 0; i < value.length; ++i)
          s += String.fromCharCode(value[i])

        src = btoa(s)
      } else {
        throw new Error(
          'This environment does not support writing binary tags; either Buffer or btoa is required',
        )
      }

      if (!type) type = resolveSeq$2.binaryOptions.defaultType

      if (type === PlainValue$3.Type.QUOTE_DOUBLE) {
        value = src
      } else {
        const { lineWidth } = resolveSeq$2.binaryOptions
        const n = Math.ceil(src.length / lineWidth)
        const lines = new Array(n)

        for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
          lines[i] = src.substr(o, lineWidth)
        }

        value = lines.join(
          type === PlainValue$3.Type.BLOCK_LITERAL ? '\n' : ' ',
        )
      }

      return resolveSeq$2.stringifyString(
        {
          comment,
          type,
          value,
        },
        ctx,
        onComment,
        onChompKeep,
      )
    },
  }

  function parsePairs(doc, cst) {
    const seq = resolveSeq$2.resolveSeq(doc, cst)

    for (let i = 0; i < seq.items.length; ++i) {
      let item = seq.items[i]
      if (item instanceof resolveSeq$2.Pair) continue
      else if (item instanceof resolveSeq$2.YAMLMap) {
        if (item.items.length > 1) {
          const msg = 'Each pair must have its own sequence indicator'
          throw new PlainValue$3.YAMLSemanticError(cst, msg)
        }

        const pair = item.items[0] || new resolveSeq$2.Pair()
        if (item.commentBefore)
          pair.commentBefore = pair.commentBefore
            ? `${item.commentBefore}\n${pair.commentBefore}`
            : item.commentBefore
        if (item.comment)
          pair.comment = pair.comment
            ? `${item.comment}\n${pair.comment}`
            : item.comment
        item = pair
      }
      seq.items[i] =
        item instanceof resolveSeq$2.Pair ? item : new resolveSeq$2.Pair(item)
    }

    return seq
  }

  function createPairs(schema, iterable, ctx) {
    const pairs = new resolveSeq$2.YAMLSeq(schema)
    pairs.tag = 'tag:yaml.org,2002:pairs'

    for (const it of iterable) {
      let key, value

      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0]
          value = it[1]
        } else throw new TypeError(`Expected [key, value] tuple: ${it}`)
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it)

        if (keys.length === 1) {
          key = keys[0]
          value = it[key]
        } else throw new TypeError(`Expected { key: value } tuple: ${it}`)
      } else {
        key = it
      }

      const pair = schema.createPair(key, value, ctx)
      pairs.items.push(pair)
    }

    return pairs
  }

  const pairs = {
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: parsePairs,
    createNode: createPairs,
  }

  class YAMLOMap extends resolveSeq$2.YAMLSeq {
    constructor() {
      super()

      PlainValue$3._defineProperty(
        this,
        'add',
        resolveSeq$2.YAMLMap.prototype.add.bind(this),
      )

      PlainValue$3._defineProperty(
        this,
        'delete',
        resolveSeq$2.YAMLMap.prototype.delete.bind(this),
      )

      PlainValue$3._defineProperty(
        this,
        'get',
        resolveSeq$2.YAMLMap.prototype.get.bind(this),
      )

      PlainValue$3._defineProperty(
        this,
        'has',
        resolveSeq$2.YAMLMap.prototype.has.bind(this),
      )

      PlainValue$3._defineProperty(
        this,
        'set',
        resolveSeq$2.YAMLMap.prototype.set.bind(this),
      )

      this.tag = YAMLOMap.tag
    }

    toJSON(_, ctx) {
      const map = new Map()
      if (ctx && ctx.onCreate) ctx.onCreate(map)

      for (const pair of this.items) {
        let key, value

        if (pair instanceof resolveSeq$2.Pair) {
          key = resolveSeq$2.toJSON(pair.key, '', ctx)
          value = resolveSeq$2.toJSON(pair.value, key, ctx)
        } else {
          key = resolveSeq$2.toJSON(pair, '', ctx)
        }

        if (map.has(key))
          throw new Error('Ordered maps must not include duplicate keys')
        map.set(key, value)
      }

      return map
    }
  }

  PlainValue$3._defineProperty(YAMLOMap, 'tag', 'tag:yaml.org,2002:omap')

  function parseOMap(doc, cst) {
    const pairs = parsePairs(doc, cst)
    const seenKeys = []

    for (const { key } of pairs.items) {
      if (key instanceof resolveSeq$2.Scalar) {
        if (seenKeys.includes(key.value)) {
          const msg = 'Ordered maps must not include duplicate keys'
          throw new PlainValue$3.YAMLSemanticError(cst, msg)
        } else {
          seenKeys.push(key.value)
        }
      }
    }

    return Object.assign(new YAMLOMap(), pairs)
  }

  function createOMap(schema, iterable, ctx) {
    const pairs = createPairs(schema, iterable, ctx)
    const omap = new YAMLOMap()
    omap.items = pairs.items
    return omap
  }

  const omap = {
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve: parseOMap,
    createNode: createOMap,
  }

  class YAMLSet extends resolveSeq$2.YAMLMap {
    constructor() {
      super()
      this.tag = YAMLSet.tag
    }

    add(key) {
      const pair =
        key instanceof resolveSeq$2.Pair ? key : new resolveSeq$2.Pair(key)
      const prev = resolveSeq$2.findPair(this.items, pair.key)
      if (!prev) this.items.push(pair)
    }

    get(key, keepPair) {
      const pair = resolveSeq$2.findPair(this.items, key)
      return !keepPair && pair instanceof resolveSeq$2.Pair
        ? pair.key instanceof resolveSeq$2.Scalar
          ? pair.key.value
          : pair.key
        : pair
    }

    set(key, value) {
      if (typeof value !== 'boolean')
        throw new Error(
          `Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`,
        )
      const prev = resolveSeq$2.findPair(this.items, key)

      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1)
      } else if (!prev && value) {
        this.items.push(new resolveSeq$2.Pair(key))
      }
    }

    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set)
    }

    toString(ctx, onComment, onChompKeep) {
      if (!ctx) return JSON.stringify(this)
      if (this.hasAllNullValues())
        return super.toString(ctx, onComment, onChompKeep)
      else throw new Error('Set items must all have null values')
    }
  }

  PlainValue$3._defineProperty(YAMLSet, 'tag', 'tag:yaml.org,2002:set')

  function parseSet(doc, cst) {
    const map = resolveSeq$2.resolveMap(doc, cst)
    if (!map.hasAllNullValues())
      throw new PlainValue$3.YAMLSemanticError(
        cst,
        'Set items must all have null values',
      )
    return Object.assign(new YAMLSet(), map)
  }

  function createSet(schema, iterable, ctx) {
    const set = new YAMLSet()

    for (const value of iterable)
      set.items.push(schema.createPair(value, null, ctx))

    return set
  }

  const set = {
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    resolve: parseSet,
    createNode: createSet,
  }

  const parseSexagesimal = (sign, parts) => {
    const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0)
    return sign === '-' ? -n : n
  } // hhhh:mm:ss.sss

  const stringifySexagesimal = ({ value }) => {
    if (isNaN(value) || !isFinite(value))
      return resolveSeq$2.stringifyNumber(value)
    let sign = ''

    if (value < 0) {
      sign = '-'
      value = Math.abs(value)
    }

    const parts = [value % 60] // seconds, including ms

    if (value < 60) {
      parts.unshift(0) // at least one : is required
    } else {
      value = Math.round((value - parts[0]) / 60)
      parts.unshift(value % 60) // minutes

      if (value >= 60) {
        value = Math.round((value - parts[0]) / 60)
        parts.unshift(value) // hours
      }
    }

    return (
      sign +
      parts
        .map((n) => (n < 10 ? '0' + String(n) : String(n)))
        .join(':')
        .replace(/000000\d*$/, '') // % 60 may introduce error
    )
  }

  const intTime = {
    identify: (value) => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
    resolve: (str, sign, parts) =>
      parseSexagesimal(sign, parts.replace(/_/g, '')),
    stringify: stringifySexagesimal,
  }
  const floatTime = {
    identify: (value) => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
    resolve: (str, sign, parts) =>
      parseSexagesimal(sign, parts.replace(/_/g, '')),
    stringify: stringifySexagesimal,
  }
  const timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp(
      '^(?:' +
        '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?' +
        ')$',
    ),
    resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
      if (millisec) millisec = (millisec + '00').substr(1, 3)
      let date = Date.UTC(
        year,
        month - 1,
        day,
        hour || 0,
        minute || 0,
        second || 0,
        millisec || 0,
      )

      if (tz && tz !== 'Z') {
        let d = parseSexagesimal(tz[0], tz.slice(1))
        if (Math.abs(d) < 30) d *= 60
        date -= 60000 * d
      }

      return new Date(date)
    },
    stringify: ({ value }) =>
      value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, ''),
  }
  /* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */

  function shouldWarn(deprecation) {
    const env = (typeof process !== 'undefined' && process.env) || {}

    if (deprecation) {
      if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined')
        return !YAML_SILENCE_DEPRECATION_WARNINGS
      return !env.YAML_SILENCE_DEPRECATION_WARNINGS
    }

    if (typeof YAML_SILENCE_WARNINGS !== 'undefined')
      return !YAML_SILENCE_WARNINGS
    return !env.YAML_SILENCE_WARNINGS
  }

  function warn(warning, type) {
    if (shouldWarn(false)) {
      const emit = typeof process !== 'undefined' && process.emitWarning // This will throw in Jest if `warning` is an Error instance due to
      // https://github.com/facebook/jest/issues/2549

      if (emit) emit(warning, type)
      else {
        // eslint-disable-next-line no-console
        console.warn(type ? `${type}: ${warning}` : warning)
      }
    }
  }

  function warnFileDeprecation(filename) {
    if (shouldWarn(true)) {
      const path = filename
        .replace(/.*yaml[/\\]/i, '')
        .replace(/\.js$/, '')
        .replace(/\\/g, '/')
      warn(
        `The endpoint 'yaml/${path}' will be removed in a future release.`,
        'DeprecationWarning',
      )
    }
  }

  const warned = {}

  function warnOptionDeprecation(name, alternative) {
    if (!warned[name] && shouldWarn(true)) {
      warned[name] = true
      let msg = `The option '${name}' will be removed in a future release`
      msg += alternative ? `, use '${alternative}' instead.` : '.'
      warn(msg, 'DeprecationWarning')
    }
  }

  warnings1000a372.binary = binary
  warnings1000a372.floatTime = floatTime
  warnings1000a372.intTime = intTime
  warnings1000a372.omap = omap
  warnings1000a372.pairs = pairs
  warnings1000a372.set = set
  warnings1000a372.timestamp = timestamp
  warnings1000a372.warn = warn
  warnings1000a372.warnFileDeprecation = warnFileDeprecation
  warnings1000a372.warnOptionDeprecation = warnOptionDeprecation

  var PlainValue$2 = PlainValueEc8e588e

  var resolveSeq$1 = resolveSeqD03cb037

  var warnings$1 = warnings1000a372

  function createMap(schema, obj, ctx) {
    const map = new resolveSeq$1.YAMLMap(schema)

    if (obj instanceof Map) {
      for (const [key, value] of obj)
        map.items.push(schema.createPair(key, value, ctx))
    } else if (obj && typeof obj === 'object') {
      for (const key of Object.keys(obj))
        map.items.push(schema.createPair(key, obj[key], ctx))
    }

    if (typeof schema.sortMapEntries === 'function') {
      map.items.sort(schema.sortMapEntries)
    }

    return map
  }

  const map = {
    createNode: createMap,
    default: true,
    nodeClass: resolveSeq$1.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve: resolveSeq$1.resolveMap,
  }

  function createSeq(schema, obj, ctx) {
    const seq = new resolveSeq$1.YAMLSeq(schema)

    if (obj && obj[Symbol.iterator]) {
      for (const it of obj) {
        const v = schema.createNode(it, ctx.wrapScalars, null, ctx)
        seq.items.push(v)
      }
    }

    return seq
  }

  const seq = {
    createNode: createSeq,
    default: true,
    nodeClass: resolveSeq$1.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve: resolveSeq$1.resolveSeq,
  }
  const string = {
    identify: (value) => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: resolveSeq$1.resolveString,

    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign(
        {
          actualString: true,
        },
        ctx,
      )
      return resolveSeq$1.stringifyString(item, ctx, onComment, onChompKeep)
    },

    options: resolveSeq$1.strOptions,
  }
  const failsafe = [map, seq, string]
  /* global BigInt */

  const intIdentify$2 = (value) =>
    typeof value === 'bigint' || Number.isInteger(value)

  const intResolve$1 = (src, part, radix) =>
    resolveSeq$1.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix)

  function intStringify$1(node, radix, prefix) {
    const { value } = node
    if (intIdentify$2(value) && value >= 0)
      return prefix + value.toString(radix)
    return resolveSeq$1.stringifyNumber(node)
  }

  const nullObj = {
    identify: (value) => value == null,
    createNode: (schema, value, ctx) =>
      ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => null,
    options: resolveSeq$1.nullOptions,
    stringify: () => resolveSeq$1.nullOptions.nullStr,
  }
  const boolObj = {
    identify: (value) => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => str[0] === 't' || str[0] === 'T',
    options: resolveSeq$1.boolOptions,
    stringify: ({ value }) =>
      value
        ? resolveSeq$1.boolOptions.trueStr
        : resolveSeq$1.boolOptions.falseStr,
  }
  const octObj = {
    identify: (value) => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o([0-7]+)$/,
    resolve: (str, oct) => intResolve$1(str, oct, 8),
    options: resolveSeq$1.intOptions,
    stringify: (node) => intStringify$1(node, 8, '0o'),
  }
  const intObj = {
    identify: intIdentify$2,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str) => intResolve$1(str, str, 10),
    options: resolveSeq$1.intOptions,
    stringify: resolveSeq$1.stringifyNumber,
  }
  const hexObj = {
    identify: (value) => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x([0-9a-fA-F]+)$/,
    resolve: (str, hex) => intResolve$1(str, hex, 16),
    options: resolveSeq$1.intOptions,
    stringify: (node) => intStringify$1(node, 16, '0x'),
  }
  const nanObj = {
    identify: (value) => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.inf|(\.nan))$/i,
    resolve: (str, nan) =>
      nan
        ? NaN
        : str[0] === '-'
        ? Number.NEGATIVE_INFINITY
        : Number.POSITIVE_INFINITY,
    stringify: resolveSeq$1.stringifyNumber,
  }
  const expObj = {
    identify: (value) => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify: ({ value }) => Number(value).toExponential(),
  }
  const floatObj = {
    identify: (value) => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,

    resolve(str, frac1, frac2) {
      const frac = frac1 || frac2
      const node = new resolveSeq$1.Scalar(parseFloat(str))
      if (frac && frac[frac.length - 1] === '0')
        node.minFractionDigits = frac.length
      return node
    },

    stringify: resolveSeq$1.stringifyNumber,
  }
  const core = failsafe.concat([
    nullObj,
    boolObj,
    octObj,
    intObj,
    hexObj,
    nanObj,
    expObj,
    floatObj,
  ])
  /* global BigInt */

  const intIdentify$1 = (value) =>
    typeof value === 'bigint' || Number.isInteger(value)

  const stringifyJSON = ({ value }) => JSON.stringify(value)

  const json = [
    map,
    seq,
    {
      identify: (value) => typeof value === 'string',
      default: true,
      tag: 'tag:yaml.org,2002:str',
      resolve: resolveSeq$1.resolveString,
      stringify: stringifyJSON,
    },
    {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) =>
        ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
      default: true,
      tag: 'tag:yaml.org,2002:null',
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON,
    },
    {
      identify: (value) => typeof value === 'boolean',
      default: true,
      tag: 'tag:yaml.org,2002:bool',
      test: /^true|false$/,
      resolve: (str) => str === 'true',
      stringify: stringifyJSON,
    },
    {
      identify: intIdentify$1,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str) =>
        resolveSeq$1.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) =>
        intIdentify$1(value) ? value.toString() : JSON.stringify(value),
    },
    {
      identify: (value) => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON,
    },
  ]

  json.scalarFallback = (str) => {
    throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`)
  }
  /* global BigInt */

  const boolStringify = ({ value }) =>
    value ? resolveSeq$1.boolOptions.trueStr : resolveSeq$1.boolOptions.falseStr

  const intIdentify = (value) =>
    typeof value === 'bigint' || Number.isInteger(value)

  function intResolve(sign, src, radix) {
    let str = src.replace(/_/g, '')

    if (resolveSeq$1.intOptions.asBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`
          break

        case 8:
          str = `0o${str}`
          break

        case 16:
          str = `0x${str}`
          break
      }

      const n = BigInt(str)
      return sign === '-' ? BigInt(-1) * n : n
    }

    const n = parseInt(str, radix)
    return sign === '-' ? -1 * n : n
  }

  function intStringify(node, radix, prefix) {
    const { value } = node

    if (intIdentify(value)) {
      const str = value.toString(radix)
      return value < 0 ? '-' + prefix + str.substr(1) : prefix + str
    }

    return resolveSeq$1.stringifyNumber(node)
  }

  const yaml11 = failsafe.concat(
    [
      {
        identify: (value) => value == null,
        createNode: (schema, value, ctx) =>
          ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: () => null,
        options: resolveSeq$1.nullOptions,
        stringify: () => resolveSeq$1.nullOptions.nullStr,
      },
      {
        identify: (value) => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: () => true,
        options: resolveSeq$1.boolOptions,
        stringify: boolStringify,
      },
      {
        identify: (value) => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
        resolve: () => false,
        options: resolveSeq$1.boolOptions,
        stringify: boolStringify,
      },
      {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'BIN',
        test: /^([-+]?)0b([0-1_]+)$/,
        resolve: (str, sign, bin) => intResolve(sign, bin, 2),
        stringify: (node) => intStringify(node, 2, '0b'),
      },
      {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'OCT',
        test: /^([-+]?)0([0-7_]+)$/,
        resolve: (str, sign, oct) => intResolve(sign, oct, 8),
        stringify: (node) => intStringify(node, 8, '0'),
      },
      {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^([-+]?)([0-9][0-9_]*)$/,
        resolve: (str, sign, abs) => intResolve(sign, abs, 10),
        stringify: resolveSeq$1.stringifyNumber,
      },
      {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'HEX',
        test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
        resolve: (str, sign, hex) => intResolve(sign, hex, 16),
        stringify: (node) => intStringify(node, 16, '0x'),
      },
      {
        identify: (value) => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^(?:[-+]?\.inf|(\.nan))$/i,
        resolve: (str, nan) =>
          nan
            ? NaN
            : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
        stringify: resolveSeq$1.stringifyNumber,
      },
      {
        identify: (value) => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        format: 'EXP',
        test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: (str) => parseFloat(str.replace(/_/g, '')),
        stringify: ({ value }) => Number(value).toExponential(),
      },
      {
        identify: (value) => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,

        resolve(str, frac) {
          const node = new resolveSeq$1.Scalar(
            parseFloat(str.replace(/_/g, '')),
          )

          if (frac) {
            const f = frac.replace(/_/g, '')
            if (f[f.length - 1] === '0') node.minFractionDigits = f.length
          }

          return node
        },

        stringify: resolveSeq$1.stringifyNumber,
      },
    ],
    warnings$1.binary,
    warnings$1.omap,
    warnings$1.pairs,
    warnings$1.set,
    warnings$1.intTime,
    warnings$1.floatTime,
    warnings$1.timestamp,
  )
  const schemas = {
    core,
    failsafe,
    json,
    yaml11,
  }
  const tags = {
    binary: warnings$1.binary,
    bool: boolObj,
    float: floatObj,
    floatExp: expObj,
    floatNaN: nanObj,
    floatTime: warnings$1.floatTime,
    int: intObj,
    intHex: hexObj,
    intOct: octObj,
    intTime: warnings$1.intTime,
    map,
    null: nullObj,
    omap: warnings$1.omap,
    pairs: warnings$1.pairs,
    seq,
    set: warnings$1.set,
    timestamp: warnings$1.timestamp,
  }

  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName)
      const tagObj = match.find((t) => !t.format) || match[0]
      if (!tagObj) throw new Error(`Tag ${tagName} not found`)
      return tagObj
    } // TODO: deprecate/remove class check

    return tags.find(
      (t) =>
        ((t.identify && t.identify(value)) ||
          (t.class && value instanceof t.class)) &&
        !t.format,
    )
  }

  function createNode$1(value, tagName, ctx) {
    if (value instanceof resolveSeq$1.Node) return value
    const { defaultPrefix, onTagObj, prevObjects, schema, wrapScalars } = ctx
    if (tagName && tagName.startsWith('!!'))
      tagName = defaultPrefix + tagName.slice(2)
    let tagObj = findTagObject(value, tagName, schema.tags)

    if (!tagObj) {
      if (typeof value.toJSON === 'function') value = value.toJSON()
      if (!value || typeof value !== 'object')
        return wrapScalars ? new resolveSeq$1.Scalar(value) : value
      tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map
    }

    if (onTagObj) {
      onTagObj(tagObj)
      delete ctx.onTagObj
    } // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `obj` wrapper allows for circular references to resolve.

    const obj = {
      value: undefined,
      node: undefined,
    }

    if (value && typeof value === 'object' && prevObjects) {
      const prev = prevObjects.get(value)

      if (prev) {
        const alias = new resolveSeq$1.Alias(prev) // leaves source dirty; must be cleaned by caller

        ctx.aliasNodes.push(alias) // defined along with prevObjects

        return alias
      }

      obj.value = value
      prevObjects.set(value, obj)
    }

    obj.node = tagObj.createNode
      ? tagObj.createNode(ctx.schema, value, ctx)
      : wrapScalars
      ? new resolveSeq$1.Scalar(value)
      : value
    if (tagName && obj.node instanceof resolveSeq$1.Node) obj.node.tag = tagName
    return obj.node
  }

  function getSchemaTags(schemas, knownTags, customTags, schemaId) {
    let tags = schemas[schemaId.replace(/\W/g, '')] // 'yaml-1.1' -> 'yaml11'

    if (!tags) {
      const keys = Object.keys(schemas)
        .map((key) => JSON.stringify(key))
        .join(', ')
      throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`)
    }

    if (Array.isArray(customTags)) {
      for (const tag of customTags) tags = tags.concat(tag)
    } else if (typeof customTags === 'function') {
      tags = customTags(tags.slice())
    }

    for (let i = 0; i < tags.length; ++i) {
      const tag = tags[i]

      if (typeof tag === 'string') {
        const tagObj = knownTags[tag]

        if (!tagObj) {
          const keys = Object.keys(knownTags)
            .map((key) => JSON.stringify(key))
            .join(', ')
          throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`)
        }

        tags[i] = tagObj
      }
    }

    return tags
  }

  const sortMapEntriesByKey = (a, b) =>
    a.key < b.key ? -1 : a.key > b.key ? 1 : 0

  class Schema$2 {
    // TODO: remove in v2
    // TODO: remove in v2
    constructor({
      customTags,
      merge,
      schema,
      sortMapEntries,
      tags: deprecatedCustomTags,
    }) {
      this.merge = !!merge
      this.name = schema
      this.sortMapEntries =
        sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null
      if (!customTags && deprecatedCustomTags)
        warnings$1.warnOptionDeprecation('tags', 'customTags')
      this.tags = getSchemaTags(
        schemas,
        tags,
        customTags || deprecatedCustomTags,
        schema,
      )
    }

    createNode(value, wrapScalars, tagName, ctx) {
      const baseCtx = {
        defaultPrefix: Schema$2.defaultPrefix,
        schema: this,
        wrapScalars,
      }
      const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx
      return createNode$1(value, tagName, createCtx)
    }

    createPair(key, value, ctx) {
      if (!ctx)
        ctx = {
          wrapScalars: true,
        }
      const k = this.createNode(key, ctx.wrapScalars, null, ctx)
      const v = this.createNode(value, ctx.wrapScalars, null, ctx)
      return new resolveSeq$1.Pair(k, v)
    }
  }

  PlainValue$2._defineProperty(
    Schema$2,
    'defaultPrefix',
    PlainValue$2.defaultTagPrefix,
  )

  PlainValue$2._defineProperty(
    Schema$2,
    'defaultTags',
    PlainValue$2.defaultTags,
  )

  Schema88e323a7.Schema = Schema$2

  var PlainValue$1 = PlainValueEc8e588e

  var resolveSeq = resolveSeqD03cb037

  var Schema$1 = Schema88e323a7

  const defaultOptions = {
    anchorPrefix: 'a',
    customTags: null,
    indent: 2,
    indentSeq: true,
    keepCstNodes: false,
    keepNodeTypes: true,
    keepBlobsInJSON: true,
    mapAsMap: false,
    maxAliasCount: 100,
    prettyErrors: false,
    // TODO Set true in v2
    simpleKeys: false,
    version: '1.2',
  }
  const scalarOptions = {
    get binary() {
      return resolveSeq.binaryOptions
    },

    set binary(opt) {
      Object.assign(resolveSeq.binaryOptions, opt)
    },

    get bool() {
      return resolveSeq.boolOptions
    },

    set bool(opt) {
      Object.assign(resolveSeq.boolOptions, opt)
    },

    get int() {
      return resolveSeq.intOptions
    },

    set int(opt) {
      Object.assign(resolveSeq.intOptions, opt)
    },

    get null() {
      return resolveSeq.nullOptions
    },

    set null(opt) {
      Object.assign(resolveSeq.nullOptions, opt)
    },

    get str() {
      return resolveSeq.strOptions
    },

    set str(opt) {
      Object.assign(resolveSeq.strOptions, opt)
    },
  }
  const documentOptions = {
    '1.0': {
      schema: 'yaml-1.1',
      merge: true,
      tagPrefixes: [
        {
          handle: '!',
          prefix: PlainValue$1.defaultTagPrefix,
        },
        {
          handle: '!!',
          prefix: 'tag:private.yaml.org,2002:',
        },
      ],
    },
    1.1: {
      schema: 'yaml-1.1',
      merge: true,
      tagPrefixes: [
        {
          handle: '!',
          prefix: '!',
        },
        {
          handle: '!!',
          prefix: PlainValue$1.defaultTagPrefix,
        },
      ],
    },
    1.2: {
      schema: 'core',
      merge: false,
      tagPrefixes: [
        {
          handle: '!',
          prefix: '!',
        },
        {
          handle: '!!',
          prefix: PlainValue$1.defaultTagPrefix,
        },
      ],
    },
  }

  function stringifyTag(doc, tag) {
    if ((doc.version || doc.options.version) === '1.0') {
      const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/)
      if (priv) return '!' + priv[1]
      const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/)
      return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`
    }

    let p = doc.tagPrefixes.find((p) => tag.indexOf(p.prefix) === 0)

    if (!p) {
      const dtp = doc.getDefaults().tagPrefixes
      p = dtp && dtp.find((p) => tag.indexOf(p.prefix) === 0)
    }

    if (!p) return tag[0] === '!' ? tag : `!<${tag}>`
    const suffix = tag.substr(p.prefix.length).replace(
      /[!,[\]{}]/g,
      (ch) =>
        ({
          '!': '%21',
          ',': '%2C',
          '[': '%5B',
          ']': '%5D',
          '{': '%7B',
          '}': '%7D',
        }[ch]),
    )
    return p.handle + suffix
  }

  function getTagObject(tags, item) {
    if (item instanceof resolveSeq.Alias) return resolveSeq.Alias

    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag)
      if (match.length > 0)
        return match.find((t) => t.format === item.format) || match[0]
    }

    let tagObj, obj

    if (item instanceof resolveSeq.Scalar) {
      obj = item.value // TODO: deprecate/remove class check

      const match = tags.filter(
        (t) =>
          (t.identify && t.identify(obj)) ||
          (t.class && obj instanceof t.class),
      )
      tagObj =
        match.find((t) => t.format === item.format) ||
        match.find((t) => !t.format)
    } else {
      obj = item
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass)
    }

    if (!tagObj) {
      const name = obj && obj.constructor ? obj.constructor.name : typeof obj
      throw new Error(`Tag not resolved for ${name} value`)
    }

    return tagObj
  } // needs to be called before value stringifier to allow for circular anchor refs

  function stringifyProps(node, tagObj, { anchors, doc }) {
    const props = []
    const anchor = doc.anchors.getName(node)

    if (anchor) {
      anchors[anchor] = node
      props.push(`&${anchor}`)
    }

    if (node.tag) {
      props.push(stringifyTag(doc, node.tag))
    } else if (!tagObj.default) {
      props.push(stringifyTag(doc, tagObj.tag))
    }

    return props.join(' ')
  }

  function stringify$1(item, ctx, onComment, onChompKeep) {
    const { anchors, schema } = ctx.doc
    let tagObj

    if (!(item instanceof resolveSeq.Node)) {
      const createCtx = {
        aliasNodes: [],
        onTagObj: (o) => (tagObj = o),
        prevObjects: new Map(),
      }
      item = schema.createNode(item, true, null, createCtx)

      for (const alias of createCtx.aliasNodes) {
        alias.source = alias.source.node
        let name = anchors.getName(alias.source)

        if (!name) {
          name = anchors.newName()
          anchors.map[name] = alias.source
        }
      }
    }

    if (item instanceof resolveSeq.Pair)
      return item.toString(ctx, onComment, onChompKeep)
    if (!tagObj) tagObj = getTagObject(schema.tags, item)
    const props = stringifyProps(item, tagObj, ctx)
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1
    const str =
      typeof tagObj.stringify === 'function'
        ? tagObj.stringify(item, ctx, onComment, onChompKeep)
        : item instanceof resolveSeq.Scalar
        ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep)
        : item.toString(ctx, onComment, onChompKeep)
    if (!props) return str
    return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '['
      ? `${props} ${str}`
      : `${props}\n${ctx.indent}${str}`
  }

  class Anchors {
    static validAnchorNode(node) {
      return (
        node instanceof resolveSeq.Scalar ||
        node instanceof resolveSeq.YAMLSeq ||
        node instanceof resolveSeq.YAMLMap
      )
    }

    constructor(prefix) {
      PlainValue$1._defineProperty(this, 'map', Object.create(null))

      this.prefix = prefix
    }

    createAlias(node, name) {
      this.setAnchor(node, name)
      return new resolveSeq.Alias(node)
    }

    createMergePair(...sources) {
      const merge = new resolveSeq.Merge()
      merge.value.items = sources.map((s) => {
        if (s instanceof resolveSeq.Alias) {
          if (s.source instanceof resolveSeq.YAMLMap) return s
        } else if (s instanceof resolveSeq.YAMLMap) {
          return this.createAlias(s)
        }

        throw new Error('Merge sources must be Map nodes or their Aliases')
      })
      return merge
    }

    getName(node) {
      const { map } = this
      return Object.keys(map).find((a) => map[a] === node)
    }

    getNames() {
      return Object.keys(this.map)
    }

    getNode(name) {
      return this.map[name]
    }

    newName(prefix) {
      if (!prefix) prefix = this.prefix
      const names = Object.keys(this.map)

      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`
        if (!names.includes(name)) return name
      }
    } // During parsing, map & aliases contain CST nodes

    resolveNodes() {
      const { map, _cstAliases } = this
      Object.keys(map).forEach((a) => {
        map[a] = map[a].resolved
      })

      _cstAliases.forEach((a) => {
        a.source = a.source.resolved
      })

      delete this._cstAliases
    }

    setAnchor(node, name) {
      if (node != null && !Anchors.validAnchorNode(node)) {
        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes')
      }

      if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
        throw new Error(
          'Anchor names must not contain whitespace or control characters',
        )
      }

      const { map } = this
      const prev = node && Object.keys(map).find((a) => map[a] === node)

      if (prev) {
        if (!name) {
          return prev
        } else if (prev !== name) {
          delete map[prev]
          map[name] = node
        }
      } else {
        if (!name) {
          if (!node) return null
          name = this.newName()
        }

        map[name] = node
      }

      return name
    }
  }

  const visit = (node, tags) => {
    if (node && typeof node === 'object') {
      const { tag } = node

      if (node instanceof resolveSeq.Collection) {
        if (tag) tags[tag] = true
        node.items.forEach((n) => visit(n, tags))
      } else if (node instanceof resolveSeq.Pair) {
        visit(node.key, tags)
        visit(node.value, tags)
      } else if (node instanceof resolveSeq.Scalar) {
        if (tag) tags[tag] = true
      }
    }

    return tags
  }

  const listTagNames = (node) => Object.keys(visit(node, {}))

  function parseContents(doc, contents) {
    const comments = {
      before: [],
      after: [],
    }
    let body = undefined
    let spaceBefore = false

    for (const node of contents) {
      if (node.valueRange) {
        if (body !== undefined) {
          const msg =
            'Document contains trailing content not separated by a ... or --- line'
          doc.errors.push(new PlainValue$1.YAMLSyntaxError(node, msg))
          break
        }

        const res = resolveSeq.resolveNode(doc, node)

        if (spaceBefore) {
          res.spaceBefore = true
          spaceBefore = false
        }

        body = res
      } else if (node.comment !== null) {
        const cc = body === undefined ? comments.before : comments.after
        cc.push(node.comment)
      } else if (node.type === PlainValue$1.Type.BLANK_LINE) {
        spaceBefore = true

        if (
          body === undefined &&
          comments.before.length > 0 &&
          !doc.commentBefore
        ) {
          // space-separated comments at start are parsed as document comments
          doc.commentBefore = comments.before.join('\n')
          comments.before = []
        }
      }
    }

    doc.contents = body || null

    if (!body) {
      doc.comment = comments.before.concat(comments.after).join('\n') || null
    } else {
      const cb = comments.before.join('\n')

      if (cb) {
        const cbNode =
          body instanceof resolveSeq.Collection && body.items[0]
            ? body.items[0]
            : body
        cbNode.commentBefore = cbNode.commentBefore
          ? `${cb}\n${cbNode.commentBefore}`
          : cb
      }

      doc.comment = comments.after.join('\n') || null
    }
  }

  function resolveTagDirective({ tagPrefixes }, directive) {
    const [handle, prefix] = directive.parameters

    if (!handle || !prefix) {
      const msg = 'Insufficient parameters given for %TAG directive'
      throw new PlainValue$1.YAMLSemanticError(directive, msg)
    }

    if (tagPrefixes.some((p) => p.handle === handle)) {
      const msg =
        'The %TAG directive must only be given at most once per handle in the same document.'
      throw new PlainValue$1.YAMLSemanticError(directive, msg)
    }

    return {
      handle,
      prefix,
    }
  }

  function resolveYamlDirective(doc, directive) {
    let [version] = directive.parameters
    if (directive.name === 'YAML:1.0') version = '1.0'

    if (!version) {
      const msg = 'Insufficient parameters given for %YAML directive'
      throw new PlainValue$1.YAMLSemanticError(directive, msg)
    }

    if (!documentOptions[version]) {
      const v0 = doc.version || doc.options.version
      const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`
      doc.warnings.push(new PlainValue$1.YAMLWarning(directive, msg))
    }

    return version
  }

  function parseDirectives(doc, directives, prevDoc) {
    const directiveComments = []
    let hasDirectives = false

    for (const directive of directives) {
      const { comment, name } = directive

      switch (name) {
        case 'TAG':
          try {
            doc.tagPrefixes.push(resolveTagDirective(doc, directive))
          } catch (error) {
            doc.errors.push(error)
          }

          hasDirectives = true
          break

        case 'YAML':
        case 'YAML:1.0':
          if (doc.version) {
            const msg =
              'The %YAML directive must only be given at most once per document.'
            doc.errors.push(new PlainValue$1.YAMLSemanticError(directive, msg))
          }

          try {
            doc.version = resolveYamlDirective(doc, directive)
          } catch (error) {
            doc.errors.push(error)
          }

          hasDirectives = true
          break

        default:
          if (name) {
            const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`
            doc.warnings.push(new PlainValue$1.YAMLWarning(directive, msg))
          }
      }

      if (comment) directiveComments.push(comment)
    }

    if (
      prevDoc &&
      !hasDirectives &&
      '1.1' === (doc.version || prevDoc.version || doc.options.version)
    ) {
      const copyTagPrefix = ({ handle, prefix }) => ({
        handle,
        prefix,
      })

      doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix)
      doc.version = prevDoc.version
    }

    doc.commentBefore = directiveComments.join('\n') || null
  }

  function assertCollection(contents) {
    if (contents instanceof resolveSeq.Collection) return true
    throw new Error('Expected a YAML collection as document contents')
  }

  class Document$2 {
    constructor(options) {
      this.anchors = new Anchors(options.anchorPrefix)
      this.commentBefore = null
      this.comment = null
      this.contents = null
      this.directivesEndMarker = null
      this.errors = []
      this.options = options
      this.schema = null
      this.tagPrefixes = []
      this.version = null
      this.warnings = []
    }

    add(value) {
      assertCollection(this.contents)
      return this.contents.add(value)
    }

    addIn(path, value) {
      assertCollection(this.contents)
      this.contents.addIn(path, value)
    }

    delete(key) {
      assertCollection(this.contents)
      return this.contents.delete(key)
    }

    deleteIn(path) {
      if (resolveSeq.isEmptyPath(path)) {
        if (this.contents == null) return false
        this.contents = null
        return true
      }

      assertCollection(this.contents)
      return this.contents.deleteIn(path)
    }

    getDefaults() {
      return (
        Document$2.defaults[this.version] ||
        Document$2.defaults[this.options.version] ||
        {}
      )
    }

    get(key, keepScalar) {
      return this.contents instanceof resolveSeq.Collection
        ? this.contents.get(key, keepScalar)
        : undefined
    }

    getIn(path, keepScalar) {
      if (resolveSeq.isEmptyPath(path))
        return !keepScalar && this.contents instanceof resolveSeq.Scalar
          ? this.contents.value
          : this.contents
      return this.contents instanceof resolveSeq.Collection
        ? this.contents.getIn(path, keepScalar)
        : undefined
    }

    has(key) {
      return this.contents instanceof resolveSeq.Collection
        ? this.contents.has(key)
        : false
    }

    hasIn(path) {
      if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined
      return this.contents instanceof resolveSeq.Collection
        ? this.contents.hasIn(path)
        : false
    }

    set(key, value) {
      assertCollection(this.contents)
      this.contents.set(key, value)
    }

    setIn(path, value) {
      if (resolveSeq.isEmptyPath(path)) this.contents = value
      else {
        assertCollection(this.contents)
        this.contents.setIn(path, value)
      }
    }

    setSchema(id, customTags) {
      if (!id && !customTags && this.schema) return
      if (typeof id === 'number') id = id.toFixed(1)

      if (id === '1.0' || id === '1.1' || id === '1.2') {
        if (this.version) this.version = id
        else this.options.version = id
        delete this.options.schema
      } else if (id && typeof id === 'string') {
        this.options.schema = id
      }

      if (Array.isArray(customTags)) this.options.customTags = customTags
      const opt = Object.assign({}, this.getDefaults(), this.options)
      this.schema = new Schema$1.Schema(opt)
    }

    parse(node, prevDoc) {
      if (this.options.keepCstNodes) this.cstNode = node
      if (this.options.keepNodeTypes) this.type = 'DOCUMENT'
      const {
        directives = [],
        contents = [],
        directivesEndMarker,
        error,
        valueRange,
      } = node

      if (error) {
        if (!error.source) error.source = this
        this.errors.push(error)
      }

      parseDirectives(this, directives, prevDoc)
      if (directivesEndMarker) this.directivesEndMarker = true
      this.range = valueRange ? [valueRange.start, valueRange.end] : null
      this.setSchema()
      this.anchors._cstAliases = []
      parseContents(this, contents)
      this.anchors.resolveNodes()

      if (this.options.prettyErrors) {
        for (const error of this.errors)
          if (error instanceof PlainValue$1.YAMLError) error.makePretty()

        for (const warn of this.warnings)
          if (warn instanceof PlainValue$1.YAMLError) warn.makePretty()
      }

      return this
    }

    listNonDefaultTags() {
      return listTagNames(this.contents).filter(
        (t) => t.indexOf(Schema$1.Schema.defaultPrefix) !== 0,
      )
    }

    setTagPrefix(handle, prefix) {
      if (handle[0] !== '!' || handle[handle.length - 1] !== '!')
        throw new Error('Handle must start and end with !')

      if (prefix) {
        const prev = this.tagPrefixes.find((p) => p.handle === handle)
        if (prev) prev.prefix = prefix
        else
          this.tagPrefixes.push({
            handle,
            prefix,
          })
      } else {
        this.tagPrefixes = this.tagPrefixes.filter((p) => p.handle !== handle)
      }
    }

    toJSON(arg, onAnchor) {
      const { keepBlobsInJSON, mapAsMap, maxAliasCount } = this.options
      const keep =
        keepBlobsInJSON &&
        (typeof arg !== 'string' ||
          !(this.contents instanceof resolveSeq.Scalar))
      const ctx = {
        doc: this,
        indentStep: '  ',
        keep,
        mapAsMap: keep && !!mapAsMap,
        maxAliasCount,
        stringify: stringify$1, // Requiring directly in Pair would create circular dependencies
      }
      const anchorNames = Object.keys(this.anchors.map)
      if (anchorNames.length > 0)
        ctx.anchors = new Map(
          anchorNames.map((name) => [
            this.anchors.map[name],
            {
              alias: [],
              aliasCount: 0,
              count: 1,
            },
          ]),
        )
      const res = resolveSeq.toJSON(this.contents, arg, ctx)
      if (typeof onAnchor === 'function' && ctx.anchors)
        for (const { count, res } of ctx.anchors.values()) onAnchor(res, count)
      return res
    }

    toString() {
      if (this.errors.length > 0)
        throw new Error('Document with errors cannot be stringified')
      const indentSize = this.options.indent

      if (!Number.isInteger(indentSize) || indentSize <= 0) {
        const s = JSON.stringify(indentSize)
        throw new Error(`"indent" option must be a positive integer, not ${s}`)
      }

      this.setSchema()
      const lines = []
      let hasDirectives = false

      if (this.version) {
        let vd = '%YAML 1.2'

        if (this.schema.name === 'yaml-1.1') {
          if (this.version === '1.0') vd = '%YAML:1.0'
          else if (this.version === '1.1') vd = '%YAML 1.1'
        }

        lines.push(vd)
        hasDirectives = true
      }

      const tagNames = this.listNonDefaultTags()
      this.tagPrefixes.forEach(({ handle, prefix }) => {
        if (tagNames.some((t) => t.indexOf(prefix) === 0)) {
          lines.push(`%TAG ${handle} ${prefix}`)
          hasDirectives = true
        }
      })
      if (hasDirectives || this.directivesEndMarker) lines.push('---')

      if (this.commentBefore) {
        if (hasDirectives || !this.directivesEndMarker) lines.unshift('')
        lines.unshift(this.commentBefore.replace(/^/gm, '#'))
      }

      const ctx = {
        anchors: Object.create(null),
        doc: this,
        indent: '',
        indentStep: ' '.repeat(indentSize),
        stringify: stringify$1, // Requiring directly in nodes would create circular dependencies
      }
      let chompKeep = false
      let contentComment = null

      if (this.contents) {
        if (this.contents instanceof resolveSeq.Node) {
          if (
            this.contents.spaceBefore &&
            (hasDirectives || this.directivesEndMarker)
          )
            lines.push('')
          if (this.contents.commentBefore)
            lines.push(this.contents.commentBefore.replace(/^/gm, '#')) // top-level block scalars need to be indented if followed by a comment

          ctx.forceBlockIndent = !!this.comment
          contentComment = this.contents.comment
        }

        const onChompKeep = contentComment ? null : () => (chompKeep = true)
        const body = stringify$1(
          this.contents,
          ctx,
          () => (contentComment = null),
          onChompKeep,
        )
        lines.push(resolveSeq.addComment(body, '', contentComment))
      } else if (this.contents !== undefined) {
        lines.push(stringify$1(this.contents, ctx))
      }

      if (this.comment) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
          lines.push('')
        lines.push(this.comment.replace(/^/gm, '#'))
      }

      return lines.join('\n') + '\n'
    }
  }

  PlainValue$1._defineProperty(Document$2, 'defaults', documentOptions)

  Document9b4560a1.Document = Document$2
  Document9b4560a1.defaultOptions = defaultOptions
  Document9b4560a1.scalarOptions = scalarOptions

  var parseCst = parseCst$1

  var Document$1 = Document9b4560a1

  var Schema = Schema88e323a7

  var PlainValue = PlainValueEc8e588e

  var warnings = warnings1000a372

  function createNode(value, wrapScalars = true, tag) {
    if (tag === undefined && typeof wrapScalars === 'string') {
      tag = wrapScalars
      wrapScalars = true
    }

    const options = Object.assign(
      {},
      Document$1.Document.defaults[Document$1.defaultOptions.version],
      Document$1.defaultOptions,
    )
    const schema = new Schema.Schema(options)
    return schema.createNode(value, wrapScalars, tag)
  }

  class Document extends Document$1.Document {
    constructor(options) {
      super(Object.assign({}, Document$1.defaultOptions, options))
    }
  }

  function parseAllDocuments(src, options) {
    const stream = []
    let prev

    for (const cstDoc of parseCst.parse(src)) {
      const doc = new Document(options)
      doc.parse(cstDoc, prev)
      stream.push(doc)
      prev = doc
    }

    return stream
  }

  function parseDocument(src, options) {
    const cst = parseCst.parse(src)
    const doc = new Document(options).parse(cst[0])

    if (cst.length > 1) {
      const errMsg =
        'Source contains multiple documents; please use YAML.parseAllDocuments()'
      doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg))
    }

    return doc
  }

  function parse(src, options) {
    const doc = parseDocument(src, options)
    doc.warnings.forEach((warning) => warnings.warn(warning))
    if (doc.errors.length > 0) throw doc.errors[0]
    return doc.toJSON()
  }

  function stringify(value, options) {
    const doc = new Document(options)
    doc.contents = value
    return String(doc)
  }

  const YAML = {
    createNode,
    defaultOptions: Document$1.defaultOptions,
    Document,
    parse,
    parseAllDocuments,
    parseCST: parseCst.parse,
    parseDocument,
    scalarOptions: Document$1.scalarOptions,
    stringify,
  }
  dist.YAML = YAML

  var yaml = dist.YAML

  const staticTemplateFolder = ' Templates'
  function getTemplateFolder() {
    return DataStore.folders.find((f) => f.includes(staticTemplateFolder))
  }
  async function makeTemplateFolder() {
    let folder = getTemplateFolder()

    if (folder == null) {
      const shouldCreateFolder = await chooseOption(
        'No templates folder found.',
        [
          {
            label: ` Create ${staticTemplateFolder} with samples`,
            value: true,
          },
          {
            label: ' Cancel',
            value: false,
          },
        ],
        false,
      )

      if (!shouldCreateFolder) {
        return
      }

      const subfolder = await chooseOption(
        'Select a location for the templates folder.',
        DataStore.folders.map((folder) => ({
          label: folder,
          value: folder + (folder.endsWith('/') ? '' : '/'),
        })),
        '',
      )
      folder = subfolder + staticTemplateFolder // Now create a sample note in that folder, then we got the folder also created

      DataStore.newNote(DAILY_NOTE_TEMPLATE, folder)
      DataStore.newNote(MEETING_NOTE_TEMPLATE, folder)
      DataStore.newNote(TAGS_TEMPLATE, folder)
      DataStore.newNote(CONFIG, folder)
      await showMessage(
        `"${staticTemplateFolder}" folder created with samples `,
      )
    }
  }
  /*

  DEFAULT TEMPLATE NOTES FOLLOW

  */

  const DAILY_NOTE_TEMPLATE = `Daily Note Template
---
## Tasks

## Media

## Journal
`
  const MEETING_NOTE_TEMPLATE = `Meeting Note Template
---
## Project X Meeting on [[date]] with @Y and @Z

## Notes

## Actions
`
  const TAGS_TEMPLATE = `Tags Template
---
# {{title}}

Created on {{date({locale: 'en-US', dateStyle: 'short'})}}
`
  const CONFIG = ` _configuration
---
# Template Tag Configuration

This file is used to configure how templates work. \
Use the code fence below to set global values for template tags.

You can one of the following languages for your configuration:

**javascript**: Actually, *[JSON5](https://json5.org)*. If you write a codeblock tagged as javascript, \
make sure you write valid JSON5. Anything else will cause an error.
**json**: If you don't mind losing the ability to write comments etc, you can use regular JSON as well.
**yaml**: If you prefer the syntax of YAML, that is supported too.
**ini**: If you would like to use the TOML format, mark your codeblock with \`ini\` and it will \
be treated as TOML.

The first code-block within the note will always be used. So edit the default configuration below:

\`\`\`javascript
{
  // Even though it says, "javacsript" above, this actually just JSON5.

  // configuration for weather data
  weather: {
    // API key for https://openweathermap.org/
    // !!REQUIRED!!
    apiKey: '... put your API key here ...',
    // Default location for weather forcast
    lattitude: 0,
    longitude: 0,
    // Default temperature unit. Can be "C" (Celcius), "K" (Kelvin) or "F" (Fahrenheit)
    unit: 'C',
    // When using a weather tag, you can customize these options.
  },

  // configuration for dates, heavily based on javascript's Intl module
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat
  date: {
    // Default timezone for date and time.
    timezone: 'automatic',
    // Default locale to format date and time.
    // e.g. en-US will result in mm/dd/yyyy, while en_GB will be dd/mm/yyyy
    locale: 'en-US',
    // can be "short", "medium", "long" or "full"
    dateStyle: 'short',
    // can be null (to skip time), "short", "medium", "long" or "full"
    timeStyle: null,
  },

  // default values for custom tags.
  // These tags cannot be functions, but you may choose to have nested objects.
  // feel free to edit this value however you see fit.
  tagValue: {
    me: {
      // Can be used as {{me.firstName}}
      firstName: 'John',
      // Can be used as {{me.lastName}}
      lastName: 'Doe',
    }
    // ...
  },
}
\`\`\`

If you prefer YAML format, delete the code-block above and edit this one instead:

\`\`\`yaml
---
# configuration for weather data
weather:
  # API key for https://openweathermap.org/
  # !!REQUIRED!!
  apiKey: "... put your API key here ..."
  # Default location for weather forcast
  lattitude: 0
  longitude: 0
  # Default temperature unit. Can be "C" (Celcius), "K" (Kelvin) or "F" (Fahrenheit)
  unit: C

# configuration for dates, heavily based on javascript's Intl module
# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat
date:
  # Default timezone for date and time.
  timezone: automatic
  # Default locale to format date and time.
  # e.g. en-US will result in mm/dd/yyyy, while en_GB will be dd/mm/yyyy
  locale: en-US
  # can be "short", "medium", "long" or "full"
  dateStyle: short
  # can be null (to skip time), "short", "medium", "long" or "full"
  timeStyle: short

# default values for custom tags.
# These tags cannot be functions, but you may choose to have nested objects.
# feel free to edit this value however you see fit.
tagValue:
  me:
    # Can be used as {{me.firstName}}
    firstName: John
    # Can be used as {{me.lastName}}
    lastName: Doe
  # ... add any of your own keys here
\`\`\`

If you prefer TOML instead of JSON5 or YAML, delete the two code blocks above and use this one instead:

\`\`\`ini
# configuration for weather data
[weather]
# API key for https://openweathermap.org/
# !!REQUIRED!!
apiKey = "... put your API key here ..."
# Default location for weather forcast
lattitude = 0
longitude = 0
# Default temperature unit. Can be "C" (Celcius), "K" (Kelvin) or "F" (Fahrenheit)
unit = "C"
# When using a weather tag, you can customize these options.

# configuration for dates, heavily based on javascript's Intl module
# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat
[date]
# Default timezone for date and time.
timezone = "automatic"
# Default locale to format date and time.
# e.g. en-US will result in mm/dd/yyyy, while en_GB will be dd/mm/yyyy
locale = "en-US"
# can be "short", "medium", "long" or "full"
dateStyle = "short"
# can be null (to skip time), "short", "medium", "long" or "full"
timeStyle = "short"

# default values for custom tags.
[tagValue]
# These tags cannot be functions, but you may choose to have nested objects.
# feel free to edit this value however you see fit.

[tagValue.me]
# Can be used as {{me.firstName}}
firstName = "John"
# Can be used as {{me.lastName}}
lastName = "Doe"
\`\`\`
`

  const ALLOWED_FORMATS = ['javascript', 'json', 'json5', 'yaml', 'toml', 'ini']
  const FORMAT_MAP = {
    javascript: 'json5',
    ini: 'toml',
  }
  async function getDefaultConfiguration() {
    const templateFolder = await getTemplateFolder()

    if (templateFolder == null) {
      return {}
    }

    const configFile = DataStore.projectNotes
      .filter((n) => n.filename?.startsWith(templateFolder))
      .find((n) => !!n.title?.startsWith('_configuration'))
    const content = configFile?.content

    if (content == null) {
      return {}
    }

    const firstCodeblock = content.split('\n```')[1]

    if (firstCodeblock == null) {
      await showMessage('No configuration found in configuration file.')
      return {}
    }

    let [format, ...contents] = firstCodeblock.split('\n')
    contents = contents.join('\n')
    format = format.trim()

    if (!ALLOWED_FORMATS.includes(format)) {
      await showMessage('Invalid configuration format in the config file.')
      return {}
    }

    format = FORMAT_MAP[format] ?? format

    switch (format) {
      case 'json':
        return parseJSON(contents)

      case 'json5':
        return parseJSON5(contents)

      case 'yaml':
        return parseYAML(contents)

      case 'toml':
        return parseTOML(contents)
    }
  }

  async function parseJSON(contents) {
    try {
      return JSON.parse(contents)
    } catch (e) {
      console.log(e)
      await showMessage(
        'Invalid JSON in your configuration. Please fix it to use configuration',
      )
      return {}
    }
  }

  async function parseJSON5(contents) {
    try {
      const value = lib.parse(contents)
      return value
    } catch (e) {
      console.log(e)
      await showMessage(
        'Invalid JSON5 in your configuration. Please fix it to use configuration',
      )
      return {}
    }
  }

  async function parseYAML(contents) {
    try {
      const value = yaml.parse(contents)

      if (typeof value === 'object') {
        return value
      } else {
        return {}
      }
    } catch (e) {
      console.log(e)
      await showMessage(
        'Invalid YAML in your configuration. Please fix it to use configuration',
      )
      return {}
    }
  }

  async function parseTOML(contents) {
    try {
      const value = toml.parse(contents)

      if (typeof value === 'object') {
        return value
      } else {
        return {}
      }
    } catch (e) {
      console.log(e)
      await showMessage(
        'Invalid TOML in your configuration. Please fix it to use configuration',
      )
      return {}
    }
  }

  async function addTemplate() {
    const templateFolder = await getTemplateFolder()

    if (templateFolder == null) {
      await makeTemplateFolder()
      await showMessage('Try using this command again to use a template')
      return
    }

    const options = DataStore.projectNotes
      .filter((n) => n.filename?.startsWith(templateFolder))
      .filter((n) => !n.title?.startsWith('_configuration'))
      .map((note) =>
        note.title == null
          ? null
          : {
              label: note.title,
              value: note,
            },
      )
      .filter(Boolean)
    const selectedTemplate = await chooseOption('Choose Template', options)
    let templateContent = selectedTemplate?.content

    if (templateContent == null) {
      return
    }

    templateContent = templateContent.split('\n---\n').slice(1).join('\n---\n')
    const config = (await getDefaultConfiguration()) ?? {}
    const processedTemplateContent = await processTemplate(
      templateContent,
      config,
    )
    Editor.content = [Editor.content, processedTemplateContent]
      .filter(Boolean)
      .join('\n')
  }

  async function processTemplate(content, config) {
    const tagStart = content.indexOf('{{')
    const tagEnd = content.indexOf('}}')
    const hasTag = tagStart !== -1 && tagEnd !== -1 && tagStart < tagEnd

    if (!hasTag) {
      return content
    }

    const beforeTag = content.slice(0, tagStart)
    const afterTag = content.slice(tagEnd + 2)
    const tag = content.slice(tagStart + 2, tagEnd)

    try {
      const tagProcessed = await processTag(tag, config)
      const restProcessed = await processTemplate(afterTag, config)
      return beforeTag + tagProcessed + restProcessed
    } catch (e) {
      console.log(e)
      return content
    }
  }

  async function processTag(tag, config) {
    if (tag.startsWith('date(') && tag.endsWith(')')) {
      return await processDate(tag.slice(5, tag.length - 1), config)
    }

    const valueInConfig = tag // eslint-disable-next-line no-useless-escape
      .split(/[\.\[\]]/)
      .filter(Boolean)
      .reduce(
        (path, key) =>
          path != null && typeof path === 'object' ? path[key] : null,
        config.tagValue,
      )

    if (valueInConfig != null) {
      return String(valueInConfig)
    }

    return await getInput(`Value for ${tag}`)
  }

  async function processDate(dateConfig, config) {
    const defaultConfig = config.date ?? {}
    const paramConfig = dateConfig.trim() ? await parseJSON5(dateConfig) : {} // console.log(`param config: ${dateConfig} as ${JSON.stringify(paramConfig)}`);

    const finalArguments = { ...defaultConfig, ...paramConfig }
    const { locale, ...otherParams } = finalArguments
    const localeParam = locale != null ? String(locale) : []
    const secondParam = {
      dateStyle: 'short',
      ...otherParams,
    } // console.log(`${JSON.stringify(localeParam)}, ${JSON.stringify(secondParam)}`);

    return new Intl.DateTimeFormat(localeParam, secondParam).format(new Date())
  }

  function newNoteWithTemplate() {
    console.log('newNoteWithTemplate run')
  }

  exports.addTemplate = addTemplate
  exports.newNoteWithTemplate = newNoteWithTemplate

  Object.defineProperty(exports, '__esModule', { value: true })

  return exports
})({})
Object.assign(globalThis, exports)
